<?xml version="1.0"?>
<doc>
    <assembly>
        "NMotive"
    </assembly>
    <members>
        <member name="M:NMotive.TakeMetadata.Finalize">
            <exclude />
        </member>
        <member name="M:NMotive.TakeMetadata.Dispose">
            <exclude />
        </member>
        <member name="M:NMotive.TakeMetadata.HasData(NMotive.Take.DataType)">
            <summary>
Returns <c>true</c> if this take contains the given
data type.
</summary>
            <param name="dataType">The type of data.</param>
            <returns>
                <c>true</c> if this take contains the given data type.</returns>
        </member>
        <member name="M:NMotive.TakeMetadata.HasGaps">
            <summary>
Checks if the take has gaps.
</summary>
            <returns>
                <c>true</c> if the take has gaps.</returns>
        </member>
        <member name="P:NMotive.TakeMetadata.Best">
            <summary>
Gets the "best" property of the take.
</summary>
        </member>
        <member name="P:NMotive.TakeMetadata.Scene">
            <summary>
Access to the contained NodeWarehouse
</summary>
        </member>
        <member name="P:NMotive.TakeMetadata.FileName">
            <summary>
Gets the name of the file associated with the take.
</summary>
        </member>
        <member name="P:NMotive.TakeMetadata.FullFrameRange">
            <summary>
Gets the full frame range for the take as a frame range.
</summary>
        </member>
        <member name="P:NMotive.TakeMetadata.FullTimeRange">
            <summary>
Gets the full time range for the take as a tuple where the first member 
is the start time and the second member is the end time.
</summary>
        </member>
        <member name="P:NMotive.TakeMetadata.FrameTime">
            <summary>
Gets the master frame time (in seconds per frame).
</summary>
        </member>
        <member name="P:NMotive.TakeMetadata.Notes">
            <summary>
Gets the notes field for this take.
</summary>
        </member>
        <member name="P:NMotive.TakeMetadata.Name">
            <summary>
Gets the name for this take.
</summary>
        </member>
        <member name="P:NMotive.TakeMetadata.FrameRate">
            <summary>
Gets the frame rate for this take.
</summary>
        </member>
        <member name="P:NMotive.TakeMetadata.ID">
            <summary>
Gets the unique ID for this take.
</summary>
        </member>
        <member name="M:NMotive.TakeMetadata.#ctor(System.String)">
            <summary>
Constructs a <c>TakeMetadata</c> from the given take file.
</summary>
            <param name="takeFilePath">Take file path.</param>
        </member>
        <member name="F:NMotive.TakeMetadata.mSession">
            <exclude />
        </member>
        <member name="F:NMotive.TakeMetadata.mNativeStreamWarehouse">
            <exclude />
        </member>
        <member name="F:NMotive.TakeMetadata.mNativeTake">
            <exclude />
        </member>
        <member name="T:NMotive.TakeMetadata">
            <summary>
Contains read-only meta data for a take. Construction of objects of type
<c>TakeMetadata</c> is more efficient than contructing full <c>Take</c> objects.
If you want to access read-only information about a take without doing any processing
or editing, prefer the <c>TakeMetadata</c> class as it is much faster.
</summary>
        </member>
        <member name="T:MoCapCore.cStructuredStreamWarehouse">
            <summary>
A full implementation of the cIDataStreamWarehouse interface that implements a files-within-a-file structure.
</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouseFactory.TypeName">
            <summary>
Type name for stream warehouse instances created by this factory. This is just the name that will
be used to request instances, and does not necessarily have to correspond to the class name.
</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouseFactory.CreateInstance">
            <summary>
Creates a new instance of a requested cIDataStreamWarehouse type. Ownership of the newly created 
instance is transferred to the caller.
</summary>
        </member>
        <member name="T:MoCapCore.cIDataStreamWarehouseFactory">
            <summary>
Abstract base class for all cDataStreamWarehouse factories.
</summary>
        </member>
        <member name="M:MoCapCore.cDataStreamWarehouse.AddStream(MoCapCore.cIDataStream*)">
            <summary>Concrete implementations should call this method at the end of OpenStream
to add a new stream to the list of open streams.
</summary>
        </member>
        <member name="M:MoCapCore.cDataStreamWarehouse.CloseAllStreams">
            <summary>Close any open streams.</summary>
        </member>
        <member name="T:MoCapCore.cDataStreamWarehouse">
            <summary>
A partial implementation of the cIDataStreamWarehouse interface to use as a base class for
concrete implementations.
</summary>
        </member>
        <member name="M:MoCapCore.cINodeFactoryWarehouse.FindFactory(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Find the factory of the given type.</summary>
        </member>
        <member name="M:MoCapCore.cINodeFactoryWarehouse.CreateNode(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Create a new node of the given type name.</summary>
        </member>
        <member name="M:MoCapCore.cINodeFactoryWarehouse.AddTypeAlias(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Add a type name alias (usually for legacy purposes) that will map an alias to an existing
type name. The type name must already exist in the warehouse.</summary>
        </member>
        <member name="M:MoCapCore.cINodeFactoryWarehouse.AddFactory(std.unique_ptr&lt;MoCapCore.cINodeFactory,std.default_delete&lt;MoCapCore.cINodeFactory&gt;&gt;)">
            <summary>Add a factory to the warehouse. Ownership is transferred here.</summary>
        </member>
        <member name="T:MoCapCore.cINodeFactoryWarehouse">
            <summary>Interface class that provides ability to create node instances of named class types.</summary>
        </member>
        <member name="M:MotiveCore.cCameraFrameFactory.CreateInstance">
            <summary>Create a new instance of a camera frame.</summary>
        </member>
        <member name="M:NMotive.FindGaps.Find(NMotive.Take)">
            <summary>
Finds gaps in the given take.
</summary>
            <param name="take">The take.</param>
            <returns>A dictionary with marker keys and gaps, represented as 
a set of <c>FrameRange</c>'s, as values.</returns>
        </member>
        <member name="P:NMotive.FindGaps.MaxGapSize">
            <summary>
Gets and sets the maximum gap size in frames. Gaps with 
lengths strictly greater than <c>MaxGapSize</c> will be not be
reported.
</summary>
        </member>
        <member name="M:NMotive.FindGaps.#ctor(System.Int32)">
            <summary>
Constructs a <c>FindGaps</c> instance with the given maximum gap
size in frames.
</summary>
            <param name="maxGapSize">Maximum gap size in frames to find. Gaps with 
lengths strictly greater than <c>maxGapSize</c> will be not be
reported.</param>
        </member>
        <member name="M:NMotive.FindGaps.#ctor">
            <summary>
Constructs a <c>FindGaps</c> instance. The default maximum gap
size is 10 frames.
</summary>
        </member>
        <member name="M:NMotive.FindGaps.#cctor">
            <exclude />
        </member>
        <member name="M:NMotive.FindGaps.Marker.GetHashCode">
            <summary>
Gets the hashcode for this marker.
</summary>
            <returns>Hash code for this object.</returns>
        </member>
        <member name="M:NMotive.FindGaps.Marker.CompareTo(NMotive.FindGaps.Marker)">
            <summary>
Function for comparing to markers. Markers are compared using their
unique ID's.
</summary>
            <param name="rhs">Marker to compare self to.</param>
            <returns>Standard integer comparison value.</returns>
        </member>
        <member name="M:NMotive.FindGaps.Marker.Equals(NMotive.FindGaps.Marker)">
            <summary>
Determines if two markers are equal. Markers are equal if the have
the same unique ID.
</summary>
            <param name="rhs">The maker to compare self to.</param>
            <returns>
                <c>true</c> if this marker is equal to <c>rhs</c></returns>
        </member>
        <member name="P:NMotive.FindGaps.Marker.Name">
            <summary>
Gets the markers name.
</summary>
        </member>
        <member name="P:NMotive.FindGaps.Marker.ID">
            <summary>
Gets the markers ID.
</summary>
        </member>
        <member name="M:NMotive.FindGaps.Marker.#ctor(NMotive.UID,System.String)">
            <summary>
Constructs a <c>Marker</c> object with the given name and ID.
</summary>
            <param name="id">The marker unique ID.</param>
            <param name="name">The marker name.</param>
        </member>
        <member name="T:NMotive.FindGaps.Marker">
            <summary>
Class encapsulating a marker name and ID. Implements the IEquatable{Marker}
and IComparable{Marker} interfaces.
</summary>
        </member>
        <member name="T:NMotive.FindGaps">
            <summary>
Class for finding gaps in 3D data which have frame lengths less than
or equal to a specified number of frames.
</summary>
        </member>
        <member name="T:MoCapCore.cFindGapOp">
            <summary>
Either change the label of the passed marker, or combine it with an existing marker in the scene if
one already exists.
</summary>
        </member>
        <member name="F:MotiveCore.cMarkerNameImporter.kMarkerSticksElement">
            <summary>Marker sticks section tag name.</summary>
        </member>
        <member name="F:MotiveCore.cMarkerNameImporter.kMarkerColorsElement">
            <summary>Marker colors section tag name.</summary>
        </member>
        <member name="F:MotiveCore.cMarkerNameImporter.kMarkerNamesElement">
            <summary>Marker name section tag name.</summary>
        </member>
        <member name="T:MotiveCore.cMarkerNameImporter">
            <summary>
Importer class for skeleton marker name maps, marker stick definitions, and marker colors.
</summary>
        </member>
        <member name="M:tinyxml2wc.XMLPrinter.CStrSize">
If in print to memory mode, return the size
of the XML file in memory. (Note the size returned
includes the terminating null.)

</member>
        <member name="M:tinyxml2wc.XMLPrinter.CStr">
If in print to memory mode, return a pointer to
the XML file in memory.

</member>
        <member name="M:tinyxml2wc.XMLPrinter.PushComment(System.Char!System.Runtime.CompilerServices.IsConst*)">
Add a comment
</member>
        <member name="M:tinyxml2wc.XMLPrinter.PushText(System.Double)">
Add a text node from a double.
</member>
        <member name="M:tinyxml2wc.XMLPrinter.PushText(System.Single)">
Add a text node from a float.
</member>
        <member name="M:tinyxml2wc.XMLPrinter.PushText(System.Boolean)">
Add a text node from a bool.
</member>
        <member name="M:tinyxml2wc.XMLPrinter.PushText(System.UInt32)">
Add a text node from an unsigned.
</member>
        <member name="M:tinyxml2wc.XMLPrinter.PushText(System.Int32)">
Add a text node from an integer.
</member>
        <member name="M:tinyxml2wc.XMLPrinter.PushText(System.Char!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
Add a text node.
</member>
        <member name="M:tinyxml2wc.XMLPrinter.CloseElement">
If streaming, close the Element.
</member>
        <member name="M:tinyxml2wc.XMLPrinter.PushAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*)">
If streaming, add an attribute to an open element.
</member>
        <member name="M:tinyxml2wc.XMLPrinter.OpenElement(System.Char!System.Runtime.CompilerServices.IsConst*)">
If streaming, start writing an element.
        The element must be closed with CloseElement()

</member>
        <member name="M:tinyxml2wc.XMLPrinter.PushHeader(System.Boolean,System.Boolean)">
If streaming, write the BOM and declaration. 
</member>
        <member name="M:tinyxml2wc.XMLPrinter.#ctor(_iobuf*,System.Boolean)">
Construct the printer. If the FILE* is specified,
        this will print to the FILE. Else it will print
        to memory, and the result is available in CStr().
        If 'compact' is set to true, then output is created
        with only required whitespace and newlines.

</member>
        <member name="T:tinyxml2wc.XMLConstHandle">
A variant of the XMLHandle class for working with const XMLNodes and Documents. It is the
same in all regards, except for the 'const' qualifiers. See XMLHandle for API.

</member>
        <member name="M:tinyxml2wc.XMLHandle.ToDeclaration">
Safe cast to XMLDeclaration. This can return null.
</member>
        <member name="M:tinyxml2wc.XMLHandle.ToUnknown">
Safe cast to XMLUnknown. This can return null.
</member>
        <member name="M:tinyxml2wc.XMLHandle.ToText">
Safe cast to XMLText. This can return null.
</member>
        <member name="M:tinyxml2wc.XMLHandle.ToElement">
Safe cast to XMLElement. This can return null.
</member>
        <member name="M:tinyxml2wc.XMLHandle.ToNode">
Safe cast to XMLNode. This can return null.
</member>
        <member name="M:tinyxml2wc.XMLHandle.NextSiblingElement(System.Char!System.Runtime.CompilerServices.IsConst*)">
Get the next sibling element of this handle.
</member>
        <member name="M:tinyxml2wc.XMLHandle.NextSibling">
Get the next sibling of this handle.
</member>
        <member name="M:tinyxml2wc.XMLHandle.PreviousSiblingElement(System.Char!System.Runtime.CompilerServices.IsConst*)">
Get the previous sibling element of this handle.
</member>
        <member name="M:tinyxml2wc.XMLHandle.PreviousSibling">
Get the previous sibling of this handle.
</member>
        <member name="M:tinyxml2wc.XMLHandle.LastChildElement(System.Char!System.Runtime.CompilerServices.IsConst*)">
Get the last child element of this handle.
</member>
        <member name="M:tinyxml2wc.XMLHandle.LastChild">
Get the last child of this handle.
</member>
        <member name="M:tinyxml2wc.XMLHandle.FirstChildElement(System.Char!System.Runtime.CompilerServices.IsConst*)">
Get the first child element of this handle.
</member>
        <member name="M:tinyxml2wc.XMLHandle.FirstChild">
Get the first child of this handle.
</member>
        <member name="M:tinyxml2wc.XMLHandle.op_Assign(tinyxml2wc.XMLHandle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment
</member>
        <member name="M:tinyxml2wc.XMLHandle.#ctor(tinyxml2wc.XMLHandle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:tinyxml2wc.XMLHandle.#ctor(tinyxml2wc.XMLNode*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a handle from a node.
</member>
        <member name="M:tinyxml2wc.XMLHandle.#ctor(tinyxml2wc.XMLNode*)">
Create a handle from any node (at any depth of the tree.) This can be a null pointer.
</member>
        <member name="M:tinyxml2wc.TiXMLDocument.PrintError">
If there is an error, print it to stdout.
</member>
        <member name="M:tinyxml2wc.TiXMLDocument.GetErrorStr2">
Return a possibly helpful secondary diagnostic location or string.
</member>
        <member name="M:tinyxml2wc.TiXMLDocument.GetErrorStr1">
Return a possibly helpful diagnostic location or string.
</member>
        <member name="M:tinyxml2wc.TiXMLDocument.ErrorID">
Return the errorID.
</member>
        <member name="M:tinyxml2wc.TiXMLDocument.Error">
Return true if there was an error parsing the document.
</member>
        <member name="M:tinyxml2wc.TiXMLDocument.DeleteNode(tinyxml2wc.XMLNode*)">
Delete a node associated with this document.
It will be unlinked from the DOM.

</member>
        <member name="M:tinyxml2wc.TiXMLDocument.NewUnknown(System.Char!System.Runtime.CompilerServices.IsConst*)">
Create a new Unknown associated with
this Document. The memory forthe object
is managed by the Document.

</member>
        <member name="M:tinyxml2wc.TiXMLDocument.NewText(System.Char!System.Runtime.CompilerServices.IsConst*)">
Create a new Text associated with
this Document. The memory for the Text
is managed by the Document.

</member>
        <member name="M:tinyxml2wc.TiXMLDocument.NewComment(System.Char!System.Runtime.CompilerServices.IsConst*)">
Create a new Comment associated with
this Document. The memory for the Comment
is managed by the Document.

</member>
        <member name="M:tinyxml2wc.TiXMLDocument.NewElement(System.Char!System.Runtime.CompilerServices.IsConst*)">
Create a new Element associated with
this Document. The memory for the Element
is managed by the Document.

</member>
        <member name="M:tinyxml2wc.TiXMLDocument.RootElement">
Return the root element of DOM. Equivalent to FirstChildElement().
        To get the first node, use FirstChild().

</member>
        <member name="M:tinyxml2wc.TiXMLDocument.SetBOM(System.Boolean)">
Sets whether to write the BOM when writing the file.

</member>
        <member name="M:tinyxml2wc.TiXMLDocument.HasBOM">
Returns true if this document has a leading Byte Order Mark of UTF8.

</member>
        <member name="M:tinyxml2wc.TiXMLDocument.SaveFile(_iobuf*,System.Boolean)">
        Save the XML file to disk. You are responsible
        for providing and closing the FILE*.

        Returns XML_NO_ERROR (0) on success, or
        an errorID.

</member>
        <member name="M:tinyxml2wc.TiXMLDocument.SaveFile(System.Char!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
Save the XML file to disk.
Returns XML_NO_ERROR (0) on success, or
an errorID.

</member>
        <member name="M:tinyxml2wc.TiXMLDocument.LoadFile(_iobuf*)">
        Load an XML file from disk. You are responsible
        for providing and closing the FILE*.

        Returns XML_NO_ERROR (0) on success, or
        an errorID.

</member>
        <member name="M:tinyxml2wc.TiXMLDocument.LoadFile(System.Char!System.Runtime.CompilerServices.IsConst*)">
Load an XML file from disk.
Returns XML_NO_ERROR (0) on success, or
an errorID.

</member>
        <member name="M:tinyxml2wc.TiXMLDocument.Parse(System.Char!System.Runtime.CompilerServices.IsConst*,System.UInt64)">
        Parse an XML file from a character string.
        Returns XML_NO_ERROR (0) on success, or
        an errorID.

        You may optionally pass in the 'nBytes', which is
        the number of bytes which will be parsed. If not
        specified, TinyXML will assume 'xml' points to a
        null terminated string.

</member>
        <member name="M:tinyxml2wc.TiXMLDocument.#ctor(System.Boolean,tinyxml2wc.Whitespace)">
constructor
</member>
        <member name="T:tinyxml2wc.TiXMLDocument">
A Document binds together all the functionality.
    It can be saved, loaded, and printed to the screen.
    All Nodes are connected and allocated to a Document.
    If the Document is deleted, all its Nodes are also deleted.

</member>
        <member name="M:tinyxml2wc.XMLElement.QueryFloatText(System.Single*)">
See QueryIntText()
</member>
        <member name="M:tinyxml2wc.XMLElement.QueryDoubleText(System.Double*)">
See QueryIntText()
</member>
        <member name="M:tinyxml2wc.XMLElement.QueryBoolText(System.Boolean*)">
See QueryIntText()
</member>
        <member name="M:tinyxml2wc.XMLElement.QueryUnsignedText(System.UInt32*)">
See QueryIntText()
</member>
        <member name="M:tinyxml2wc.XMLElement.GetText">
Convenience function for easy access to the text inside an element. Although easy
        and concise, GetText() is limited compared to getting the TiXmlText child
        and accessing it directly.

        If the first child of 'this' is a TiXmlText, the GetText()
        returns the character string of the Text node, else null is returned.

        This is a convenient method for getting the text of simple contained text:
        @verbatim
        <foo>This is text</foo>
        const char* str = fooElement-&gt;GetText();
        @endverbatim

        'str' will be a pointer to "This is text".

        Note that this function can be misleading. If the element foo was created from
        this XML:
        @verbatim
        <foo><b>This is text</b></foo>
        @endverbatim

        then the value of str would be null. The first child node isn't a text node, it is
        another element. From this XML:
        @verbatim
        <foo>This is <b>text</b></foo>
        @endverbatim
        GetText() will return "This is ".

</member>
        <member name="M:tinyxml2wc.XMLElement.FindAttribute(System.Char!System.Runtime.CompilerServices.IsConst*)">
Query a specific attribute in the list.
</member>
        <member name="M:tinyxml2wc.XMLElement.FirstAttribute">
Return the first attribute in the list.
</member>
        <member name="M:tinyxml2wc.XMLElement.DeleteAttribute(System.Char!System.Runtime.CompilerServices.IsConst*)">
Delete an attribute.

</member>
        <member name="M:tinyxml2wc.XMLElement.SetAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.Int64)">
Sets the named attribute to value.
</member>
        <member name="M:tinyxml2wc.XMLElement.SetAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.Double)">
Sets the named attribute to value.
</member>
        <member name="M:tinyxml2wc.XMLElement.SetAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
Sets the named attribute to value.
</member>
        <member name="M:tinyxml2wc.XMLElement.SetAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Sets the named attribute to value.
</member>
        <member name="M:tinyxml2wc.XMLElement.SetAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Sets the named attribute to value.
</member>
        <member name="M:tinyxml2wc.XMLElement.SetAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*)">
Sets the named attribute to value.
</member>
        <member name="M:tinyxml2wc.XMLElement.QueryFloatAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.Single*)">
See QueryIntAttribute()
</member>
        <member name="M:tinyxml2wc.XMLElement.QueryDoubleAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.Double*)">
See QueryIntAttribute()
</member>
        <member name="M:tinyxml2wc.XMLElement.QueryBoolAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.Boolean*)">
See QueryIntAttribute()
</member>
        <member name="M:tinyxml2wc.XMLElement.QueryUnsignedAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.UInt32*)">
See QueryIntAttribute()
</member>
        <member name="M:tinyxml2wc.XMLElement.FloatAttribute(System.Char!System.Runtime.CompilerServices.IsConst*)">
See IntAttribute()
</member>
        <member name="M:tinyxml2wc.XMLElement.DoubleAttribute(System.Char!System.Runtime.CompilerServices.IsConst*)">
See IntAttribute()
</member>
        <member name="M:tinyxml2wc.XMLElement.BoolAttribute(System.Char!System.Runtime.CompilerServices.IsConst*)">
See IntAttribute()
</member>
        <member name="M:tinyxml2wc.XMLElement.UnsignedAttribute(System.Char!System.Runtime.CompilerServices.IsConst*)">
See IntAttribute()
</member>
        <member name="M:tinyxml2wc.XMLElement.IntAttribute(System.Char!System.Runtime.CompilerServices.IsConst*)">
Given an attribute name, IntAttribute() returns the value
        of the attribute interpreted as an integer. 0 will be
        returned if there is an error. For a method with error
        checking, see QueryIntAttribute()

</member>
        <member name="M:tinyxml2wc.XMLElement.Attribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*)">
Given an attribute name, Attribute() returns the value
        for the attribute of that name, or null if none
        exists. For example:

        @verbatim
        const char* value = ele-&gt;Attribute( "foo" );
        @endverbatim

        The 'value' parameter is normally null. However, if specified,
        the attribute will only be returned if the 'name' and 'value'
        match. This allow you to write code:

        @verbatim
        if ( ele-&gt;Attribute( "foo", "bar" ) ) callFooIsBar();
        @endverbatim

        rather than:
        @verbatim
        if ( ele-&gt;Attribute( "foo" ) ) {
        if ( strcmp( ele-&gt;Attribute( "foo" ), "bar" ) == 0 ) callFooIsBar();
        }
        @endverbatim

</member>
        <member name="M:tinyxml2wc.XMLElement.SetName(System.Char!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
Set the name of the element.
</member>
        <member name="M:tinyxml2wc.XMLElement.Name">
Get the name of an element (which is the Value() of the node.)
</member>
        <member name="T:tinyxml2wc.XMLElement">
The element is a container class. It has a value, the element name,
    and can contain other elements, text, comments, and unknowns.
    Elements also contain an arbitrary number of attributes.

</member>
        <member name="M:tinyxml2wc.XMLAttribute.SetAttribute(System.Int64)">
Set the attribute to value.
</member>
        <member name="M:tinyxml2wc.XMLAttribute.SetAttribute(System.Single)">
Set the attribute to value.
</member>
        <member name="M:tinyxml2wc.XMLAttribute.SetAttribute(System.Double)">
Set the attribute to value.
</member>
        <member name="M:tinyxml2wc.XMLAttribute.SetAttribute(System.Boolean)">
Set the attribute to value.
</member>
        <member name="M:tinyxml2wc.XMLAttribute.SetAttribute(System.UInt32)">
Set the attribute to value.
</member>
        <member name="M:tinyxml2wc.XMLAttribute.SetAttribute(System.Int32)">
Set the attribute to value.
</member>
        <member name="M:tinyxml2wc.XMLAttribute.SetAttribute(System.Char!System.Runtime.CompilerServices.IsConst*)">
Set the attribute to a string value.
</member>
        <member name="M:tinyxml2wc.XMLAttribute.QueryFloatValue(System.Single*)">
See QueryIntAttribute
</member>
        <member name="M:tinyxml2wc.XMLAttribute.QueryDoubleValue(System.Double*)">
See QueryIntAttribute
</member>
        <member name="M:tinyxml2wc.XMLAttribute.QueryBoolValue(System.Boolean*)">
See QueryIntAttribute
</member>
        <member name="M:tinyxml2wc.XMLAttribute.QueryUnsignedValue(System.UInt32*)">
See QueryIntAttribute
</member>
        <member name="M:tinyxml2wc.XMLAttribute.QueryIntValue(System.Int32*)">
QueryIntAttribute interprets the attribute as an integer, and returns the value
        in the provided paremeter. The function will return XML_NO_ERROR on success,
        and XML_WRONG_ATTRIBUTE_TYPE if the conversion is not successful.

</member>
        <member name="M:tinyxml2wc.XMLAttribute.FloatValue">
Query as a float. See IntAttribute()
</member>
        <member name="M:tinyxml2wc.XMLAttribute.DoubleValue">
Query as a double. See IntAttribute()
</member>
        <member name="M:tinyxml2wc.XMLAttribute.BoolValue">
Query as a boolean. See IntAttribute()
</member>
        <member name="M:tinyxml2wc.XMLAttribute.UnsignedValue">
Query as an unsigned integer. See IntAttribute()
</member>
        <member name="M:tinyxml2wc.XMLAttribute.IntValue">
IntAttribute interprets the attribute as an integer, and returns the value.
        If the value isn't an integer, 0 will be returned. There is no error checking;
        use QueryIntAttribute() if you need error checking.

</member>
        <member name="M:tinyxml2wc.XMLAttribute.Next">
The next attribute in the list.
</member>
        <member name="M:tinyxml2wc.XMLAttribute.Value">
The value of the attribute.
</member>
        <member name="M:tinyxml2wc.XMLAttribute.Name">
The name of the attribute.
</member>
        <member name="T:tinyxml2wc.XMLAttribute">
An attribute is a name-value pair. Elements have an arbitrary
    number of attributes, each with a unique name.

    @note The attributes are not XMLNodes. You may only query the
    Next() attribute in a list.

</member>
        <member name="T:tinyxml2wc.XMLUnknown">
Any tag that tinyXml doesn't recognize is saved as an
    unknown. It is a tag of text, but should not be modified.
    It will be written back to the XML, unchanged, when the file
    is saved.

    DTD tags get thrown into TiXmlUnknowns.

</member>
        <member name="T:tinyxml2wc.XMLComment">
An XML Comment. 
</member>
        <member name="M:tinyxml2wc.XMLText.CData">
Returns true if this is a CDATA text element.
</member>
        <member name="M:tinyxml2wc.XMLText.SetCData(System.Boolean)">
Declare whether this should be CDATA or standard text.
</member>
        <member name="T:tinyxml2wc.XMLText">
XML text.

    Note that a text node can have child element nodes, for example:
    @verbatim
    <root>This is <b>bold</b></root>
    @endverbatim

    A text node can have 2 ways to output the next. "normal" output
    and CDATA. It will default to the mode it was parsed from the XML file and
    you generally want to leave it alone, but you can change the output mode with
    SetCDATA() and query it with CDATA().

</member>
        <member name="M:tinyxml2wc.XMLNode.ShallowEqual(tinyxml2wc.XMLNode!System.Runtime.CompilerServices.IsConst*)">
        Test if 2 nodes are the same, but don't test children.
        The 2 nodes do not need to be in the same Document.

        Note: if called on a TiXMLDocument, this will return false.

</member>
        <member name="M:tinyxml2wc.XMLNode.ShallowClone(tinyxml2wc.TiXMLDocument*)">
        Make a copy of this node, but not its children.
        You may pass in a Document pointer that will be
        the owner of the new Node. If the 'document' is
        null, then the node returned will be allocated
        from the current Document. (this-&gt;GetDocument())

        Note: if called on a TiXMLDocument, this will return null.

</member>
        <member name="M:tinyxml2wc.XMLNode.DeleteChild(tinyxml2wc.XMLNode*)">
Delete a child of this node.

</member>
        <member name="M:tinyxml2wc.XMLNode.DeleteChildren">
Delete all the children of this node.

</member>
        <member name="M:tinyxml2wc.XMLNode.InsertAfterChild(tinyxml2wc.XMLNode*,tinyxml2wc.XMLNode*)">
Add a node after the specified child node.

</member>
        <member name="M:tinyxml2wc.XMLNode.InsertFirstChild(tinyxml2wc.XMLNode*)">
Add a child node as the first (left) child.

</member>
        <member name="M:tinyxml2wc.XMLNode.InsertEndChild(tinyxml2wc.XMLNode*)">
Add a child node as the last (right) child.

</member>
        <member name="M:tinyxml2wc.XMLNode.NextSiblingElement(System.Char!System.Runtime.CompilerServices.IsConst*)">
Get the next (right) sibling element of this node, with an opitionally supplied name.
</member>
        <member name="M:tinyxml2wc.XMLNode.NextSibling">
Get the next (right) sibling node of this node.
</member>
        <member name="M:tinyxml2wc.XMLNode.PreviousSiblingElement(System.Char!System.Runtime.CompilerServices.IsConst*)">
Get the previous (left) sibling element of this node, with an opitionally supplied name.
</member>
        <member name="M:tinyxml2wc.XMLNode.PreviousSibling">
Get the previous (left) sibling node of this node.
</member>
        <member name="M:tinyxml2wc.XMLNode.LastChildElement(System.Char!System.Runtime.CompilerServices.IsConst*)">
Get the last child element or optionally the last child
        element with the specified name.

</member>
        <member name="M:tinyxml2wc.XMLNode.LastChild">
Get the last child node, or null if none exists.
</member>
        <member name="M:tinyxml2wc.XMLNode.FirstChildElement(System.Char!System.Runtime.CompilerServices.IsConst*)">
Get the first child element, or optionally the first child
        element with the specified name.

</member>
        <member name="M:tinyxml2wc.XMLNode.FirstChild">
Get the first child node, or null if none exists.
</member>
        <member name="M:tinyxml2wc.XMLNode.NoChildren">
Returns true if this node has no children.
</member>
        <member name="M:tinyxml2wc.XMLNode.Parent">
Get the parent of this node on the DOM.
</member>
        <member name="M:tinyxml2wc.XMLNode.SetValue(System.Char!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
Set the Value of an XML node.
        @sa Value()

</member>
        <member name="M:tinyxml2wc.XMLNode.Value">
The meaning of 'value' changes for the specific type.
        @verbatim
        Document:       empty
        Element:        name of the element
        Comment:        the comment text
        Unknown:        the tag contents
        Text:           the text string
        @endverbatim

</member>
        <member name="M:tinyxml2wc.XMLNode.ToUnknown">
Safely cast to an Unknown, or null.
</member>
        <member name="M:tinyxml2wc.XMLNode.ToDeclaration">
Safely cast to a Declaration, or null.
</member>
        <member name="M:tinyxml2wc.XMLNode.ToDocument">
Safely cast to a Document, or null.
</member>
        <member name="M:tinyxml2wc.XMLNode.ToComment">
Safely cast to a Comment, or null.
</member>
        <member name="M:tinyxml2wc.XMLNode.ToText">
Safely cast to Text, or null.
</member>
        <member name="M:tinyxml2wc.XMLNode.ToElement">
Safely cast to an Element, or null.
</member>
        <member name="M:tinyxml2wc.XMLNode.GetDocument">
Get the TiXMLDocument that owns this XMLNode.

Get the TiXMLDocument that owns this XMLNode.
</member>
        <member name="T:tinyxml2wc.XMLNode">
XMLNode is a base class for every object that is in the
    XML Document Object Model (DOM), except XMLAttributes.
    Nodes have siblings, a parent, and children which can
    be navigated. A node is always in a TiXMLDocument.
    The type of a XMLNode can be queried, and it can
    be cast to its more defined type.

    A TiXMLDocument allocates memory for all its Nodes.
    When the TiXMLDocument gets deleted, all its Nodes
    will also be deleted.

    @verbatim
    A Document can contain: Element (container or leaf)
    Comment (leaf)
    Unknown (leaf)
    Declaration( leaf )

    An Element can contain: Element (container or leaf)
    Text    (leaf)
    Attributes (not on tree)
    Comment (leaf)
    Unknown (leaf)

    @endverbatim

</member>
        <member name="M:tinyxml2wc.XMLVisitor.Visit(tinyxml2wc.XMLUnknown!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Visit an unknown node.
</member>
        <member name="M:tinyxml2wc.XMLVisitor.Visit(tinyxml2wc.XMLComment!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Visit a comment node.
</member>
        <member name="M:tinyxml2wc.XMLVisitor.Visit(tinyxml2wc.XMLText!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Visit a text node.
</member>
        <member name="M:tinyxml2wc.XMLVisitor.Visit(tinyxml2wc.XMLDeclaration!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Visit a declaration.
</member>
        <member name="M:tinyxml2wc.XMLVisitor.VisitExit(tinyxml2wc.XMLElement!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Visit an element.
</member>
        <member name="M:tinyxml2wc.XMLVisitor.VisitEnter(tinyxml2wc.XMLElement!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,tinyxml2wc.XMLAttribute!System.Runtime.CompilerServices.IsConst*)">
Visit an element.
</member>
        <member name="M:tinyxml2wc.XMLVisitor.VisitExit(tinyxml2wc.TiXMLDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Visit a document.
</member>
        <member name="M:tinyxml2wc.XMLVisitor.VisitEnter(tinyxml2wc.TiXMLDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Visit a document.
</member>
        <member name="T:tinyxml2wc.XMLVisitor">
    Implements the interface to the "Visitor pattern" (see the Accept() method.)
    If you call the Accept() method, it requires being passed a XMLVisitor
    class to handle callbacks. For nodes that contain other nodes (Document, Element)
    you will get called with a VisitEnter/VisitExit pair. Nodes that are always leafs
    are simply called with Visit().

    If you return 'true' from a Visit method, recursive parsing will continue. If you return
    false, <b>no children of this node or its sibilings</b> will be visited.

    All flavors of Visit methods have a default implementation that returns 'true' (continue
    visiting). You need to only override methods that are interesting to you.

    Generally Accept() is called on the TiXmlDocument, although all nodes support visiting.

    You should never change the document from a callback.

    @sa XMLNode::Accept()

</member>
        <member name="M:MotiveCore.cLicenseManager.LicenseInformationWidgetTree">
            <summary>Retrieve a Qt widget hierarchy that displays Motive license information. Caller is responsible
for freeing the returned objects.</summary>
        </member>
        <member name="M:MoCapCore.cILicenseManager.RevalidateLicense">
            <summary>Re-test primary license and determine if the license is valid.</summary>
        </member>
        <member name="M:MoCapCore.cILicenseManager.LicensingDeviceSerial">
            <summary>Returns the serial number of the licensing device.</summary>
        </member>
        <member name="M:MoCapCore.cILicenseManager.LicenseInfo(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Retrieve an XML string describing the capabilities of each license that exists on the system.
The passed string is appended to rather than replaced.</summary>
        </member>
        <member name="M:Core.cRandomNumberGenerator.GenerateBuffer(System.Byte*,System.UInt32)">
            <summary>Fills the given buffer with random values.</summary>
        </member>
        <member name="M:Core.cRandomNumberGenerator.GenerateVector(System.UInt32*,System.UInt32)">
            <summary>Fills the given array with random values.</summary>
        </member>
        <member name="M:Core.cRandomNumberGenerator.GenerateUnsignedInt(System.UInt32,System.UInt32)">
            <summary>Generate a random 32-bit unsigned integer within the given range (inclusive).</summary>
        </member>
        <member name="M:Core.cRandomNumberGenerator.GenerateUnsignedInt">
            <summary>Generate a random 32-bit unsigned integer.</summary>
        </member>
        <member name="M:Core.cRandomNumberGenerator.GenerateInt">
            <summary>Generate an integer within the full integer range.</summary>
        </member>
        <member name="M:Core.cRandomNumberGenerator.SetSeed(System.Int32)">
            <summary>Set the seed value to use.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelFactoryWarehouse.AddTypeAlias(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Add a type name alias (usually for legacy purposes) that will map an alias to an existing
type name. The type name must already exist in the warehouse.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelFactoryWarehouse.AddFactory(std.unique_ptr&lt;MoCapCore.cIChannelFactory,std.default_delete&lt;MoCapCore.cIChannelFactory&gt;&gt;)">
            <summary>Add a factory to the warehouse. Ownership is transferred here.</summary>
        </member>
        <member name="T:MoCapCore.cFileStream">
            <summary>
A concrete implementation of the cDataStream interface that abstracts the real file system.
</summary>
        </member>
        <member name="T:MoCapCore.cDataStream">
            <summary>
A partial implementation of the cIDataStream interface that provides some convenience functionality
for derived classes.
</summary>
        </member>
        <member name="M:NMotive.FBXBinaryExporter.Export(NMotive.Take,NMotive.DataStream)">
            <exclude />
            <summary>
Exports the given take to the given data stream.
</summary>
            <param name="take">The take to export</param>
            <param name="stream">The data stream to export to.</param>
            <returns>The result of the export attempt.</returns>
        </member>
        <member name="P:NMotive.FBXBinaryExporter.IsBusy">
            <summary>
Gets a property that is <c>true</c> if the this object is currently 
busy doing an export operation.
</summary>
        </member>
        <member name="P:NMotive.FBXBinaryExporter.IsBinary">
            <summary>
Gets a property that is <c>strue</c> if the export format is binary.
</summary>
        </member>
        <member name="P:NMotive.FBXBinaryExporter.Description">
            <summary>
Gets the description of this exporter.
</summary>
        </member>
        <member name="P:NMotive.FBXBinaryExporter.Name">
            <summary>
Gets the name of this exporter.
</summary>
        </member>
        <member name="M:NMotive.FBXBinaryExporter.#ctor">
            <summary>
Creates an <c>FBXBinaryExporter</c> instance with default options.
</summary>
        </member>
        <member name="T:NMotive.FBXBinaryExporter">
            <summary>
Class for exporting take data in FBX binary format.
</summary>
        </member>
        <member name="M:NMotive.FillGaps.Process(NMotive.Take,System.Collections.Generic.IList`1{NMotive.UID})">
            <summary>
Processes the given take, filling gaps for the specified markers.
</summary>
            <param name="take">The take to process.</param>
            <param name="markerIDs">Fill gaps for these markers. For pattern
based interpolation it is the list of pattern markers with the 
target marker being the first in the list. i.e. <c>markerIDs[0]</c></param>
            <returns>The result of the operation.</returns>
        </member>
        <member name="M:NMotive.FillGaps.Process(NMotive.Take,NMotive.FrameRangeSet)">
            <summary>
Processes the given take, filling gaps for the specified markers in the
specified ranges.
</summary>
            <param name="take">The take to process.</param>
            <param name="frameRanges">Fill gaps in these frame ranges.</param>
            <returns>The result of the operation.</returns>
        </member>
        <member name="M:NMotive.FillGaps.Process(NMotive.Take,NMotive.FrameRangeSet,System.Collections.Generic.IList`1{NMotive.UID})">
            <summary>
Processes the given take, filling gaps for the specified markers in the
specified ranges.
</summary>
            <param name="take">The take to process.</param>
            <param name="frameRanges">Fill gaps in these frame ranges.</param>
            <param name="markerIDs">Fills gaps for these markers. For pattern
based interpolation it is the list of pattern markers with the 
target marker being the first in the list. i.e. <c>markerIDs[0]</c></param>
            <returns>The result of the operation.</returns>
        </member>
        <member name="M:NMotive.FillGaps.Process(NMotive.Take)">
            <summary>
Processes the given take. Fill is done for all markers and all frames.
</summary>
            <param name="take">The take to process.</param>
            <returns>The result of the operation.</returns>
        </member>
        <member name="P:NMotive.FillGaps.CustomFillProvider">
            <exclude />
        </member>
        <member name="P:NMotive.FillGaps.MaxGapFillWidth">
            <summary>
Gets and sets the maximum size, in frames, 
that a gap can be for Motive to fill. Raising this will allow 
larger gaps to be filled. However, larger gaps may be more prone to 
incorrect interpolation.
</summary>
        </member>
        <member name="P:NMotive.FillGaps.InterpolationMode">
            <summary>
Gets and sets the interpolation algorithm for gap filling.
</summary>
        </member>
        <member name="M:NMotive.FillGaps.#ctor(System.Int32,NMotive.ProgressIndicator)">
            <summary>
Constructs a <c>FillGaps</c> object the given max gap fill width and progress
indicator.
</summary>
            <param name="maxGapFillWidth">The maximum size, in frames, 
that a gap can be for Motive to fill. Raising this will allow 
larger gaps to be filled. However, larger gaps may be more prone to 
incorrect interpolation.</param>
            <param name="progress">Progress indicator used by this processor.</param>
        </member>
        <member name="M:NMotive.FillGaps.#ctor(System.Int32)">
            <summary>
Constructs a <c>FillGaps</c> object the given max gap fill width.
</summary>
            <param name="maxGapFillWidth">The maximum size, in frames, 
that a gap can be for Motive to fill. Raising this will allow 
larger gaps to be filled. However, larger gaps may be more prone to 
incorrect interpolation.</param>
        </member>
        <member name="M:NMotive.FillGaps.#ctor(NMotive.ProgressIndicator)">
            <summary>
Constructs a <c>FillGaps</c> object with the given progress indicator.
</summary>
            <param name="progress">Progress indicator used by this processor.</param>
        </member>
        <member name="M:NMotive.FillGaps.#ctor">
            <summary>
Constructs a <c>FillGaps</c> object with default options.
</summary>
        </member>
        <member name="T:NMotive.FillGaps">
            <summary>
Take processor implementation for filling gaps in 3D data.
</summary>
        </member>
        <member name="T:NMotive.ICustomFillProvider">
            <exclude />
        </member>
        <member name="M:MoCapCore.cFillGapsOp.SetCustomFillProvider(MoCapCore.cICustomFillProvider*)">
            <summary>Set custom fill provider for pattern/model based fill. This object
will assume ownership of the pointer. This overload is
provided for use by NMotive/.NET only because CLI/C++ does not support smart pointer
interop (this is a bug in VS 2015). Use the unique pointer version unless you
are accessing from .NET.</summary>
        </member>
        <member name="M:MoCapCore.cFillGapsOp.SetCustomFillProvider(std.unique_ptr&lt;MoCapCore.cICustomFillProvider,std.default_delete&lt;MoCapCore.cICustomFillProvider&gt;&gt;)">
            <summary>Set custom fill provider for pattern/model based fill.</summary>
        </member>
        <member name="T:MoCapCore.cFillGapsOp">
            <summary>
Fill gaps on based on the scoping and interpolation type specified in the operation's settings.
</summary>
        </member>
        <member name="M:NMotive.ITakeProcessingScriptWithArgs.ValidateArguments(System.String[])">
            <summary>
Validates the arguments for the script. Arguments will by passed to
the script, via the <c>Arguments</c> property, only after they have
been validated by this function.
</summary>
            <param name="argString">The argument string to validate.</param>
            <returns>The result of the validation. If the argument string is validated
the <c>Success</c> field of the returned <c>Result</c> object should
be set to <c>true</c>. If validation fails the he <c>Success</c> field 
of the returned <c>Result</c> object should be set to <c>false</c> and
the <c>Message</c> field should indicate the nature of the error.</returns>
        </member>
        <member name="P:NMotive.ITakeProcessingScriptWithArgs.ArgumentLabel">
            <summary>
You can optionally supply a label to the Motive Batch Processor to 
display next to the text entry box where the user will enter script
arguments. Return <c>null</c> or an empty string if you do not wish
to supply a label.
</summary>
        </member>
        <member name="P:NMotive.ITakeProcessingScriptWithArgs.Arguments">
            <summary>
Set default values for script arguments. Script arguments are an array of
of strings, similar to a programs command line arguments. Script arguments
entered by the user in the Motive Batch Processor will be passed to the
script by this functions.
</summary>
            <remarks>
Arguments are passed to the script only after they are validated by the
<c>ValidateArguments</c> function.
</remarks>
        </member>
        <member name="P:NMotive.ITakeProcessingScriptWithArgs.DefaultArguments">
            <summary>
Get default values for script arguments. Script arguments are an array of
of strings, similar to a programs command line arguments. May return
<c>null</c> or an empty array if there are no default values.
</summary>
        </member>
        <member name="T:NMotive.ITakeProcessingScriptWithArgs">
            <summary>
Interface implemented by .NET scripts if they want to be run using the
Motive Batch Processor application and accept arguments input by the
user.
</summary>
        </member>
        <member name="M:NMotive.ITakeProcessingScript.ProcessTake(NMotive.Take,NMotive.ProgressIndicator)">
            <summary>
Process a take and, optionally, update progress.
</summary>
            <param name="takeToProcess">The take to process.</param>
            <param name="progress">Progress object that the process may
update with its progress.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="T:NMotive.ITakeProcessingScript">
            <summary>
Interface implemented by .NET scripts if they want to be run using the
Motive Batch Processor application. 
</summary>
        </member>
        <member name="M:NMotive.Settings.ImportCalibrationSettings(System.String)">
            <summary>
Import calibration settings from a file. The importation must be
done before every operation that will use them.
</summary>
            <param name="settingsFilename">Calibration settings file name.</param>
            <param name="option">The apply calibration option.</param>
            <returns>The result of the import attempt.</returns>
        </member>
        <member name="M:NMotive.Settings.ImportMotiveProfile(System.String)">
            <summary>Import a Motive profile from a file. The importation must be
done before every operation that will use the settings contained therein. 
In particular this applies for reconstruction settings in the profile file.</summary>
            <param name="profileFile">Motive profile settings file name.</param>
            <returns>The result of the import attempt.</returns>
        </member>
        <member name="T:NMotive.Settings">
            <summary>
Functions for importing global settings. Like reconstruction and
calibration settings.
</summary>
        </member>
        <member name="M:MotiveCore.cCalibrationSerializer.SaveCalibration(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cCameraCalibration!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Export a calibration to a disk file.</summary>
        </member>
        <member name="M:MotiveCore.cCalibrationSerializer.LoadCalibration(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cCameraCalibration*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Import a calibration from file on disk.</summary>
        </member>
        <member name="T:MotiveCore.cCalibrationSerializer">
            <summary>A loader/saver class for handling calibrations.</summary>
        </member>
        <member name="M:NMotive.Filter.Process(NMotive.Take,NMotive.FrameRangeSet)">
            <summary>
 Apply the filter to the all the markers in the given frame ranges in
the given take.
</summary>
            <param name="take">Take to filter.</param>
            <param name="selectedRanges">Data will be filtered in these ranges.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="M:NMotive.Filter.Process(NMotive.Take,NMotive.FrameRangeSet,System.Collections.Generic.IList`1{NMotive.UID})">
            <summary>
 Apply the filter to the given markers in the given frame ranges in
the given take.
</summary>
            <param name="take">Take to filter.</param>
            <param name="selectedRanges">Data will be filtered in these ranges.</param>
            <param name="markerIDs">ID's of the markers to filter.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="M:NMotive.Filter.Process(NMotive.Take,System.Collections.Generic.IList`1{NMotive.UID})">
            <summary>
Apply the filter to the given markers in all the frames of the 
given take.
</summary>
            <param name="take">Take to filter.</param>
            <param name="markerIDs">ID's of the markers to filter.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="M:NMotive.Filter.Process(NMotive.Take)">
            <summary>
Apply the filter to all markers in all the frames of the 
given take.
</summary>
            <param name="take">Take to filter.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="P:NMotive.Filter.CutOffFrequency">
            <summary>
Cutoff frequency in Hz for this filter. Default is 15.
</summary>
        </member>
        <member name="P:NMotive.Filter.DataRate">
            <summary>
Gets and sets the data rate property for this filter. Default
is 120.
</summary>
        </member>
        <member name="M:NMotive.Filter.#ctor(System.Double,System.Double)">
            <summary>
Constructs a <c>Filter</c> object with the given data rate and 
cutoff frequency.
</summary>
            <param name="dataRate">The data rate.</param>
            <param name="cutoffFrequency">The cutoff frequency for the filter.</param>
        </member>
        <member name="M:NMotive.Filter.#ctor">
            <summary>
Constructs a <c>Filter</c> object with default cutoff frequency
and data rate.
</summary>
        </member>
        <member name="T:NMotive.Filter">
            <summary>
Smooths 3D data by passing it through a low pass filter.
The lower the cutoff frequency setting, the more smoothed the data will
be.  High frequencies are present during sharp transitions in the data, 
such as foot-plants, but can also be introduced by noise in the data. 
Commonly used ranges for Filter Cutoff Frequency are 7-12 Hz, but you 
may want to adjust that up for fast, sharp motions to avoid softening 
transitions in the motion that need to stay sharp.
</summary>
        </member>
        <member name="T:MoCapCore.cFilterOp">
            <summary>
Either change the label of the passed marker, or combine it with an existing marker in the scene if
one already exists.
</summary>
        </member>
        <member name="M:NMotive.TrimTails.Process(NMotive.Take,System.Collections.Generic.IList`1{NMotive.UID})">
            <summary>
Trims tails of the given markers in the given frame ranges in the given take.
</summary>
            <param name="take">The take to process.</param>
            <param name="markerIDs">Trim tails on these markers only.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="M:NMotive.TrimTails.Process(NMotive.Take,NMotive.FrameRangeSet)">
            <summary>
Trims tails of the given markers in the given frame ranges in the given take.
</summary>
            <param name="take">The take to process.</param>
            <param name="selectedRanges">Trim tails in these ranges only.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="M:NMotive.TrimTails.Process(NMotive.Take,NMotive.FrameRangeSet,System.Collections.Generic.IList`1{NMotive.UID})">
            <summary>
Trims tails of the given markers in the given frame ranges in the given take.
</summary>
            <param name="take">The take to process.</param>
            <param name="selectedRanges">Trim tails in these ranges only.</param>
            <param name="markerIDs">Trim tails on these markers only.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="M:NMotive.TrimTails.Process(NMotive.Take)">
            <summary>
Trims tails in the given take.
</summary>
            <param name="take">The take to process.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="P:NMotive.TrimTails.Automatic">
            <summary>
If true the trimming algorithm will determine the number of frames
to trim. The set the maximum number of frames the algorithm is 
allowed to tr
</summary>
        </member>
        <member name="P:NMotive.TrimTails.MinimumSegmentSize">
            <summary>
When trimming tails, the tool will make sure that data segments 
(i.e. sections of data with no gaps) are not reduced below this 
number of frames. Default value is 5.
</summary>
        </member>
        <member name="P:NMotive.TrimTails.TrailingTrimSize">
            <summary>
The number of frames to trim at the end of any gaps, or the 
maximum number of frames to trim at the end of any gaps when the 
</summary>
        </member>
        <member name="P:NMotive.TrimTails.LeadingTrimSize">
            <summary>
The number of frames to trim at the beginning of any gaps, or the 
maximum number of frames to trim at the beginning of any gaps when the 
</summary>
        </member>
        <member name="P:NMotive.TrimTails.GapSizeThreshold">
            <summary>
Gets and sets the gap size threshold.
When trimming tails, a gap must be at least this large before any
trimming will be done on its leading or trailing edge.
</summary>
        </member>
        <member name="M:NMotive.TrimTails.#ctor">
            <summary>
Constructs a <c>TrimTails</c> instance with default values.
</summary>
        </member>
        <member name="F:NMotive.TrimTails.mNaitveDeleteKeys">
            <exclude />
            <summary>
Backing native implementation for delete keys.
</summary>
        </member>
        <member name="F:NMotive.TrimTails.mNativeFindTails">
            <exclude />
            <summary>
Backing native implementation for find tails.
</summary>
        </member>
        <member name="T:NMotive.TrimTails">
            <summary>
As markers pass into and out of view of the cameras, sometimes those 
partial occlusions can introduce "tails" in a trajectory near data 
gaps. The <c>TrimTails</c>class finds and removes these tails.
</summary>
        </member>
        <member name="M:MoCapCore.cDeleteKeysOp.SetUseSelectedTime(System.Boolean)">
            <summary>Set whether to use just the currently selected time range(s). Default is to use all time.</summary>
        </member>
        <member name="M:MoCapCore.cDeleteKeysOp.SetSelectedKeysOnly(System.Boolean)">
            <summary>If set, will only delete selected keys in the range. Otherwise, all keys in the range are deleted.</summary>
        </member>
        <member name="T:MoCapCore.cDeleteKeysOp">
            <summary>
Deletes all selected keys on selected nodes, optionally only in selected time ranges.
</summary>
        </member>
        <member name="T:MoCapCore.cFindTailsOp">
            <summary>
Trim keys that may be noisy near the start or end of a gap.
</summary>
        </member>
        <member name="M:MoCapCore.cOperation.#ctor(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cPropertyCollection*)">
            <summary>Takes ownership of the passed ParameterGroup.</summary>
        </member>
        <member name="T:MoCapCore.cOperation">
            <summary>Helper base class for data operations.</summary>
        </member>
        <member name="M:MoCapCore.cIOperation.Parameters">
            <summary>Get the parameter group instance for this operation.</summary>
        </member>
        <member name="M:MoCapCore.cIOperation.CanUndo">
            <summary>Returns true if the operation can be undone and redone.</summary>
        </member>
        <member name="M:MoCapCore.cIOperation.CanCancel">
            <summary>Returns true if the operation can be canceled.</summary>
        </member>
        <member name="M:MoCapCore.cIOperation.Description">
            <summary>Brief description to display.</summary>
        </member>
        <member name="M:MoCapCore.cIOperation.Label">
            <summary>Brief name to display.</summary>
        </member>
        <member name="M:MoCapCore.cIOperation.Name">
            <summary>No-spaces, Camel-case name used for operation lookup.</summary>
        </member>
        <member name="M:MoCapCore.cIOperation.Cancel">
            <summary>Call this to cancel the operation in progress.</summary>
            <returns>True if the operation could be canceled and was canceled, or was already finished.</returns>
        </member>
        <member name="M:MoCapCore.cIOperation.Run(MoCapCore.cIOperationData*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cIProgressIndicator*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>This is called to run the operation using the given progress indicator.</summary>
        </member>
        <member name="T:MoCapCore.cIOperation">
            <summary>
Abstract base class for all Operations. Operations are units of functionality that can be
executed as transactions on core data.
</summary>
        </member>
        <member name="M:MoCapCore.cOperationFactory.PropertyDefinitions">
            <summary>Returns the property collection definition for use by derived classes.</summary>
        </member>
        <member name="M:MoCapCore.cOperationFactory.AddPropertyDefinition(std.unique_ptr&lt;MoCapCore.cPropertyDefinition,std.default_delete&lt;MoCapCore.cPropertyDefinition&gt;&gt;)">
            <summary>
Derived classes call this to add parameter definitions to the definition block. Ownership
of the passed object is transferred.
</summary>
        </member>
        <member name="T:MoCapCore.cOperationFactory">
            <summary>
Helper base class for creating new operation factories. Most factories should derive from this
class to handle some of the basic object accounting.
</summary>
        </member>
        <member name="M:MoCapCore.cIOperationFactory.Description">
            <summary>A brief description of what the operations created by this factory do.</summary>
        </member>
        <member name="M:MoCapCore.cIOperationFactory.Label">
            <summary>The human-readable label associated with the operations this factory produces.</summary>
        </member>
        <member name="M:MoCapCore.cIOperationFactory.Name">
            <summary>The internal name of the operations created by this factory.</summary>
        </member>
        <member name="M:MoCapCore.cIOperationFactory.CreateProperties">
            <summary>
Creates and returns a new parameter group that can be used with operations created by
this factory. Ownership of the newly created instance is transferred to the caller.
</summary>
        </member>
        <member name="M:MoCapCore.cIOperationFactory.CreateInstance(MoCapCore.cPropertyCollection!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Creates a new instance of the operation with the given parameter list. When overriding this method,
you should Clone() the ParameterGroup in the new operation instance because the passed ParemeterGroup
is a borrowed reference. Ownership of the newly created instance is transferred to the caller.
</summary>
        </member>
        <member name="T:MoCapCore.cIOperationFactory">
            <summary>
Abstract base class for all Operation factories. Operation factories are responsible for producing
instances of their operations. To create a new operation, derive a new class from IOperationFactory
and derive your new operation from IOperation. Add a new factory instance to OperationManager.
</summary>
        </member>
        <member name="M:MoCapCore.cIOperationData.CurrentLabelWarehouse">
            <summary>Active label warehouse.</summary>
        </member>
        <member name="M:MoCapCore.cIOperationData.CurrentTimeManager">
            <summary>Retrieve a reference to the current time manager.</summary>
        </member>
        <member name="M:MoCapCore.cIOperationData.CurrentTakeManager">
            <summary>Retrieve a reference to the current take manager.</summary>
        </member>
        <member name="T:MoCapCore.cIOperationData">
            <summary>
Interface for common data objects that is passed to all operations upon running.
</summary>
        </member>
        <member name="T:MotiveCore.cBVHExporter">
            <summary>
Exporter class for BVH files
</summary>
        </member>
        <member name="M:NMotive.BVHExporter.Export(NMotive.Take,NMotive.DataStream)">
            <exclude />
            <summary>
Exports the given take to the given data stream.
</summary>
            <param name="take">The take to export</param>
            <param name="stream">The data stream to export to.</param>
            <returns>The result of the export attempt.</returns>
        </member>
        <member name="P:NMotive.BVHExporter.SkeletonName">
            <summary>
Gets and sets the name of the skeleton to export. 
The default is to export the first skeleton in the takes
list of skeletons.
</summary>
        </member>
        <member name="P:NMotive.BVHExporter.MotionBuilderNames">
            <summary>
Gets and sets whether or not to use MotionBuilder names.
</summary>
        </member>
        <member name="P:NMotive.BVHExporter.HandsDownward">
            <summary>
Gets and sets the hands downward option.
</summary>
        </member>
        <member name="P:NMotive.BVHExporter.ExcludeFingers">
            <summary>
Gets and sets the exclude fingers option.
</summary>
        </member>
        <member name="P:NMotive.BVHExporter.ExcludeToes">
            <summary>
Gets and sets the exclude toes option.
</summary>
        </member>
        <member name="P:NMotive.BVHExporter.SingleJointTorso">
            <summary>
Gets and sets the single joint torso option.
</summary>
        </member>
        <member name="P:NMotive.BVHExporter.Units">
            <summary>
Gets and sets the length units option.
This option determines the base unit of measurement for positioning
in BVH export. Default value is meters.
</summary>
        </member>
        <member name="M:NMotive.BVHExporter.#ctor">
            <summary>
Constructs a <c>BVHExporter</c> object with the default options.
</summary>
        </member>
        <member name="T:NMotive.BVHExporter">
            <summary>
Class for exporting take data in BVH format.
</summary>
        </member>
        <member name="M:NMotive.TRCExporter.Export(NMotive.Take,NMotive.DataStream)">
            <exclude />
            <summary>
Exports the given take to the given data stream.
</summary>
            <param name="take">The take to export</param>
            <param name="stream">The data stream to export to.</param>
            <returns>The result of the export attempt.</returns>
        </member>
        <member name="P:NMotive.TRCExporter.Units">
            <summary>
Gets and sets the length units option.
This option determines the base unit of measurement for positioning
in C3D export. Default value is meters.
</summary>
        </member>
        <member name="M:NMotive.TRCExporter.#ctor">
            <summary>
Constructs a <c>TRCExporter</c> object with the default options.
</summary>
        </member>
        <member name="T:NMotive.TRCExporter">
            <summary>
Class for exporting take files to TRC format.
</summary>
        </member>
        <member name="M:MotiveCore.cTRCExporter.SetScale(System.Single,System.Boolean)">
            <summary>
Sets the scale factor used for exporting values.
</summary>
            <param name="s">The scale factor to apply to exported
values. Must a decimal value be between 0 and 1.</param>
        </member>
        <member name="M:MotiveCore.cTRCExporter.SetUnits(Core.eUnits!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>
Sets the value of the property.
Units of position measurement.
</summary>
            <param name="unitsValue">The new property value.</param>
        </member>
        <member name="M:MotiveCore.cTRCExporter.Units">
            <summary>
Gets the value of the property.
Units of position measurement.
</summary>
            <returns>The property value.</returns>
        </member>
        <member name="M:MotiveCore.cTRCExporter.SetEndFrame(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>
Sets the value of the property.
Ending frame
</summary>
            <param name="endFrameValue">The new property value.</param>
        </member>
        <member name="M:MotiveCore.cTRCExporter.EndFrame">
            <summary>
Gets the value of the property.
Ending frame
</summary>
            <returns>The property value.</returns>
        </member>
        <member name="M:MotiveCore.cTRCExporter.SetStartFrame(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>
Sets the value of the property.
Starting frame
</summary>
            <param name="startFrameValue">The new property value.</param>
        </member>
        <member name="M:MotiveCore.cTRCExporter.StartFrame">
            <summary>
Gets the value of the property.
Starting frame
</summary>
            <returns>The property value.</returns>
        </member>
        <member name="M:MotiveCore.cTRCExporter.SetFrameRate(System.Double!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>
Sets the value of the property.
Data frame rate
</summary>
            <param name="frameRateValue">The new property value.</param>
        </member>
        <member name="M:MotiveCore.cTRCExporter.FrameRate">
            <summary>
Gets the value of the property.
Data frame rate
</summary>
            <returns>The property value.</returns>
        </member>
        <member name="M:NMotive.CSVExporter.Export(NMotive.Take,NMotive.DataStream)">
            <exclude />
            <summary>
Exports the given take to the given data stream.
</summary>
            <param name="take">The take to export</param>
            <param name="stream">The data stream to export to.</param>
            <returns>The result of the export attempt.</returns>
        </member>
        <member name="P:NMotive.CSVExporter.WriteHeader">
            <summary>
Gets and sets the write header property. Default is <c>true</c>.
</summary>
        </member>
        <member name="P:NMotive.CSVExporter.RotationType">
            <summary>
Gets and sets the rotation type. Default is Quaternion.
</summary>
        </member>
        <member name="P:NMotive.CSVExporter.WriteQualityStats">
            <summary>
Gets and sets the write quality statistics property. Default is <c>true</c>. 
</summary>
        </member>
        <member name="P:NMotive.CSVExporter.WriteBoneMarkers">
            <summary>
Gets and sets the write bone markers property. Default is <c>true</c>. 
</summary>
        </member>
        <member name="P:NMotive.CSVExporter.WriteBones">
            <summary>
Gets and sets the write bones property. Default is <c>true</c>. 
</summary>
        </member>
        <member name="P:NMotive.CSVExporter.WriteRigidBodyMarkers">
            <summary>
Gets and sets the write rigid body markers property. Default is <c>true</c>. 
</summary>
        </member>
        <member name="P:NMotive.CSVExporter.WriteRigidBodies">
            <summary>
Gets and sets the write rigid bodies property. Default is <c>true</c>.
</summary>
        </member>
        <member name="P:NMotive.CSVExporter.WriteMarkers">
            <summary>
Gets and sets the write markers property. Default is <c>true</c>.
</summary>
        </member>
        <member name="P:NMotive.CSVExporter.UseWorldSapceCoordinates">
            <summary>
Gets and sets the property determining whether or not to use world
coordinates.
</summary>
        </member>
        <member name="P:NMotive.CSVExporter.Units">
            <summary>
Gets and sets the length units option.
This option determines the base unit of measurement for positioning
in CSV export. Default value is meters.
</summary>
        </member>
        <member name="M:NMotive.CSVExporter.#ctor">
            <summary>
Constructs a <c>CSVExporter</c> object with the default options.
</summary>
        </member>
        <member name="T:NMotive.CSVExporter">
            <summary>
Class for exporting take files to CSV (Comma Separated Value) format.
</summary>
        </member>
        <member name="T:NMotive.Rotation">
            <summary>
Enumeration of possible rotation options.
</summary>
        </member>
        <member name="F:NMotive.Rotation.ZYX">
            <summary>zyx rotation order. Motive default.</summary>
        </member>
        <member name="F:NMotive.Rotation.ZXY">
            <summary>zxy rotation order. Motive default.</summary>
        </member>
        <member name="F:NMotive.Rotation.YZX">
            <summary>yzx rotation order. Motive default.</summary>
        </member>
        <member name="F:NMotive.Rotation.YXZ">
            <summary>yxz rotation order. Motive default.</summary>
        </member>
        <member name="F:NMotive.Rotation.XZY">
            <summary>xzy rotation order. Motive default.</summary>
        </member>
        <member name="F:NMotive.Rotation.XYZ">
            <summary>xyz rotation order. Motive default.</summary>
        </member>
        <member name="F:NMotive.Rotation.QuaternionFormat">
            <summary>Rotations in quaternion format.</summary>
        </member>
        <member name="T:MoCapCore.cStreamsManager">
            <summary>A concrete implementation of the the cIStreamsManager interface.</summary>
        </member>
        <member name="M:NMotive.FBXAsciiExporter.Export(NMotive.Take,NMotive.DataStream)">
            <exclude />
            <summary>
Exports the given take to the given data stream.
</summary>
            <param name="take">The take to export</param>
            <param name="stream">The data stream to export to.</param>
            <returns>The result of the export attempt.</returns>
        </member>
        <member name="P:NMotive.FBXAsciiExporter.OpticalMarkerNameSpace">
            <summary>
Overrides the default Optical Name Space for FBX.
</summary>
        </member>
        <member name="P:NMotive.FBXAsciiExporter.MarkerNameSeparator">
            <summary>
Chooses ':' or '_' for marker name separator.
</summary>
        </member>
        <member name="P:NMotive.FBXAsciiExporter.SkeletonNullsNames">
            <summary>
If the <c>WriteSkeletons</c> property is equal to <c>RigidBodyWriteNullsOptions::Named</c>,
then only skeletons whose names are in this list will be written to output.
</summary>
        </member>
        <member name="P:NMotive.FBXAsciiExporter.WriteSkeletonNulls">
            <summary>
Gets or sets a value indicating whether or not to write skeleton nulls.
</summary>
        </member>
        <member name="P:NMotive.FBXAsciiExporter.WriteMarkerNulls">
            <summary>
Gets and sets the property specifying whether or not to write out
null markers.
The default value is <c>false</c>.
</summary>
        </member>
        <member name="P:NMotive.FBXAsciiExporter.WriteMarkers">
            <summary>
Gets and sets the <c>WriteMarkers</c> property.
The default value is <c>true</c>.
</summary>
        </member>
        <member name="P:NMotive.FBXAsciiExporter.IsBinary">
            <summary>
Gets a property that is <c>strue</c> if the export format is binary.
</summary>
        </member>
        <member name="P:NMotive.FBXAsciiExporter.Extension">
            <summary>
Gets the conventional extension for files with this export format.
The extension does NOT include the '.'
</summary>
        </member>
        <member name="P:NMotive.FBXAsciiExporter.Description">
            <summary>
Gets the description of this exporter.
</summary>
        </member>
        <member name="P:NMotive.FBXAsciiExporter.Name">
            <summary>
Gets the name of this exporter.
</summary>
        </member>
        <member name="M:NMotive.FBXAsciiExporter.#ctor">
            <summary>
Constructs an <c>FBXAsciiExporter</c> instance with default options.
</summary>
        </member>
        <member name="T:NMotive.FBXAsciiExporter">
            <summary>
Class for exporting take data to FBX ASCII format.
</summary>
        </member>
        <member name="M:NMotive.FBXExporter.GetRBNullsSettings(NMotive.Take)">
            <exclude />
        </member>
        <member name="M:NMotive.FBXExporter.GetFrameRateSettings(NMotive.Take)">
            <exclude />
            <summary>
Returns the appropriate frame rate based on current settings.
</summary>
            <param name="exportSettings">Export settings struct.</param>
            <param name="take">A take.</param>
        </member>
        <member name="M:NMotive.FBXExporter.GetFrameRangeSettings(NMotive.Take)">
            <exclude />
            <summary>
Returns the appropriate frame range based on current settings.
</summary>
            <param name="exportSettings">Export settings struct.</param>
            <param name="take">A take.</param>
        </member>
        <member name="M:NMotive.FBXExporter.GetSkeletonSettings(NMotive.Take)">
            <exclude />
            <summary>
Sets export settings based on the the 
value of the <c>WriteSkeletons</c> property.
</summary>
            <param name="exportSettings">Reference to the export settings structure.</param>
            <param name="take">The take being written to FBX ASCII format.</param>
        </member>
        <member name="M:NMotive.FBXExporter.GetSkeletons(NMotive.Take)">
            <exclude />
            <summary>
Gets the list of skeleton ID's to be written based on the the 
value of the <c>WriteSkeletons</c> property.
</summary>
            <param name="take">The take being written to FBX ASCII format.</param>
        </member>
        <member name="P:NMotive.FBXExporter.WriteUnlabeledMarkers">
            <summary>
Gets and sets the property specifying whether or not to write out
unlabeled markers.
The default value is <c>true</c>.
</summary>
        </member>
        <member name="P:NMotive.FBXExporter.UseTimeCode">
            <summary>
Gets and sets the property specifying whether or not to use the time code
The default value is <c>false</c>.
</summary>
        </member>
        <member name="P:NMotive.FBXExporter.WriteVirtualFingerTipMarkers">
            <summary>
Gets and sets the export virtual fingertip markers property.
If <c>true</c> synthetic fingertip markers generated by the solver 
will be exported. The default is <c>false</c></summary>
        </member>
        <member name="P:NMotive.FBXExporter.WriteRigidBodyNulls">
            <summary>
Gets or sets a value indicating whether or not to write rigid body nulls.
</summary>
        </member>
        <member name="P:NMotive.FBXExporter.Units">
            <summary>
Gets and sets the length units option.
This option determines the base unit of measurement for positioning
in FBX export. Default value is meters.
</summary>
        </member>
        <member name="P:NMotive.FBXExporter.WriteSkeletons">
            <summary>
Gets and sets the property for determining which skeletons, if any are 
written output.
</summary>
        </member>
        <member name="P:NMotive.FBXExporter.RigidBodyNames">
            <summary>
If the <c>RigidBodyWriteNullsOptions</c> property is equal to <c>RigidBodyWriteNullsOptions::Named</c>,
then only rigid bodies whose names are in this list will be written to output.
</summary>
        </member>
        <member name="P:NMotive.FBXExporter.SkeletonNames">
            <summary>
If the <c>WriteSkeletons</c> property is equal to <c>SkeletonWriteOptions::Named</c>,
then only skeletons whose names are in this list will be written to output.
</summary>
        </member>
        <member name="P:NMotive.FBXExporter.IsBusy">
            <summary>
Gets a property that is <c>true</c> if the this object is currently 
busy doing an export operation.
</summary>
        </member>
        <member name="P:NMotive.FBXExporter.Extension">
            <summary>
Gets the conventional extension for files with this export format.
The extension does NOT include the '.'
</summary>
        </member>
        <member name="F:NMotive.FBXExporter.mNamedRigidBodies">
            <summary>
If the WriteSkeletons property is equal the Named, write out
the skeletons whose names are in this list.
</summary>
        </member>
        <member name="F:NMotive.FBXExporter.mNamedSkeletons">
            <summary>
If the WriteSkeletons property is equal the Named, write out
the skeletons whose names are in this list.
</summary>
        </member>
        <member name="F:NMotive.FBXExporter.mIsBusy">
            <summary>
Set to true when in the export function.
</summary>
        </member>
        <member name="M:NMotive.FBXExporter.#ctor">
            <summary>
Constructs an <c>FBXExporter</c> object with the <c>WriteSkeletons</c>
equal to None.
</summary>
        </member>
        <member name="F:NMotive.FBXExporter.MarkerNameSeparatorOptions.Underscore">
            <summary>
Use '_' for marker name separator.
</summary>
        </member>
        <member name="F:NMotive.FBXExporter.MarkerNameSeparatorOptions.Colon">
            <summary>
Use ':' for marker name separator.
</summary>
        </member>
        <member name="T:NMotive.FBXExporter.MarkerNameSeparatorOptions">
            <summary>
Options for marker name separator character.
</summary>
        </member>
        <member name="F:NMotive.FBXExporter.SkeletonWriteOptions.Active">
            <summary>
Write all active skeletons in the take.
</summary>
        </member>
        <member name="F:NMotive.FBXExporter.SkeletonWriteOptions.Named">
            <summary>
Write skeletons whose names specified in the <c>SkeletonNames</c>
property.
</summary>
        </member>
        <member name="F:NMotive.FBXExporter.SkeletonWriteOptions.None">
            <summary>
Do not write skeletons.
</summary>
        </member>
        <member name="F:NMotive.FBXExporter.SkeletonWriteOptions.All">
            <summary>
Write all skeletons.
</summary>
        </member>
        <member name="T:NMotive.FBXExporter.SkeletonWriteOptions">
            <summary>
Options for writing skeletons to the output file.
</summary>
        </member>
        <member name="F:NMotive.FBXExporter.RigidBodyWriteNullsOptions.Active">
            <summary>
Write all active rigid bodies in the take.
</summary>
        </member>
        <member name="F:NMotive.FBXExporter.RigidBodyWriteNullsOptions.Named">
            <summary>
Write rigid body rigidBodies whose names specified in the <c>RigidBodyNames</c>
property.
</summary>
        </member>
        <member name="F:NMotive.FBXExporter.RigidBodyWriteNullsOptions.None">
            <summary>
Do not write rigid body rigidBodies.
</summary>
        </member>
        <member name="F:NMotive.FBXExporter.RigidBodyWriteNullsOptions.All">
            <summary>
Write all rigid body rigidBodies.
</summary>
        </member>
        <member name="T:NMotive.FBXExporter.RigidBodyWriteNullsOptions">
            <summary>
Options for writing skeletons to the output file.
</summary>
        </member>
        <member name="T:NMotive.FBXExporter">
            <summary>
Base class for FBX exporters
</summary>
        </member>
        <member name="T:MotiveCore.cFBXExporter">
            <summary>
Exporter class for FBX files
</summary>
        </member>
        <member name="M:NMotive.DataStreamWarehouse.Delete(System.String)">
            <summary>
Deletes the named entry. If it is a directory, entries are recursively
deleted from the given
path down.
</summary>
        </member>
        <member name="M:NMotive.DataStreamWarehouse.Exists(System.String)">
            <summary>Check if the given path exists as a stream or directory.</summary>
            <returns>
                <c>true</c> if the given path is a stream or directory.</returns>
        </member>
        <member name="M:NMotive.DataStreamWarehouse.IsDirectory(System.String)">
            <summary>Returns true if the given path in the storage is a directory.</summary>
        </member>
        <member name="M:NMotive.DataStreamWarehouse.Entries(System.String)">
            <summary>Retrieve a list of all streams/directories at the given 
path in the storage.</summary>
            <param name="path">Storage path.</param>
            <returns>List of streams/directories at the given path in the storage.</returns>
        </member>
        <member name="M:NMotive.DataStreamWarehouse.CloseStream(NMotive.DataStream)">
            <summary>Close a repository data stream.</summary>
            <returns>
                <c>true</c> if the stream was successfully closed.</returns>
        </member>
        <member name="M:NMotive.DataStreamWarehouse.OpenStream(System.String,NMotive.DataStream.StreamOpenMode,System.Boolean)">
            <summary>
Open a stream in the storage repository. 
</summary>
            <param name="filename">The given filename is understood to be relative to the root
of the repository if preceded by a '/'. Otherwise, the path is understood to be relative to the
current working directory within the repository.</param>
            <param name="openMode">Stream open mode</param>
            <param name="binary">If binary is true, the stream is opened in binary mode. Otherwise, 
 it is opened in text mode.</param>
            <returns>null if the requested path is invalid, if the stream is already open, or if the stream
could not be opened with the requested mode.</returns>
        </member>
        <member name="M:NMotive.DataStreamWarehouse.SetWorkingDirectory(System.String,System.Boolean)">
            <summary>
Sets the current working directory. The given path can be either absolute (e.g. "/fred/george")
or relative to the previous current working directory (e.g. "fred/george" or "../fred"). Unix-style
directory navigation is supported (i.e. use of ".." and "." in paths).
Returns false if the requested path does not exist.
</summary>
        </member>
        <member name="M:NMotive.DataStreamWarehouse.Close">
            <summary>Close the warehouse. Open must be called again before 
using any other methods.</summary>
        </member>
        <member name="M:NMotive.DataStreamWarehouse.Open(System.String,System.Boolean)">
            <summary>Open the warehouse for use. This must be called before using 
any other methods.</summary>
            <param name="path">Path to the warehouse file.</param>
            <param name="makeWriteable">If <c>true</c> makes the resulting data 
stream writeable.</param>
        </member>
        <member name="P:NMotive.DataStreamWarehouse.IsWritable">
            <summary>Returns true if the storage is writable.</summary>
        </member>
        <member name="P:NMotive.DataStreamWarehouse.HasOpenStreams">
            <summary>Returns true if there are open file handles in this 
repository.</summary>
        </member>
        <member name="P:NMotive.DataStreamWarehouse.WorkingDirectory">
            <summary>Retrieves the current working directory.</summary>
        </member>
        <member name="P:NMotive.DataStreamWarehouse.RootPath">
            <summary>Returns the file path/name where the warehouse 
resides.</summary>
        </member>
        <member name="P:NMotive.DataStreamWarehouse.IsOpen">
            <summary>Returns true if the warehouse is currently open.</summary>
        </member>
        <member name="T:NMotive.DataStreamWarehouse">
            <summary />
            <exclude />
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.Delete(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Deletes the named entry. If it is a directory, entries are recursively deleted from the given
path down.
</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.Exists(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if the given path exists as a stream or directory.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.IsDirectory(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if the given path in the storage is a directory.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.Entries(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Retrieve a list of all streams/directories at the given path in the storage.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.CopyStream(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cIDataStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Copies the given stream into this warehouse at the requested file location.
Any stream of the same filename in the warehouse will be overwritten.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.CloseStream(MoCapCore.cIDataStream*)">
            <summary>Close a repository data stream.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.FindOpenStream(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>This method can be used to search for a stream that may already be open.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.OpenStream(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cIDataStream.eStreamOpenMode,System.Boolean)">
            <summary>
Open a stream in the storage repository. The given filename is understood to be relative to the root
of the repository if preceded by a '/'. Otherwise, the path is understood to be relative to the
current working directory within the repository.
If binary is true, the stream is opened in binary mode. Otherwise, it is opened in text mode.
Returns NULL if the requested path is invalid, if the stream is already open, or if the stream
could not be opened with the requested mode.
</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.IsWritable">
            <summary>Returns true if the storage is writable.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.HasOpenStreams">
            <summary>Returns true if there are open file handles in this repository.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.WorkingDirectory">
            <summary>Retrieves the current working directory.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.SetWorkingDirectory(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>
Sets the current working directory. The given path can be either absolute (e.g. "/fred/george")
or relative to the previous current working directory (e.g. "fred/george" or "../fred"). Unix-style
directory navigation is supported (i.e. use of ".." and "." in paths).
Returns false if the requested path does not exist.
</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.RootPath">
            <summary>Returns the file path/name where the warehouse resides.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.IsOpen">
            <summary>Returns true if the warehouse is currently open.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.Close">
            <summary>Close the warehouse. Open must be called again before using any other methods.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStreamWarehouse.Open(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Open the warehouse for use. This must be called before using any other methods.</summary>
        </member>
        <member name="T:MoCapCore.cIDataStreamWarehouse">
            <summary>
A structured storage class that manages streams (usually files) within a repository. A repository can be
either a physical directory on the file system, or it can be a structured storage file that may contain
other files, or it can be something more abstract like a network connection to a remote asset stream.

All paths for this class should be given using the Unix-style path separator '/'.
</summary>
        </member>
        <member name="M:NMotive.C3DExporter.SetAxisMotionBuilderCompatible">
            <summary>
Sets the axis mapping to be motion builder compatible.
X-axis -&gt; negative X-axis
Y-axis -&gt; negative Z-axis
Z-axis -&gt; positive Y-axis
</summary>
        </member>
        <member name="M:NMotive.C3DExporter.Export(NMotive.Take,NMotive.DataStream)">
            <exclude />
            <summary>
Exports the given take to the given data stream.
</summary>
            <param name="take">The take to export</param>
            <param name="stream">The data stream to export to.</param>
            <returns>The result of the export attempt.</returns>
        </member>
        <member name="P:NMotive.C3DExporter.ColonNameSeparator">
            <summary>
Gets and sets the property for determining if the marker name separator
is a colon or an underscore. If true colons will be used, if false 
underscores will be used.
</summary>
        </member>
        <member name="P:NMotive.C3DExporter.ZAxis">
            <summary>
Gets and sets translations for movement along the z-axis for C3D export.
Default is positive y-axis.
</summary>
        </member>
        <member name="P:NMotive.C3DExporter.YAxis">
            <summary>
Gets and sets translations for movement along the y-axis for C3D export.
Default is negative z-axis.
</summary>
        </member>
        <member name="P:NMotive.C3DExporter.XAxis">
            <summary>
Gets and sets translations for movement along the x-axis for C3D export.
Default is negative x-axis.
</summary>
        </member>
        <member name="P:NMotive.C3DExporter.Units">
            <summary>
Gets and sets the length units option.
This option determines the base unit of measurement for positioning
in C3D export. Default value is meters.
</summary>
        </member>
        <member name="P:NMotive.C3DExporter.UseTimeCode">
            <summary>
Gets and sets the use time code property. Default is <c>true</c>.
</summary>
        </member>
        <member name="P:NMotive.C3DExporter.WriteFingerTipMarkers">
            <summary>
Gets and sets the export fingertip markers property.
If <c>true</c> synthetic fingertip markers generated by the solver 
will be exported. The default is <c>false</c></summary>
        </member>
        <member name="P:NMotive.C3DExporter.RenameUnlabeledMarkers">
            <summary>
Gets and sets the rename unlabeled markers property.
Renames unlabeled markers as "_000X". Default is <c>false</c></summary>
        </member>
        <member name="P:NMotive.C3DExporter.WriteUnlabeledMarkers">
            <summary>
Gets and sets export unlabeled markers property. The default is <c>true</c>.
</summary>
        </member>
        <member name="P:NMotive.C3DExporter.UseZeroBasedFrameIndex">
            <summary>
Gets and sets a boolean indicating whether frame indexing in the output
C3D file should be ones base or zero based. The default is 
<c>true</c> - zero based.
</summary>
            <remarks>
Zero based is the convention for MotionBuilder. Ones based is per C3D
Specification.
</remarks>
        </member>
        <member name="M:NMotive.C3DExporter.#ctor">
            <summary>
Constructs a <c>C3DExporter</c> object with the default options.
</summary>
        </member>
        <member name="T:NMotive.C3DExporter">
            <summary>
Class for exporting take files to C3D format.
</summary>
        </member>
        <member name="M:NMotive.Exporter.NativeToManaged(Core.eUnits)">
            <exclude />
        </member>
        <member name="M:NMotive.Exporter.ManagedToNative(NMotive.LengthUnits)">
            <exclude />
        </member>
        <member name="P:NMotive.Exporter.Scale">
            <summary>
Gets and sets the scale property.
Range from 0 to 1. Default is 1.
</summary>
        </member>
        <member name="P:NMotive.Exporter.FrameRate">
            <summary>
Gets and sets frame rate to export at. The default value is the 
class constant <c>DefaultFrameRate</c>. When set to this value the
export frame rate will be the same as the take frame rate.
</summary>
        </member>
        <member name="P:NMotive.Exporter.EndFrame">
            <summary>
Gets the index of the last frame to export. Frames in the range 
<c>StartFrame</c> to <c>EndFrame</c> will be exporterd. The default
value is the class constant <c>Exporter::DefaultEndFrame</c>. When 
<c>EndFrame</c> is set to this value the end frame will 
be the last frame in the take being exported.
</summary>
        </member>
        <member name="P:NMotive.Exporter.StartFrame">
            <summary>
Gets the index of the first frame to export. Frames in the range 
<c>StartFrame</c> to <c>EndFrame</c> will be exporterd. The default
value is the class constant <c>Exporter::DefaultStartFrame</c>. When 
<c>StartFrame</c> is set to this value the start frame will 
be the first frame in the take being exported.
</summary>
        </member>
        <member name="F:NMotive.Exporter.DefaultFrameRate">
            <summary>
Default frame rate to export at. When the property
<c>FrameRate</c> is set to this value the export frame rate will be
the same as the take frame rate.
</summary>
        </member>
        <member name="F:NMotive.Exporter.DefaultEndFrame">
            <summary>
Default end frame in the take to export.
When the <c>EndFrame</c> property is set to this value the end frame will 
be the last frame in the take being exported.
</summary>
        </member>
        <member name="F:NMotive.Exporter.DefaultStartFrame">
            <summary>
Default starting frame in the take to export.
When the <c>StartFrame</c> property is set to this value the start frame will 
be the first frame in the take being exported.
</summary>
        </member>
        <member name="T:NMotive.Exporter">
            <summary>
Base class from which all take Exporters derive.
</summary>
        </member>
        <member name="T:MotiveCore.cC3DExporter">
            <summary>
Exporter class for C3D files
</summary>
        </member>
        <member name="M:NMotive.KeyframeDataFilter.Apply(System.Collections.Generic.IList`1{NMotive.Keyframe`1{NMotive.Quaternion}})">
            <summary>
Apply the filter to the given list of quaternion rotations.
</summary>
            <param name="vals">A list of quaternion rotations.</param>
        </member>
        <member name="M:NMotive.KeyframeDataFilter.Apply(System.Collections.Generic.IList`1{NMotive.Keyframe`1{NMotive.Vector3f}})">
            <summary>
Apply the filter to the given list of key frame 3-D vectors.
</summary>
            <param name="vals">A list of key frame 3-D vectors.</param>
        </member>
        <member name="M:NMotive.KeyframeDataFilter.Apply(System.Collections.Generic.IList`1{NMotive.Vector3f})">
            <summary>
Apply the filter to the given list of 3-D vectors.
</summary>
            <param name="vals">A list of 3-D vectors.</param>
        </member>
        <member name="M:NMotive.KeyframeDataFilter.Apply(System.Collections.Generic.IList`1{NMotive.Keyframe`1{System.Single}})">
            <summary>
Apply the filter to the given key frames.
</summary>
            <param name="vals">A list of key frames.</param>
        </member>
        <member name="M:NMotive.KeyframeDataFilter.Apply(System.Collections.Generic.IList`1{System.Single})">
            <summary>
Apply the filter to the given values.
</summary>
            <param name="vals">A list of values.</param>
        </member>
        <member name="P:NMotive.KeyframeDataFilter.CutoffFrequency">
            <summary>
Set the cut-off frequency (in Hz) for the filter.
</summary>
        </member>
        <member name="P:NMotive.KeyframeDataFilter.SampleRate">
            <summary>
Set the data rate (in Hz) to assume for all samples.
</summary>
        </member>
        <member name="P:NMotive.KeyframeDataFilter.Order">
            <summary>
Set the order of the filter. Must be an even integer in the range [2,6].
</summary>
        </member>
        <member name="T:NMotive.KeyframeDataFilter">
            <summary>
Builds an nth order Butterworth IIR filter, and allows setting of the cutoff frequency. The filter
order must be an even integer to allow backward and forward application of 1/2 nth order filters to
compensate for phase shift that would otherwise be introduced by only running the filter in the
forward direction. See MatLab's filtfilt for description.
This filter assumes that the keyframe data is contiguous (i.e. no gaps).
</summary>
        </member>
        <member name="M:MoCapCore.cKeyframeDataFilter.Apply(std.vector&lt;System.Single,std.allocator&lt;System.Single&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Apply the filter to the given keys. Keys are assumed to be contiguous.</summary>
        </member>
        <member name="M:MoCapCore.cKeyframeDataFilter.SetCutoffFrequency(System.Double)">
            <summary>Set the cutoff frequency (in Hz) for the filter.</summary>
        </member>
        <member name="M:MoCapCore.cKeyframeDataFilter.SetSampleRate(System.Double)">
            <summary>Set the data rate (in Hz) to assume for all samples.</summary>
        </member>
        <member name="M:MoCapCore.cKeyframeDataFilter.SetOrder(System.Int32)">
            <summary>Set the order of the filter. Must be an even integer in the range [2,6].</summary>
        </member>
        <member name="T:MoCapCore.cKeyframeDataFilter">
            <summary>
Builds an nth order Butterworth IIR filter, and allows setting of the cutoff frequency. The filter
order must be an even integer to allow backward and forward application of 1/2 nth order filters to
compensate for phase shift that would otherwise be introduced by only running the filter in the
forward direction. See MatLab's filtfilt for description.
This filter assumes that the keyframe data is contiguous (i.e. no gaps).
</summary>
        </member>
        <member name="P:NMotive.Joint.ActiveDOFs">
            <summary>
Gets the active degrees of freedom.
</summary>
        </member>
        <member name="M:NMotive.Joint.#ctor(MoCapCore.cJointNode*)">
            <exclude />
        </member>
        <member name="F:NMotive.Joint.DOF.AllDOF">
            <summary>
X translation, plus Y translation, plus Z translation, plus
X rotation, plus Y rotation, plus Z rotation.
</summary>
        </member>
        <member name="F:NMotive.Joint.DOF.AllRot">
            <summary>
X rotation, plus Y rotation, plus Z rotation.
</summary>
        </member>
        <member name="F:NMotive.Joint.DOF.AllTrans">
            <summary>
X translation, plus Y translation, plus Z translation.
</summary>
        </member>
        <member name="F:NMotive.Joint.DOF.ZRot">
            <summary>
Z rotation.
</summary>
        </member>
        <member name="F:NMotive.Joint.DOF.YRot">
            <summary>
Y rotation.
</summary>
        </member>
        <member name="F:NMotive.Joint.DOF.XRot">
            <summary>
X rotation.
</summary>
        </member>
        <member name="F:NMotive.Joint.DOF.ZTrans">
            <summary>
Z translation.
</summary>
        </member>
        <member name="F:NMotive.Joint.DOF.YTrans">
            <summary>
Y translation.
</summary>
        </member>
        <member name="F:NMotive.Joint.DOF.XTrans">
            <summary>
X translation.
</summary>
        </member>
        <member name="T:NMotive.Joint.DOF">
            <summary>
Enumeration of degrees of freedom
</summary>
        </member>
        <member name="T:NMotive.Joint">
            <summary>
Class for representing joint nodes in a scene.
</summary>
        </member>
        <member name="P:NMotive.RealMarker.KeyFrameRange">
            <summary>
Gets the keyframe range.
</summary>
        </member>
        <member name="P:NMotive.RealMarker.ChannelCount">
            <summary>
Gets the number of channels available.
</summary>
        </member>
        <member name="M:NMotive.RealMarker.HasChannel(NMotive.Channel.ChannelType)">
            <summary>
Returns true if a channel of the given type exists on this node.
</summary>
            <param name="channelType">Type of channel.</param>
            <returns>
                <c>true</c> if this node contains data for the
specified channel type.</returns>
        </member>
        <member name="M:NMotive.RealMarker.WorldTransform(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Get the full world coordinate transform at the given time.
</summary>
            <param name="frameIndex">The frame index.</param>
            <returns>The simple affine world transformation for the frame.</returns>
        </member>
        <member name="M:NMotive.RealMarker.Transform(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Get the full transform at the given time.
</summary>
            <param name="frameIndex">The frame index.</param>
            <returns>The simple affine transformation for the frame.</returns>
        </member>
        <member name="M:NMotive.RealMarker.Translation(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Get the local position at the given frame index.
</summary>
            <param name="frameIndex">The frame index.</param>
            <returns>Local position of the frame index.</returns>
        </member>
        <member name="M:NMotive.RealMarker.SetTranslation(System.Int32!System.Runtime.CompilerServices.IsLong,NMotive.Vector3f)">
            <summary>
A convenience method for setting local translation. The default translation value will be set if no
animation channel exists.
</summary>
            <param name="frameIndex">Frame index to set value on.</param>
            <param name="val">The value to set.</param>
            <returns>True if the key was set. False if a key was not set, but the default value was.</returns>
        </member>
        <member name="M:NMotive.RealMarker.SetChannel(NMotive.Channel)">
            <summary>
Set one of the animation channels. Which channel gets set is governed by the Type()
of the given channel.
</summary>
            <param name="channel">The channel.</param>
            <returns>True if the given channel was a match for this node and was set as the translation channel.</returns>
        </member>
        <member name="M:NMotive.RealMarker.Clear">
            <summary>
Clear all animation data.
</summary>
        </member>
        <member name="M:NMotive.RealMarker.Clear(NMotive.FrameRange)">
            <summary>
Clear all animation data over the given range.
</summary>
            <param name="range">A range</param>
        </member>
        <member name="M:NMotive.RealMarker.IsKeyed(NMotive.FrameRange)">
            <summary>
Checks for the presence of keyed data in a give range.
</summary>
            <param name="range">A range.</param>
            <returns>Returns <c>true</c> if a transform key exists in the given range.</returns>
        </member>
        <member name="M:NMotive.RealMarker.IsKeyed">
            <summary>
Checks for the presence of keyed data.
</summary>
            <returns>Returns <c>true</c> if a transform key exists.</returns>
        </member>
        <member name="P:NMotive.RealMarker.TranslationChannel">
            <summary>
Gets the translation, or position, channel for this marker.
</summary>
            <returns>Translation channel for this marker.</returns>
        </member>
        <member name="P:NMotive.RealMarker.IsLabeled">
            <summary>
Get the labeled status of this marker.
</summary>
            <returns>
                <c>true</c> if this is a labeled marker.</returns>
        </member>
        <member name="P:NMotive.RealMarker.Residual">
            <summary>
Gets and sets the residual value for a marker.
</summary>
        </member>
        <member name="P:NMotive.RealMarker.Size">
            <summary>
Gets and sets the size of a marker.
</summary>
        </member>
        <member name="M:NMotive.RealMarker.#ctor">
            <summary>
Constructs a default instance of a real marker.
</summary>
        </member>
        <member name="T:NMotive.RealMarker">
            <summary>
Class representing real marker objects in a scene.
</summary>
        </member>
        <member name="M:MoCapCore.cOperationManager.RunningDescription(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Description of the operation currently running, if any.</summary>
            <returns>True if an operation is running and its description was retrieved.</returns>
        </member>
        <member name="M:MoCapCore.cOperationManager.RunningName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Name of the operation currently running, if any.</summary>
            <returns>True if an operation is running and its name was retrieved.</returns>
        </member>
        <member name="M:MoCapCore.cOperationManager.Running">
            <summary>Returns true if the queue is running.</summary>
        </member>
        <member name="M:MoCapCore.cOperationManager.Cancel">
            <summary>Immediately cancel all operations in the queue and cease execution.</summary>
        </member>
        <member name="M:MoCapCore.cOperationManager.Resume">
            <summary>Resume execution of the queue.</summary>
            <returns>True if there are more items to execute in the queue.</returns>
        </member>
        <member name="M:MoCapCore.cOperationManager.Pause">
            <summary>Pause execution of queue after the next operation completes.</summary>
            <returns>False if the queue is not running or is empty.</returns>
        </member>
        <member name="M:MoCapCore.cOperationManager.EndGroup(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Finish an operation group and assign a name to use for the undo operation.</summary>
        </member>
        <member name="M:MoCapCore.cOperationManager.StartGroup">
            <summary>Start an operation group. Groups are combined into a single undo operation.</summary>
        </member>
        <member name="M:MoCapCore.cOperationManager.AddToQueue(MoCapCore.cIOperation*)">
            <summary>Add the given operation to the queue. Ownership transfers.</summary>
        </member>
        <member name="M:MoCapCore.cOperationManager.AddToQueue(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cPropertyCollection!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Add the named operation to the queue, using the given set of parameters. If the queue is
currently empty, this call will also begin execution.
</summary>
            <returns>True if the operation was found and the given parameter set was a match for it.</returns>
        </member>
        <member name="M:MoCapCore.cOperationManager.SetRunMode(MoCapCore.cOperationManager.RunMode)">
            <summary>
Sets the run mode. If run mode is eImmediate, operations will be run on the caller's thread
once submitted (i.e. the AddToQueue method will block until the operation completes).
</summary>
        </member>
        <member name="M:MoCapCore.cOperationManager.CreateInstance(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Create a new instance of the named operation.</summary>
        </member>
        <member name="M:MoCapCore.cOperationManager.CreateProperties(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Create a new parameter group for the named operation.</summary>
            <returns>The new parameter group if the given name was valid. NULL otherwise.</returns>
        </member>
        <member name="M:MoCapCore.cOperationManager.FindFactory(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Retrieve the operation factory associated with the operation of the given name.</summary>
        </member>
        <member name="M:MoCapCore.cOperationManager.OperationDescription(System.UInt32,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Get the description associated with the operation factory at the given index.</summary>
            <returns>True if the index was valid and the description was retrieved.</returns>
        </member>
        <member name="M:MoCapCore.cOperationManager.OperationLabel(System.UInt32,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Get the user-facing label associated with the operation factory at the given index.</summary>
            <returns>True if the index was valid and the label was retrieved.</returns>
        </member>
        <member name="M:MoCapCore.cOperationManager.OperationName(System.UInt32,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Get the internal name of the operation at the given index in the factory list.</summary>
            <returns>True if the index was valid and the name was retrieved.</returns>
        </member>
        <member name="M:MoCapCore.cOperationManager.FactoryCount">
            <summary>Get the number of available factories.</summary>
        </member>
        <member name="M:MoCapCore.cOperationManager.AddFactory(MoCapCore.cIOperationFactory*)">
            <summary>Add a new operation factory. Ownership is transferred to this object.</summary>
            <returns>True if the factory name was unique and could be added.</returns>
        </member>
        <member name="M:MoCapCore.cOperationManager.AddNativeFactories">
            <summary>Should be called after construction to add in all the native operations' factories.</summary>
        </member>
        <member name="M:MoCapCore.cOperationManager.SetProgressHandler(std.shared_ptr&lt;MoCapCore.cIProgressIndicator&gt;)">
            <summary>
Set a progress indicator interface to use to report busy/progress. Ownership of the IProgressIndicator
object is transferred here.
</summary>
        </member>
        <member name="M:MoCapCore.cOperationManager.#ctor(std.unique_ptr&lt;MoCapCore.cIOperationData,std.default_delete&lt;MoCapCore.cIOperationData&gt;&gt;)">
            <summary>Create an operation manager.</summary>
        </member>
        <member name="T:MoCapCore.cOperationManager">
            <summary>
Manages the operation queue. This class is the interface to all editing operations. It is thread-safe such
that any calls on this class can be called from any thread, but execution of the operations on the stack
will proceed from a private thread on this class.
Operation factories can be added at any time, and once they are, are used to create and execute operations
in the queue.
</summary>
        </member>
        <member name="M:MoCapCore.IOperationManagerObserver.OnRunModeChanged(MoCapCore.cOperationManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when one or more nodes is added or removed.</summary>
        </member>
        <member name="T:NMotive.DataStream">
            <exclude />
            <summary>
class for data streams, which can usually be thought of as files. Streams may exist
as files on disk, or as files within a file archive, or as resources accessible over a network
connection, or some other representation that is suitable for this interface. Data streams are
created and destroyed by cIDataStreamWarehouse implementations.
</summary>
        </member>
        <member name="M:NMotive.VideoExporter.Export(NMotive.Take,NMotive.DataStream,NMotive.ProgressIndicator)">
            <exclude />
            <summary>
Exports the given take to the given data stream.
</summary>
            <param name="take">The take to export</param>
            <param name="stream">The data stream to export to.</param>
            <param name="progress"> The progress indicator to receive progress notifactions.</param>
            <returns>The result of the export attempt.</returns>
        </member>
        <member name="M:NMotive.VideoExporter.Export(NMotive.Take,NMotive.DataStream)">
            <exclude />
            <summary>
Exports the given take to the given data stream.
</summary>
            <param name="take">The take to export</param>
            <param name="stream">The data stream to export to.</param>
            <returns>The result of the export attempt.</returns>
        </member>
        <member name="P:NMotive.VideoExporter.DroppedFrameBehavior">
            <summary>
Gets and sets the policy for exporting frames dropped during video recording.
The options are to just to not export the dropped frame or insert a black frame in its place.
Inserting black frames will keep the video data in sync with the Motion Capture data.
</summary>
        </member>
        <member name="P:NMotive.VideoExporter.PlaybackSpeed">
            <summary>
Gets and sets the playback rate for exported video.
Scales playback speed of the exported video. The time interval between 
each frame will be increased or decreased by this ratio, making 
the video length longer or shorter.
</summary>
        </member>
        <member name="P:NMotive.VideoExporter.ColorVideoFormat">
            <summary>
Gets and sets the format for exported color video.
</summary>
        </member>
        <member name="P:NMotive.VideoExporter.FrameRate">
            <summary>
Gets and sets the frame at which to export the video.
</summary>
        </member>
        <member name="M:NMotive.VideoExporter.#ctor(NMotive.VideoExporter.FrameRateValue)">
            <summary>
Constructs a video exporter object with the frame rate.
</summary>
            <param name="frameRate">Video will be exported at this frame rate.</param>
        </member>
        <member name="M:NMotive.VideoExporter.#ctor">
            <summary>
Constructs a video exporter object. Exported frame rate is full.
</summary>
        </member>
        <member name="F:NMotive.VideoExporter.DroppedFrameBehaviorValue.BlackFrame">
            <summary>
Insert a black frame for the dropped frame when exporting. Video data remains in
sync with MoCap data.
</summary>
        </member>
        <member name="F:NMotive.VideoExporter.DroppedFrameBehaviorValue.DropFrame">
            <summary>
Skip dropped frames when exporting video data. Video will be 
out of sync with MoCap data.
</summary>
        </member>
        <member name="T:NMotive.VideoExporter.DroppedFrameBehaviorValue">
            <summary>
Options for exporting dropped frames from recorded video.
</summary>
        </member>
        <member name="F:NMotive.VideoExporter.PlaybackSpeedValue.Eighth">
            <summary>
Playback at eighth speed
</summary>
        </member>
        <member name="F:NMotive.VideoExporter.PlaybackSpeedValue.Quarter">
            <summary>
Playback at quarter speed
</summary>
        </member>
        <member name="F:NMotive.VideoExporter.PlaybackSpeedValue.Half">
            <summary>
Playback at half speed
</summary>
        </member>
        <member name="F:NMotive.VideoExporter.PlaybackSpeedValue.Full">
            <summary>
Playback at full speed
</summary>
        </member>
        <member name="T:NMotive.VideoExporter.PlaybackSpeedValue">
            <summary>
Values for scaling the playback speed of the exported video.
Each frame will be increased or decreased by this ratio, making 
the video length longer or shorter.
</summary>
        </member>
        <member name="F:NMotive.VideoExporter.ColorVideoFormatValue.MJPEG">
            <summary>
MJPEG video compression format.
</summary>
        </member>
        <member name="F:NMotive.VideoExporter.ColorVideoFormatValue.H264">
            <summary>
H.264 or MPEG-4 Part 10 video coding.
</summary>
        </member>
        <member name="T:NMotive.VideoExporter.ColorVideoFormatValue">
            <summary>
Supported exported color video file formats.
</summary>
        </member>
        <member name="F:NMotive.VideoExporter.FrameRateValue.Quarter">
            <summary>
Quarter frame rate.
</summary>
        </member>
        <member name="F:NMotive.VideoExporter.FrameRateValue.Half">
            <summary>
Half frame rate.
</summary>
        </member>
        <member name="F:NMotive.VideoExporter.FrameRateValue.Full">
            <summary>
Full frame rate.
</summary>
        </member>
        <member name="T:NMotive.VideoExporter.FrameRateValue">
            <summary>
Exporter frame rate values. Video can exported at full frame rate,
half frame rate, and quarter frame rate.
</summary>
        </member>
        <member name="T:NMotive.VideoExporter">
            <summary>
Class for exporting video from a take to a file. Exported video format
is 'avi'. The take must contain video data for the exportation to be
successful.
</summary>
        </member>
        <member name="M:NMotive.ExporterBase.Export(NMotive.Take,System.String,System.Boolean)">
            <summary>
Exports the given take to the given file with option to overwrite existing
file.
</summary>
            <param name="take">The take to export</param>
            <param name="filePath">The path of the file to export to.</param>
            <param name="overwrite">If <c>true</c>, and the specified file exists
it will be overwritten. If <c>false</c> and the specified file exists
then the existing file will not be overwritten and the take will not be
exported. The <c>Success</c> property on the returned <c>Result</c> object
will be <c>false</c>. If the specified file does not exist this parameter has no affect.
</param>
            <returns>The result of the export attempt.</returns>
        </member>
        <member name="M:NMotive.ExporterBase.Export(NMotive.Take,NMotive.DataStream,NMotive.ProgressIndicator)">
            <exclude />
            <summary>
Exports the given take to the given data stream.
</summary>
            <param name="take">The take to export</param>
            <param name="stream">The data stream to export to.</param>
            <param name="progress"> The progress indicator to receive progress notifactions.</param>
            <returns>The result of the export attempt.</returns>
        </member>
        <member name="M:NMotive.ExporterBase.Export(NMotive.Take,NMotive.DataStream)">
            <exclude />
            <summary>
Exports the given take to the given data stream.
</summary>
            <param name="take">The take to export</param>
            <param name="stream">The data stream to export to.</param>
            <returns>The result of the export attempt.</returns>
        </member>
        <member name="P:NMotive.ExporterBase.IsBusy">
            <summary>
Gets a property that is <c>true</c> if the this object is currently 
busy doing an export operation.
</summary>
        </member>
        <member name="P:NMotive.ExporterBase.IsBinary">
            <summary>
Gets a property that is <c>strue</c> if the export format is binary.
</summary>
        </member>
        <member name="P:NMotive.ExporterBase.Extension">
            <summary>
Gets the conventional extension for files with this export format.
The extension does NOT include the '.'
</summary>
        </member>
        <member name="P:NMotive.ExporterBase.Description">
            <summary>
Gets the description of this exporter.
</summary>
        </member>
        <member name="P:NMotive.ExporterBase.Name">
            <summary>
Gets the name of this exporter.
</summary>
        </member>
        <member name="M:NMotive.ExporterBase.#cctor">
            <exclude />
        </member>
        <member name="F:NMotive.ExporterBase.mNativeExporter">
            <exclude />
        </member>
        <member name="T:NMotive.ExporterBase">
            <summary>
Base class from which all take Exporters derive.
</summary>
        </member>
        <member name="M:MoCapCore.cIExporter.Busy">
            <summary>Returns true if the exporter is busy exporting.</summary>
        </member>
        <member name="M:MoCapCore.cIExporter.MapToString(System.Int32)">
            <summary>Maps an error code from this exporter to a human-readable string value.</summary>
        </member>
        <member name="M:MoCapCore.cIExporter.Export(MoCapCore.cTake!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cIProgressIndicator*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
  In the case where exporting via cIDataStream is not possible, a version of Export is provided here with
  the filename to allow the exporter / third-party library handle the file I/O.
</summary>
        </member>
        <member name="M:MoCapCore.cIExporter.Export(MoCapCore.cTake!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cIDataStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cIProgressIndicator*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Export the given take using the given (open) stream. Exporters return 0 on success and a non-zero
value on failure. The return value can be mapped to a human-readable string using the MapToString
method.
</summary>
        </member>
        <member name="M:MoCapCore.cIExporter.IsBinary">
            <summary>Should return true for exporters that expect to write data in binary format.</summary>
        </member>
        <member name="M:MoCapCore.cIExporter.Properties">
            <summary>
Retrieve the property collection of options for this exporter.
</summary>
        </member>
        <member name="M:MoCapCore.cIExporter.Extension">
            <summary>Retrieve the file extension used by exporters of this type.</summary>
        </member>
        <member name="M:MoCapCore.cIExporter.Description">
            <summary>Human-readable description of the file type this exporter creates.</summary>
        </member>
        <member name="M:MoCapCore.cIExporter.Name">
            <summary>Brief name describing the exported type.</summary>
        </member>
        <member name="T:MoCapCore.cIExporter">
            <summary>
Abstract base class for all exporters. Exporters use the cIDataStream interface to write their data.
</summary>
        </member>
        <member name="T:MoCapCore.cIntPropertyValue">
            <summary>
A property value represented by an integer value.
</summary>
        </member>
        <member name="M:MoCapCore.cIStreamsManager.OpenFile(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cIDataStream.eStreamOpenMode,System.Boolean)">
            <summary>Convenience method to open a new file stream with the given filename.</summary>
        </member>
        <member name="M:MoCapCore.cIStreamsManager.CreateWarehouse(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Create a new stream warehouse of the requested type, if it exists. Returns NULL if the 
requested type is not available or cannot be created.
</summary>
        </member>
        <member name="M:MoCapCore.cIStreamsManager.CreateWarehouse">
            <summary>Create a warehouse of the default type.</summary>
        </member>
        <member name="M:MoCapCore.cIStreamsManager.SetDefaultWarehouseType(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Sets the default warehouse type.</summary>
        </member>
        <member name="M:MoCapCore.cIStreamsManager.AddFactory(MoCapCore.cIDataStreamWarehouseFactory*)">
            <summary>Add a stream warehouse type factory. Ownership of the factory is transferred.</summary>
        </member>
        <member name="T:MoCapCore.cIStreamsManager">
            <summary>
Manager class for stream storage. This class aggregates stream warehouse types and has convenience
methods for creating and maintaining cIStreamWarehouse instances.
</summary>
        </member>
        <member name="M:MoCapCore.cIDataStream.IsEOF">
            <summary>Returns true if the stream position is at the end of the stream.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStream.Mode">
            <summary>Retrieves the access mode for the stream.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStream.SetMode(MoCapCore.cIDataStream.eStreamOpenMode)">
            <summary>Set the access mode for the stream. Returns true if the mode could be set.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStream.Flush">
            <summary>Flush any pending output to the storage media.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStream.Write(System.Byte!System.Runtime.CompilerServices.IsConst*,System.UInt64)">
            <summary>
Writes a block of data and advances the stream position. Writes up to byteCount bytes,
so the buffer must be at least byteCount bytes long.
</summary>
        </member>
        <member name="M:MoCapCore.cIDataStream.Read(System.Byte*,System.UInt64)">
            <summary>
Reads up to byteCount bytes of data and advances the stream position. The buffer must be at
least byteCount bytes long. Returns the number of bytes actually read.
</summary>
        </member>
        <member name="M:MoCapCore.cIDataStream.Seek(System.UInt64)">
            <summary>Seek to the requested (absolute) position in the stream.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStream.Tell">
            <summary>Returns the current position in the stream.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStream.Size">
            <summary>Returns the (current) full size of the stream.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStream.FullName">
            <summary>
Returns the full stream name, including path. Stream name always use the '/' path separator.
To convert, you can use Filename::ConvertSeparators().
</summary>
        </member>
        <member name="M:MoCapCore.cIDataStream.Owner">
            <summary>Return the warehouse that owns this stream.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStream.IsOpen">
            <summary>Returns true if the stream is valid and open.</summary>
        </member>
        <member name="M:MoCapCore.cIDataStream.Destroy">
            <summary>Call this method, not the destructor, to destroy cIDataStream instances.</summary>
        </member>
        <member name="T:MoCapCore.cIDataStream">
            <summary>
The interface class for data streams, which can usually be thought of as files. Streams may exist
as files on disk, or as files within a file archive, or as resources accessible over a network
connection, or some other representation that is suitable for this interface. Data streams are
created and destroyed by cIDataStreamWarehouse implementations.
</summary>
        </member>
        <member name="M:MoCapCore.cExporterManager.SetAllToDefaults">
            <summary>
Reset all exporter properties to default.
</summary>
        </member>
        <member name="M:MoCapCore.cExporterManager.FindExporterByName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Attempt to find an exporter by exporter name
</summary>
        </member>
        <member name="M:MoCapCore.cExporterManager.FindExporter(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Attempt to find an exporter that writes to the requested extension type. If more than one
matching exporter is found, only the first one is returned.
</summary>
        </member>
        <member name="M:MoCapCore.cExporterManager.Exporter(System.Int32)">
            <summary>Retrieves the exporter at the given index. Borrowed reference. DO NOT DELETE.</summary>
        </member>
        <member name="M:MoCapCore.cExporterManager.ExporterCount">
            <summary>Returns the number of available exporters.</summary>
        </member>
        <member name="M:MoCapCore.cExporterManager.AddExporter(MoCapCore.cIExporter*)">
            <summary>Add a new exporter type. Ownership is transferred here.</summary>
        </member>
        <member name="T:MoCapCore.cExporterManager">
            <summary>
Manages instances of cIExporter, along with the operations involving file exporting.
</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceFrame.TimeCode">
            <summary>Time code information. Will be flagged as valid if timecode was present.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceFrame.AudioDataSize">
            <summary>Retrieve the analog data, if any.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceFrame.CameraFrameCount">
            <summary>Retrieve the device data, if any.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceFrame.MemorySize">
            <summary>Approximate size of this object in memory.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceFrame.SetAudioData(System.UInt32,System.Byte*)">
            <summary>Set the analog data for this frame, if any. Ownership of the passed pointer is transferred here.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceFrame.AddCameraFrame(Core.cICameraFrame*)">
            <summary>Add a device frame.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceFrame.Clone(std.shared_ptr&lt;Core.cICameraFrameFactory&gt;,System.Int32)">
            <summary>Clone this instance, and optionally exclude the given data types.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceFrame.Load(Core.cIReader*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;Core.cICameraFrameFactory&gt;,System.Int16)">
            <summary>Load this object from the given reader.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceFrame.Save(Core.cIWriter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Serialize this object to the given writer.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceTrack.UpdateNow">
            <summary>Runs the garbage collection and pre-fetch operation now rather than waiting for the next
wait interval to pass. Useful for clients that are just doing a temporary loading of frames to operate
on them, but do not want to have them remain in memory after that.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceTrack.SetBlockUnloadTimeThreshold(System.Double)">
            <summary>Set the time (in seconds) that frame blocks will be held in memory in between accesses.
Once this time threshold is exceeded, an unused block will be removed from memory.</summary>
        </member>
        <member name="T:MoCapCore.cMultiDeviceTrack.sCameraInfo">
            <summary>Adds to the given list of camera serial numbers that have data of the requested type(s).</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceTrack.Name">
            <summary>Returns the track name</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceTrack.Frame(System.Int32)">
            <summary>
Returns the frame at the given frame index. If no frame exists at that frame, a NULL frame is returned.
</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceTrack.IsComplete">
            <summary>Returns true if the track is "complete" (i.e. if data has been recorded and the
mode of the track has been set to read-only.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceTrack.Empty">
            <summary>Returns true if completely empty (no frames present).</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceTrack.FullTimecodeRange">
            <summary>Returns the full timecode range, or invalid values for timecode if no timecode data is present.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceTrack.FullFrameRange">
            <summary>Returns full frame range, or an empty range if no data is present.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceTrack.FullTimeRange">
            <summary>Returns full time range, or an empty range if no data is present.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceTrack.Load(System.Double)">
            <summary>Load initial contents, index tables, etc. from the input stream to prepare the object for use.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceTrack.Save(System.Boolean)">
            <summary>Finish saving to the output stream, pushing any unsaved data.</summary>
        </member>
        <member name="M:MoCapCore.cMultiDeviceTrack.Add(std.shared_ptr&lt;MoCapCore.cMultiDeviceFrame&gt;,Core.cTime!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Add a new multi-device frame. This should only be called during recording.</summary>
            <param name="writeBlockwise">
If true, blocks will be written out when kWriteBlockFrames have been added. Be careful
to set this option to false for real-time recording as it can block long enough during a block write
that one or more frames could be missed in recording.
</param>
        </member>
        <member name="M:MoCapCore.cMultiDeviceTrack.#ctor(MoCapCore.cIDataStream*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;Core.cICameraFrameFactory&gt;,System.Boolean)">
            <summary>
Create a new track. The readOnly parameter should be set to true if this track is being
loaded from a previously recorded track.
</summary>
        </member>
        <member name="T:MoCapCore.cMultiDeviceTrack">
            <summary>
A streaming container for camera and device data streams. This is a write-once, read-only container.
Once the track is saved using the Save() method, the track becomes read-only.
</summary>
        </member>
        <member name="M:Core.cStringHelpers.ReplaceSubstring(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Find and replace all occurrences of the given text</summary>
        </member>
        <member name="M:Core.cStringHelpers.TrimRight(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Trim a wstring from end.</summary>
        </member>
        <member name="M:Core.cStringHelpers.TrimRight(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Trim a string from end.</summary>
        </member>
        <member name="M:Core.cStringHelpers.TrimLeft(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Trim a wstring from start.</summary>
        </member>
        <member name="M:Core.cStringHelpers.TrimLeft(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Trim a string from start.</summary>
        </member>
        <member name="M:Core.cStringHelpers.Trim(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Trim a wstring.</summary>
        </member>
        <member name="M:Core.cStringHelpers.Trim(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Trim a string.</summary>
        </member>
        <member name="M:Core.cStringHelpers.ToInt64(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Convert a string to an integer value. Returns 0 if conversion fails.</summary>
        </member>
        <member name="M:Core.cStringHelpers.ToInt64(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Convert a string to an integer value. Returns 0 if conversion fails.</summary>
        </member>
        <member name="M:Core.cStringHelpers.ToInt(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Convert a string to an integer value. Returns 0 if conversion fails.</summary>
        </member>
        <member name="M:Core.cStringHelpers.ToInt(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Convert a string to an integer value. Returns 0 if conversion fails.</summary>
        </member>
        <member name="M:Core.cStringHelpers.ToDouble(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Convert a string to a floating-point value. Returns 0 if conversion fails.</summary>
        </member>
        <member name="M:Core.cStringHelpers.Tokenize(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Char!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
            <summary>Split a string into a vector of strings, removing the delimiter.</summary>
        </member>
        <member name="M:Core.cStringHelpers.ToLower(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Convert a string to all lowercase characters.</summary>
        </member>
        <member name="M:Core.cStringHelpers.AreEqualNoCase(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Do a case-insensitive compare between two strings.</summary>
        </member>
        <member name="M:Core.cStringHelpers.Format(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst,BTEllipsis)">
            <summary>Implementation of sprintf for wstrings.</summary>
        </member>
        <member name="M:Core.cStringHelpers.ConvertFromWString(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Convert a (UTF-16) std::wstring to a (UTF-8) std::string.</summary>
        </member>
        <member name="M:Core.cStringHelpers.ConvertToWString(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Convert a (UTF-8) std::string to a (UTF-16) std::wstring.</summary>
        </member>
        <member name="M:Core.cStringHelpers.AreDigits(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt64,System.UInt64)">
            <summary>Returns true if the characters in the given range are all numeric digits.</summary>
        </member>
        <member name="M:Core.cStringHelpers.IncrementName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Uses the standard method to increment the given name. The standard method looks for
(%d), and adds (2) if it is not found, and replaces it with (%d+1) if found.
</summary>
        </member>
        <member name="T:Core.cStringHelpers">
            <summary>A collection of platform-neutral string management routines.</summary>
        </member>
        <member name="M:NMotive.NodeWarehouse.ClearRigidBodyNodes">
            <summary>
Removes all rigid body nodes.
</summary>
            <returns>The number of nodes removed.</returns>
        </member>
        <member name="M:NMotive.NodeWarehouse.ClearSkeletonNodes">
            <summary>
Removes all skeleton nodes.
</summary>
            <returns>The number of nodes removed.</returns>
        </member>
        <member name="M:NMotive.NodeWarehouse.ClearMarkerSetNodes">
            <summary>
Removes all marker set nodes.
</summary>
            <returns>The number of nodes removed.</returns>
        </member>
        <member name="M:NMotive.NodeWarehouse.ClearMarkerNodes">
            <summary>
Removes all marker nodes.
</summary>
            <returns>The number of nodes removed.</returns>
        </member>
        <member name="M:NMotive.NodeWarehouse.ClearJointNodes">
            <summary>
Removes all joint nodes.
</summary>
            <returns>The number of nodes removed.</returns>
        </member>
        <member name="M:NMotive.NodeWarehouse.RemoveNode(System.String)">
            <summary>
Removes the first node found with the given name.
</summary>
            <param name="nodeName">Name of the node to remove.</param>
            <returns>
                <c>true</c> if a node with the given name was found and successfully removed.</returns>
        </member>
        <member name="M:NMotive.NodeWarehouse.RemoveNode(NMotive.UID)">
            <summary>
Removes the node with the given ID.
</summary>
            <param name="nodeId">ID of the node to remove.</param>
            <returns>
                <c>true</c> if the node was found and successfully removed.</returns>
        </member>
        <member name="M:NMotive.NodeWarehouse.AddNode(NMotive.Node)">
            <summary>
Add a node to the scene.
</summary>
            <param name="node">The node to add.</param>
            <returns>
                <c>true</c> if the node was successfully added. <c>false</c>
otherwise.</returns>
        </member>
        <member name="M:NMotive.NodeWarehouse.AllMarkerSets">
            <summary>
Get a list of all marker sets.
</summary>
            <returns>List of marker sets.</returns>
        </member>
        <member name="M:NMotive.NodeWarehouse.AllSkeletons">
            <summary>
Retrieves a list of all skeleton nodes.
</summary>
            <returns>A list of the skeleton nodes. If there are no skeleton nodes
the returned list will be empty.</returns>
        </member>
        <member name="M:NMotive.NodeWarehouse.AllRigidBodies">
            <summary>
Retrieves a list of all rigid body nodes.
</summary>
            <returns>A list of the trackible nodes. If there are no trackible nodes
the returned list will be empty.</returns>
        </member>
        <member name="M:NMotive.NodeWarehouse.AllJoints">
            <summary>
Retrieves a list of all joint nodes.
</summary>
            <returns>A list of the joint nodes. If there are no joint nodes
the returned list will be empty.</returns>
        </member>
        <member name="M:NMotive.NodeWarehouse.AllMarkers">
            <summary>
Retrieves a list of all marker nodes.
</summary>
            <returns>A list of the marker nodes. If there are no marker nodes
the returned list will be empty.</returns>
        </member>
        <member name="T:NMotive.NodeWarehouse">
            <summary>
Manages all 3D objects in the scene.
</summary>
        </member>
        <member name="P:NMotive.AnimatedNode.KeyFrameRange">
            <summary>
Gets the keyframe range.
</summary>
        </member>
        <member name="P:NMotive.AnimatedNode.ChannelCount">
            <summary>
Gets the number of channels available.
</summary>
        </member>
        <member name="M:NMotive.AnimatedNode.HasChannel(NMotive.Channel.ChannelType)">
            <summary>
Returns true if a channel of the given type exists on this node.
</summary>
            <param name="channelType">Type of channel.</param>
            <returns>
                <c>true</c> if this node contains data for the
specified channel type.</returns>
        </member>
        <member name="M:NMotive.AnimatedNode.WorldTransform(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Get the full world coordinate transform at the given time.
</summary>
            <param name="frameIndex">The frame index.</param>
            <returns>The simple affine world transformation for the frame.</returns>
        </member>
        <member name="M:NMotive.AnimatedNode.Transform(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Get the full transform at the given time.
</summary>
            <param name="frameIndex">The frame index.</param>
            <returns>The simple affine transformation for the frame.</returns>
        </member>
        <member name="M:NMotive.AnimatedNode.Rotation(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Get the local rotation at the given time.
</summary>
            <param name="frameIndex">The frame index.</param>
            <returns>The rotation as a unit quaternion for the frame.</returns>
        </member>
        <member name="M:NMotive.AnimatedNode.Translation(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Get the local position at the given frame index.
</summary>
            <param name="frameIndex">The frame index.</param>
            <returns>Local position of the frame index.</returns>
        </member>
        <member name="P:NMotive.AnimatedNode.RotationChannel">
            <summary>
Gets the rotation channel. If there is no rotation channel 
<c>null</c> is returned.
</summary>
        </member>
        <member name="P:NMotive.AnimatedNode.TranslationChannel">
            <summary>
Gets the translation channel. If there is
no translation channel <c>null</c> is returned.
</summary>
        </member>
        <member name="M:NMotive.AnimatedNode.SetRotation(System.Int32!System.Runtime.CompilerServices.IsLong,NMotive.Quaternion)">
            <summary>
A convenience method for setting local rotation. The default rotation will be set if no animation
channel exists.
</summary>
            <param name="frameIndex">Frame index to set value on.</param>
            <param name="val">The value to set.</param>
            <returns>True if the key was set. False if a key was not set, but the default value was.</returns>
        </member>
        <member name="M:NMotive.AnimatedNode.SetTranslation(System.Int32!System.Runtime.CompilerServices.IsLong,NMotive.Vector3f)">
            <summary>
A convenience method for setting local translation. The default translation value will be set if no
animation channel exists.
</summary>
            <param name="frameIndex">Frame index to set value on.</param>
            <param name="val">The value to set.</param>
            <returns>True if the key was set. False if a key was not set, but the default value was.</returns>
        </member>
        <member name="M:NMotive.AnimatedNode.SetChannel(NMotive.Channel)">
            <summary>
Set one of the animation channels. Which channel gets set is governed by the Type()
of the given channel.
</summary>
            <param name="channel">The channel.</param>
            <returns>True if the given channel was a match for this node and was set as the translation channel.</returns>
        </member>
        <member name="M:NMotive.AnimatedNode.Clear">
            <summary>
Clear all animation data.
</summary>
        </member>
        <member name="M:NMotive.AnimatedNode.Clear(NMotive.FrameRange)">
            <summary>
Clear all animation data over the given range.
</summary>
            <param name="range">A range</param>
        </member>
        <member name="M:NMotive.AnimatedNode.IsKeyed(NMotive.FrameRange)">
            <summary>
Checks for the presence of keyed data in a give range.
</summary>
            <param name="range">A range.</param>
            <returns>Returns <c>true</c> if a transform key exists in the given range.</returns>
        </member>
        <member name="M:NMotive.AnimatedNode.IsKeyed">
            <summary>
Checks for the presence of keyed data.
</summary>
            <returns>Returns <c>true</c> if a transform key exists.</returns>
        </member>
        <member name="T:NMotive.AnimatedNode">
            <summary>
Base class for animated nodes in a scene. Nodes are gathered into a hierarchy in the scene
where they are either a child of the root scene node <c>NodeWarehouse</c>
or a child of another existing node in the scene.
Each node also has a transform that accumulates with its parent transform such that a full transform
hierarchy is formed by traversing the node hierarchy.</summary>
        </member>
        <member name="M:NMotive.QuaternionChannel.FindKeys(NMotive.FrameRange)">
            <summary>
Retrieve all the keys that fall within the given time range, including end points. The keys
in the returned array are guaranteed to be in order of increasing time.
</summary>
            <param name="range">Find keys in this frame range.</param>
            <returns>List of keyframes in the given range. The list may be
empty.</returns>
        </member>
        <member name="M:NMotive.QuaternionChannel.AllKeys">
            <summary>
Retrieve a copy of the entire list of keys.
</summary>
            <returns>The list of all keys.</returns>
        </member>
        <member name="M:NMotive.QuaternionChannel.KeyExtents(NMotive.FrameRange,System.Int32,NMotive.Quaternion@,NMotive.Quaternion@)">
            <summary>
Calculate the min and max values in the requested dimension for all 
keys within the given range.
</summary>
            <param name="range">Get extents for keys in this frame range.</param>
            <param name="axis">Index of axis for which to retrieve extents if keys
exist in the given range.</param>
            <param name="minVals">If there are keys in the range min exents will be placed in 
<c>minVals[axis]</c>.</param>
            <param name="maxVals">If there are keys in the range max exents will be placed in 
<c>maxVals[axis]</c>.</param>
            <returns>False if there are no keys in the given range.</returns>
        </member>
        <member name="M:NMotive.QuaternionChannel.Value(System.TimeSpan)">
            <summary>
Evaluate the channel at the given time and return its value. Will interpolate 
keys where needed.
</summary>
            <param name="fractionalFrame">Fractional frame time of the value.</param>
            <returns>The value at the frame time.</returns>
        </member>
        <member name="M:NMotive.QuaternionChannel.TryGetValue(System.Int32,NMotive.Quaternion@)">
            <summary>
Get the value the channel at the given frame if it frame is a key. No interpolation.
</summary>
            <param name="frame">Frame index.</param>
            <param name="val">If the return value is true, contains the value.
If the return value is false this value is untouched.</param>
            <returns>true if there is a value for this frame. In this case 
<c>val</c> contains the value</returns>
        </member>
        <member name="M:NMotive.QuaternionChannel.InsertKeys(System.Collections.Generic.List`1{NMotive.Keyframe`1{NMotive.Quaternion}}!System.Runtime.CompilerServices.IsByValue,System.Boolean)">
            <summary>
Inserts the given keys into this channel. The time range of 
the incoming keys is cleared before
setting new keys. The given keys must be in the array in order 
of increasing frame number.
</summary>
            <param name="sourceKeys">Keys to insert.</param>
            <param name="preserveOriginal">Preserve original key values.</param>
        </member>
        <member name="M:NMotive.QuaternionChannel.SetKeys(System.Collections.Generic.List`1{NMotive.Keyframe`1{NMotive.Quaternion}}!System.Runtime.CompilerServices.IsByValue,System.Boolean)">
            <summary>
Convenience method for setting multiple keys at once.
</summary>
            <param name="keys">The keys to set.</param>
            <param name="addIfNotFound">If true, a new key will be created 
if one does not exist for each key.</param>
        </member>
        <member name="M:NMotive.QuaternionChannel.SetKey(NMotive.Quaternion,System.Int32!System.Runtime.CompilerServices.IsLong,System.Boolean)">
            <summary>
Set a key at the given frame.
</summary>
            <param name="val">Key value to assign</param>
            <param name="tm">Frame index at which to add the key</param>
            <param name="addIfNotFound">If true, a new key will be created at 
the given time if one does not exist</param>
        </member>
        <member name="M:NMotive.QuaternionChannel.SetKey(NMotive.Keyframe`1{NMotive.Quaternion},System.Boolean)">
            <summary>
Set a keyframe.
</summary>
            <param name="key">Keyframe to add</param>
            <param name="addIfNotFound">If true, a new key will be created at the
given time if one does not exist</param>
        </member>
        <member name="P:NMotive.QuaternionChannel.DefaultValue">
            <summary>
Sets and gets the default value to use when no keys exist.
</summary>
        </member>
        <member name="M:NMotive.QuaternionChannel.#ctor">
            <summary>
Constructs an empty <c>QuaternionChannel</c> object.
</summary>
        </member>
        <member name="T:NMotive.QuaternionChannel">
            <summary>
Quaternion channel values for a node.
</summary>
        </member>
        <member name="P:NMotive.Node.Name">
            <summary>
Gets and sets the name for this node.
</summary>
        </member>
        <member name="P:NMotive.Node.ID">
            <summary>
Gets the ID for this node.
</summary>
        </member>
        <member name="P:NMotive.Node.Visible">
            <summary>
Gets and sets this nodes visible state.
</summary>
        </member>
        <member name="P:NMotive.Node.Active">
            <summary>
Gets and sets this nodes active state.
</summary>
        </member>
        <member name="M:NMotive.Node.#cctor">
            <exclude />
        </member>
        <member name="T:NMotive.Node">
            <summary>
Base class for all objects in a take scene.
</summary>
        </member>
        <member name="M:NMotive.SimpleTransformf.ToString">
            <summary>
Creates a string representation of self.
</summary>
            <returns>A string representation of self.</returns>
        </member>
        <member name="M:NMotive.SimpleTransformf.Equals(NMotive.SimpleTransformf,System.Single)">
            <summary>
Does a comparison with another transform. This is an approximate comparison.
</summary>
            <param name="other">Transform to compare self to.</param>
            <param name="tolerance">Tolerance to be used for the comparison.</param>
            <returns>
                <c>true</c> if transforms are equal within tolerance.</returns>
        </member>
        <member name="M:NMotive.SimpleTransformf.IsIdentity">
            <summary>
Check if the transform is the identity (i.e. no transform).
</summary>
            <returns>
                <c>true</c> if this transform is the identity transformation.</returns>
        </member>
        <member name="M:NMotive.SimpleTransformf.InverseTransform(NMotive.Vector3f)">
            <summary>
Transform the given point through the inverse of this transform. 
Transform order is Rotate-Translate by convention.
</summary>
            <param name="point">Point to transform.</param>
            <returns>The transformed point.</returns>
        </member>
        <member name="M:NMotive.SimpleTransformf.Transform(NMotive.Vector3f)">
            <summary>
Transform the given point through this transform. Transform order is Rotate-Translate by convention.
</summary>
            <param name="point">Point to transform.</param>
            <returns>The transformed point.</returns>
        </member>
        <member name="M:NMotive.SimpleTransformf.Transform(NMotive.SimpleTransformf)">
            <summary>
Transforms our coordinate system by the given transform.
</summary>
            <param name="transform">A simple transformation.</param>
        </member>
        <member name="M:NMotive.SimpleTransformf.Invert">
            <summary>
Invert this transform in place.
</summary>
        </member>
        <member name="M:NMotive.SimpleTransformf.Translate(NMotive.Vector3f)">
            <summary>
Accumulates the given translation into the transform. Given translation is understood to
to be in the local coordinate system.
</summary>
            <param name="translation">Translation to be added.</param>
        </member>
        <member name="M:NMotive.SimpleTransformf.Rotate(NMotive.Quaternion)">
            <summary>Accumulates the given rotation into the transform.</summary>
            <param name="rotation">Rotation to be added.</param>
        </member>
        <member name="P:NMotive.SimpleTransformf.Rotation">
            <summary>
Gets and sets the rotation quaternion for this transformation.
</summary>
        </member>
        <member name="P:NMotive.SimpleTransformf.Translation">
            <summary>
Gets and sets the translation vector for this transformation.
</summary>
        </member>
        <member name="M:NMotive.SimpleTransformf.#ctor(NMotive.Vector3f,NMotive.Quaternion)">
            <summary>
Constructs a simple transform object with the given translation
and rotation.
</summary>
            <param name="translation">The translation vector.</param>
            <param name="rotation">The rotation expressed as a unit quaternion.</param>
        </member>
        <member name="M:NMotive.SimpleTransformf.#ctor">
            <summary>
Parameterless constructor. Constructs the identity transformation.
</summary>
        </member>
        <member name="T:NMotive.SimpleTransformf">
            <summary>
Class representing a "simple" transform, i.e. a rotation plus translation. Scale
is presumed to be one.
</summary>
        </member>
        <member name="M:NMotive.Quaternion.ToString">
            <summary>
A string representation of self.
</summary>
            <returns>A string representation of self.</returns>
        </member>
        <member name="M:NMotive.Quaternion.Equals(NMotive.Quaternion,System.Single)">
            <summary>
Compares this quaternion to another for equality with a specified
tolerance..
</summary>
            <param name="other">Quaternion to compare self to.</param>
            <param name="tolerance">A tolerance to use for comparison.</param>
            <returns>
                <c>true</c> if all components are equal withing the
specified tolerance - the absolute value of the difference of
each component must be less than the tolerance.</returns>
        </member>
        <member name="M:NMotive.Quaternion.Equals(NMotive.Quaternion)">
            <summary>
Compares this quaternion to another for equality.
</summary>
            <param name="other">Quaternion to compare self to.</param>
            <returns>
                <c>true</c> if all components are exactly equal.</returns>
        </member>
        <member name="M:NMotive.Quaternion.Rotate(NMotive.Vector3f)">
            <summary>Rotate the given vector through the rotation of this quaternion.</summary>
            <param name="vec">Vector to rotate.</param>
            <returns>The rotated vector.</returns>
        </member>
        <member name="M:NMotive.Quaternion.Invert">
            <summary>
Invert this quaternion.
</summary>
            <returns>This object inverted.</returns>
        </member>
        <member name="M:NMotive.Quaternion.Conjugate">
            <summary>
Conjugates this quaternion.
</summary>
            <returns>This object conjucated.</returns>
        </member>
        <member name="M:NMotive.Quaternion.Normalize">
            <exclude />
        </member>
        <member name="M:NMotive.Quaternion.Norm">
            <exclude />
        </member>
        <member name="M:NMotive.Quaternion.NormSquared">
            <exclude />
        </member>
        <member name="M:NMotive.Quaternion.AxisAngle">
            <summary>Get Axis Angle. Angle is encoded in vector's length</summary>
            <returns>A vector representation of the axis angle.</returns>
        </member>
        <member name="M:NMotive.Quaternion.SetAxisAngle(NMotive.Vector3f)">
            <summary>Set Axis Angle. Angle is encoded in vector's length</summary>
            <param name="axisAngleVector">The angle encoded as a vector.</param>
        </member>
        <member name="M:NMotive.Quaternion.SetRealPart(NMotive.Vector3f)">
            <summary>Set the real part (i.e. XYZ components) of the quaternion.</summary>
            <param name="vals">Vector of value. 
vals[0] = x-value.
vals[1] = y-value.
vals[2] = z-value.</param>
        </member>
        <member name="M:NMotive.Quaternion.SetValues(System.Single[])">
            <summary>
Sets the values for this quaternion.
</summary>
            <param name="vals">Vector of value. 
vals[0] = x-value.
vals[1] = y-value.
vals[2] = z-value.
vals[3] = w-value.</param>
        </member>
        <member name="M:NMotive.Quaternion.SetValues(System.Single,System.Single,System.Single,System.Single)">
            <summary>
Sets the values for this quaternion.
</summary>
            <param name="x">X value.</param>
            <param name="y">Y value.</param>
            <param name="z">Z value.</param>
            <param name="w">W value.</param>
        </member>
        <member name="M:NMotive.Quaternion.FromOrthogonalVectors(NMotive.Vector3f,NMotive.Vector3f)">
            <summary>Create unit quaternion from 2 orthogonal vectors</summary>
            <param name="vec1">A vector.</param>
            <param name="vec2">A vector.</param>
            <returns>Unit quaternion from 2 orthogonal vectors.</returns>
        </member>
        <member name="M:NMotive.Quaternion.FromVectors(NMotive.Vector3f,NMotive.Vector3f)">
            <summary>Create a unit quaternion from 2 vectors.</summary>
            <param name="vec1">A vector.</param>
            <param name="vec2">A vector.</param>
            <returns>Unit quaternion from 2 vectors.</returns>
        </member>
        <member name="M:NMotive.Quaternion.Slerp(NMotive.Quaternion,NMotive.Quaternion,System.Single)">
            <summary>
Returns a spherical linear interpolated quaternion some percentage 't' between two quaternions.
The parameter t is usually in the range [0,1], but this method can also be used to extrapolate
rotations beyond that range.
</summary>
            <param name="q1">A quaternion.</param>
            <param name="q2">A quaternion.</param>
            <param name="t">Percentage expressed as fraction between 0 and 1.</param>
            <returns>Interpolated value.</returns>
        </member>
        <member name="M:NMotive.Quaternion.Lerp(NMotive.Quaternion,NMotive.Quaternion,System.Single)">
            <summary>
Returns a linear interpolated quaternion some percentage 't' between two quaternions.
The parameter t is usually in the range [0,1], but this method can also be used to extrapolate
rotations beyond that range.
</summary>
            <param name="q1">A quaternion.</param>
            <param name="q2">A quaternion.</param>
            <param name="t">Percentage expressed as fraction between 0 and 1.</param>
            <returns>Interpolated value.</returns>
        </member>
        <member name="M:NMotive.Quaternion.Inverse(NMotive.Quaternion)">
            <summary>
Computes the inverse of a quaternion.
</summary>
            <param name="q">A quaternion.</param>
            <returns>The inverse of <c>q</c>.</returns>
        </member>
        <member name="M:NMotive.Quaternion.Conjugate(NMotive.Quaternion)">
            <summary>
Forms the conjugate of a quaternion.
</summary>
            <param name="q">A quaternion.</param>
            <returns> The conjugate of <c>q</c>.</returns>
        </member>
        <member name="M:NMotive.Quaternion.Dot(NMotive.Quaternion,NMotive.Quaternion)">
            <summary>
Dot product.
</summary>
            <param name="p">A quaternion.</param>
            <param name="q">A quaternion.</param>
            <returns>The dot product of <c>p</c> and <c>q</c>.</returns>
        </member>
        <member name="M:NMotive.Quaternion.op_Inequality(NMotive.Quaternion,NMotive.Quaternion)">
            <summary>
Inequality operator for quaternions.
</summary>
            <param name="p">A quaternion.</param>
            <param name="q">A quaternion.</param>
            <returns>
                <c>true</c> if the two quaternions differ in at
least one component.</returns>
        </member>
        <member name="M:NMotive.Quaternion.op_Equality(NMotive.Quaternion,NMotive.Quaternion)">
            <summary>
Equality operator for quaternions.
</summary>
            <param name="p">A quaternion.</param>
            <param name="q">A quaternion.</param>
            <returns>
                <c>true</c> if the two quaternions are exactly equal,
component-wise.</returns>
        </member>
        <member name="M:NMotive.Quaternion.op_Multiply(NMotive.Quaternion,NMotive.Quaternion)">
            <summary>
Multiplies two quaternions.
</summary>
            <param name="p">A quaternion.</param>
            <param name="q">A quaternion.</param>
            <returns> Product as a unit quaternion.</returns>
        </member>
        <member name="P:NMotive.Quaternion.default(System.Int32)">
            <summary>
Index operator
</summary>
        </member>
        <member name="P:NMotive.Quaternion.RealPart">
            <summary>
Gets and sets the real part of the quaternion.
</summary>
        </member>
        <member name="P:NMotive.Quaternion.W">
            <summary>
Gets and sets the w or scalar component.
</summary>
        </member>
        <member name="P:NMotive.Quaternion.Z">
            <summary>
Gets and sets the z or k component.
</summary>
        </member>
        <member name="P:NMotive.Quaternion.Y">
            <summary>
Gets and sets the y or j component.
</summary>
        </member>
        <member name="P:NMotive.Quaternion.X">
            <summary>
Gets and sets the x or i component.
</summary>
        </member>
        <member name="M:NMotive.Quaternion.#ctor(System.Single[])">
            <summary>
Constructs a unit <c>Quaternion</c> object from the given array of components.
</summary>
            <param name="vals">
                <c>vals[0]</c> = i component,
<c>vals[1]</c> = j component,
<c>vals[2]</c> = k component,
<c>vals[3]</c> = scalar component,
</param>
        </member>
        <member name="M:NMotive.Quaternion.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
Constructs a unit <c>Quaternion</c> object from the given vector and scalar
parts.
</summary>
            <param name="x">i component.</param>
            <param name="y">j component.</param>
            <param name="z">k component.</param>
            <param name="w">Scalar component.</param>
        </member>
        <member name="T:NMotive.Quaternion">
            <summary>
Unit quaternion class.
</summary>
        </member>
        <member name="T:MotiveCore.vrpn_RigidBody_Tracker">
            <summary>VRPN tracker interface</summary>
        </member>
        <member name="M:MotiveCore.cRigidBodyNode.MarkerPropertyNames(System.UInt32)">
            <summary>Returns, respectively, the marker ID and marker location property names for the marker of the given index.</summary>
        </member>
        <member name="M:MotiveCore.cRigidBodyNode.SetChannel(std.unique_ptr&lt;MoCapCore.cIChannel,std.default_delete&lt;MoCapCore.cIChannel&gt;&gt;)">
cIChannelProvider
</member>
        <member name="M:MotiveCore.cRigidBodyNode.GenerateNewID">
            <summary>Generates a new ID for this object. This should only be called by the framework, and is
typically used to resolve ID conflicts.</summary>
        </member>
        <member name="M:MotiveCore.cRigidBodyNode.ActiveTagRfChannel">
            <summary>Retrieve Active Tag RF channel.</summary>
        </member>
        <member name="M:MotiveCore.cRigidBodyNode.SetActiveTagRfChannel(System.Int32)">
            <summary>Set the Active Tag RF channel.</summary>
        </member>
        <member name="M:MotiveCore.cRigidBodyNode.ActiveTagID">
            <summary>Retrieve Active Tag ID.</summary>
        </member>
        <member name="M:MotiveCore.cRigidBodyNode.SetActiveTagID(System.Int32)">
            <summary>Set the Active Tag ID.</summary>
        </member>
        <member name="M:MotiveCore.cRigidBodyNode.UserID">
            <summary>Retrieve the user ID.</summary>
        </member>
        <member name="M:MotiveCore.cRigidBodyNode.SetUserID(System.Int32)">
            <summary>Set the user ID</summary>
        </member>
        <member name="M:MotiveCore.cRigidBodyNode.CalibrationTime">
            <summary>Retrieve the time this object was last calibrated, or cTime::kInvalid if none.</summary>
        </member>
        <member name="M:MotiveCore.cRigidBodyNode.SetCalibrationTime(Core.cTime!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Convenience method to set the "last calibration time" for this object.</summary>
        </member>
        <member name="M:vrpn_Tracker_Server.mainloop">
This function should be called each time through app mainloop.
</member>
        <member name="M:vrpn_Tracker_Serial.mainloop">
Uses the get_report, send_report, and reset routines to implement a
server
</member>
        <member name="M:vrpn_Tracker_Serial.reset">
Reset the tracker.
</member>
        <member name="M:vrpn_Tracker_Serial.get_report">
Gets a report if one is available, returns 0 if not, 1 if complete
report.
</member>
        <member name="M:vrpn_BaseClass.register_types">
Register the types of messages this device sends/receives.
Return 0 on success, -1 on fail.
</member>
        <member name="M:vrpn_BaseClass.register_senders">
Register the sender for this device (by default, the name of the
device). Return 0 on success, -1 on fail.
</member>
        <member name="M:vrpn_BaseClass.init">
Initialize things that the constructor can't. Returns 0 on
success, -1 on failure.
</member>
        <member name="M:vrpn_BaseClass.mainloop">
Called once through each main loop iteration to handle updates.
Remote object mainloop() should call client_mainloop() and
then call d_connection-&gt;mainloop().
Server object mainloop() should service the device and then
call server_mainloop(), but should not normally call
d_connection-&gt;mainloop().
</member>
        <member name="M:vrpn_BaseClass.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,vrpn_Connection*)">
Names the device and assigns or opens connection,
calls registration methods
</member>
        <member name="T:vrpn_BaseClass">
Class from which all user-level (and other) classes that communicate
with vrpn_Connections should derive.
</member>
        <member name="M:vrpn_BaseClassUnique.handle_ping(System.Void*,vrpn_HANDLERPARAM)">
Used by client/server code to request/send "server is alive" (pong)
message
</member>
        <member name="M:vrpn_BaseClassUnique.client_mainloop">
Handles functions that all clients should provide in their mainloop()
(warning of no server, for example)
Should be called by all clients in their mainloop()
</member>
        <member name="M:vrpn_BaseClassUnique.server_mainloop">
Handles functions that all servers should provide in their mainloop()
(ping/pong, for example)
Should be called by all servers in their mainloop()
</member>
        <member name="M:vrpn_BaseClassUnique.decode_text_message_from_buffer(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,vrpn_TEXT_SEVERITY*,System.UInt32*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Decodes the body of the text message from a buffer from the connection
</member>
        <member name="M:vrpn_BaseClassUnique.encode_text_message_to_buffer(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,vrpn_TEXT_SEVERITY,System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Encodes the body of the text message into a buffer, preparing for
sending
</member>
        <member name="M:vrpn_BaseClassUnique.register_autodeleted_handler(System.Int32,=FUNC:System.Int32(System.Void*,vrpn_HANDLERPARAM),System.Void*,System.Int32)">
Registers a handler with the connection, and remembers to delete at
destruction.
</member>
        <member name="F:vrpn_BaseClassUnique.d_sender_id">
part
</member>
        <member name="M:vrpn_BaseClassUnique.connectionPtr">
Returns a pointer to the connection this object is using
</member>
        <member name="T:vrpn_BaseClassUnique">
INTERNAL class to hold members that there should only be one copy of
even when a class inherits from multiple vrpn_BaseClasses because it
inherits from multiple user-level classes.  Note that not everything in
vrpnBaseClass should be here, because (for example) the registration of
types should be done for each parent class.
</member>
        <member name="M:vrpn_TextPrinter.text_message_handler(System.Void*,vrpn_HANDLERPARAM)">
Handles the text messages that come from the connections for
objects we are watching.
</member>
        <member name="T:vrpn_TextPrinter.vrpn_TextPrinter_Watch_Entry">
Structure to hold the objects that are being watched.
</member>
        <member name="F:vrpn_TextPrinter.d_semaphore">
Mutex to ensure thread safety;
</member>
        <member name="M:vrpn_TextPrinter.set_ostream_to_use(_iobuf*)">
Change the ostream that will be used to print messages.  Setting a
NULL ostream results in no printing.
</member>
        <member name="M:vrpn_TextPrinter.set_min_level_to_print(vrpn_TEXT_SEVERITY,System.UInt32)">
Change the level of printing for the object (sets the minimum level to
print). Default is Warnings and Errors of all levels.
</member>
        <member name="M:vrpn_TextPrinter.remove_object(vrpn_BaseClass*)">
Remove an object from the list of watched objects (multiple deletions
of the object will not cause any error condition; deletions of
unregistered objects will not cause errors).
</member>
        <member name="M:vrpn_TextPrinter.add_object(vrpn_BaseClass*)">
Adds an object to the list of watched objects (multiple registration
of the same object will result in only one printing for each message
from the object). Returns 0 on success and -1 on failure.
YOU MUST REMOVE any objects from a vrpn_TextPrinter that you create
before destroying the printer if any connection objects survive,
otherwise they may call a callback function on the destroyed object.
</member>
        <member name="T:vrpn_TextPrinter">
Class that handles text/warning/error printing for all objects in the
system.
</member>
        <member name="F:vrpn_ConnectionManager.d_anonList">
@brief unnamed (server) connections
</member>
        <member name="F:vrpn_ConnectionManager.d_kcList">
@brief named connections
</member>
        <member name="M:vrpn_ConnectionManager.getByName(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@}
Searches through d_kcList but NOT d_anonList
(Connections constructed with no name)
</member>
        <member name="M:vrpn_ConnectionManager.addConnection(vrpn_Connection*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
NB implementation is not particularly efficient;  we expect
to have O(10) connections, not O(1000).
@{
</member>
        <member name="M:vrpn_ConnectionManager.instance">
@brief The only way to get access to an instance of this class.
Guarantees that there is only one, global object.
Also guarantees that it will be constructed the first time
this function is called, and (hopefully?) destructed when
the program terminates.
</member>
        <member name="T:vrpn_ConnectionManager">
@}
 @brief Singleton class that keeps track of all known VRPN connections
 and makes sure they're deleted on shutdown.

 We make it static to guarantee that the destructor is called
 on program close so that the destructors of all the vrpn_Connections
 that have been allocated are called so that all open logs are flushed
 to disk.  Each connection should add itself to this list in its
 constructor and should remove itself from this list in its
 destructor.

</member>
        <member name="M:vrpn_noint_block_write(System.UInt64,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt64)">
@name Utility routines for reading from and writing to sockets/file
descriptors
@{
</member>
        <member name="M:vrpn_cookie_size">
@}
@brief Returns the size of the magic cookie buffer, plus any alignment
overhead.
</member>
        <member name="M:check_vrpn_cookie(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Checks the buffer to see if it is a valid VRPN header cookie.
Returns -1 on total mismatch,
1 on minor version mismatch or other acceptable difference,
and 0 on exact match.
@{
</member>
        <member name="M:vrpn_set_service_name(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@}
@brief Utility routine to rename the service name of a given host specifier.
</member>
        <member name="M:vrpn_create_server_connection(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Lets you make one with the default settings, or just ask for a specific
port number on the default NIC on this machine.  This matches the
signature on the old constructor to make it easier to port existing
servers.
</member>
        <member name="M:vrpn_create_server_connection(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@brief Create a server connection of arbitrary type (VRPN UDP/TCP,
TCP, File, Loopback, MPI).

Returns NULL if the name is not understood or the connection cannot
be created.
WARNING:  May not be thread safe.
To create a VRPN TCP/UDP server, use a name like:
   vrpn:machine_name_or_ip:port
   machine_name_or_ip:port
   machine_name_or_ip
   :port       (This port on any network card.)
To create an MPI server, use a name like:
   mpi:MPI_COMM_WORLD
   mpi:comm_number
When done with the object, call removeReference() on it (which will
delete it if there are no other references).
</member>
        <member name="M:vrpn_get_connection_by_name(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
@brief Create a client connection of arbitrary type (VRPN UDP/TCP, TCP,
File, Loopback, MPI).

WARNING:  May not be thread safe.
If no IP address for the NIC to use is specified, uses the default
NIC.  If the force_reopen flag is set, a new connection will be
made even if there was already one to that server.
When done with the object, call removeReference() on it (which will
delete it if there are no other references).
</member>
        <member name="M:vrpn_Connection_Loopback.send_pending_reports">
@brief send pending report, clear the buffer.

This function was protected, now is public, so we can use it
to send out intermediate results without calling mainloop
</member>
        <member name="M:vrpn_Connection_Loopback.connected">
Returns vrpn_true if the connection has been established, vrpn_false if not
(For a networkless connection, this is equivalent to doing_okay()).
</member>
        <member name="M:vrpn_Connection_Loopback.doing_okay">
Returns vrpn_true if the connection is okay, vrpn_false if not
</member>
        <member name="M:vrpn_Connection_Loopback.#ctor">
Make a client connection.  To access this from user code,
call vrpn_create_server_connection() with a service name
of 'loopback:'.
For now, we don't enable logging on a Loopback connection.
</member>
        <member name="T:vrpn_Connection_Loopback">
@brief Constructor for a Loopback connection that will basically just
pass messages between objects that are connected to it.  It offers no
external connections, via IP or any other mechanism.  It is useful
if you want to make the client and server in the same connection and
you don't need to have anything else connect.
</member>
        <member name="M:vrpn_Connection_IP.handle_connection(System.Int32)">
This routine is called by a server-side connection when a
new connection has just been established, and the tcp port
has been connected to it.
</member>
        <member name="M:vrpn_Connection_IP.send_pending_reports">
@brief send pending report, clear the buffer.

This function was protected, now is public, so we can use it
to send out intermediate results without calling mainloop
</member>
        <member name="M:vrpn_Connection_IP.init">
@brief Called by all constructors
</member>
        <member name="M:vrpn_Connection_IP.handle_UDP_message(System.Void*,vrpn_HANDLERPARAM)">
@}
Routines that handle system messages
</member>
        <member name="F:vrpn_Connection_IP.listen_udp_sock">
@name Only used for a vrpn_Connection that awaits incoming connections
@{
</member>
        <member name="F:vrpn_Connection_IP.d_stop_processing_messages_after">
If this value is greater than zero, the connection should stop
looking for new messages on a given endpoint after this many
are found.
</member>
        <member name="M:vrpn_Connection_IP.connect_to_client(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
This is similar to check connection except that it can be
used to receive requests from before a server starts up
</member>
        <member name="M:vrpn_Connection_IP.#ctor(System.UInt16,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,=FUNC:vrpn_Endpoint_IP*(vrpn_Connection*,System.Int32*))">
Make a server that listens for client connections.
DEPRECATED: Call vrpn_create_server_connection() with the
NIC name and port number you want.
</member>
        <member name="M:vrpn_Connection_IP.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,=FUNC:vrpn_Endpoint_IP*(vrpn_Connection*,System.Int32*))">
Make a client connection.  To access this from user code,
call vrpn_get_connection_by_name().
  Create a connection -  if server_name is not a file: name,
makes an SDI-like connection to the named remote server
(otherwise functions as a non-networked messaging hub).
Port less than zero forces default.
  Currently, server_name is an extended URL that defaults
to VRPN connections at the port, but can be file:: to read
from a file.  Other extensions should maintain this, so
that VRPN uses URLs to name things that are to be connected
to.
</member>
        <member name="F:vrpn_Connection.d_serverLogCount">
Server logging w. multiconnection - TCH July 00
Use one "hidden" endpoint for outgoing logs (?),
standard per-endpoint logs with augmented names for incoming.
To make a hidden endpoint we create d_endpoints[0] and increment
the d_numEndpoints, but DON'T pass it d_numConnectedEndpoints
(although it should be safe to do so, since it should never truly
become connected, but we might have to "fake" it to get it to log
correctly).
</member>
        <member name="F:vrpn_Connection.d_dispatcher">
Derived classes need access to d_dispatcher in their
allocateEndpoint() routine.  Several compilers won't give it to
them, even if they do inherit publicly.  Until we figure that
out, d_dispatcher needs to be public.
</member>
        <member name="M:vrpn_Connection.setAutoDeleteStatus(System.Boolean)">
Specify whether this connection should be deleted automatically when
 it is no longer need (reference count reaches zero).
For connections created by the VRPN code (as is done in
 get_connection_by_name) these should be auto-deleted.
 Connections created by user code should not be auto-deleted;
 that is up to the user to decide when finished.
By default, the constructor sets this to FALSE.
VRPN code (or user code) can set this to TRUE if it wants the
 connection to be deleted automatically when the last service on it
 is deleted
</member>
        <member name="M:vrpn_Connection.addReference">
Counting references to this connection.
</member>
        <member name="F:vrpn_Connection.start_time">
Timekeeping - TCH 30 June 98
</member>
        <member name="M:vrpn_Connection.message_type_is_registered(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Returns message type ID, or -1 if unregistered
</member>
        <member name="M:vrpn_Connection.init">
@}
</member>
        <member name="F:vrpn_Connection.d_stop_processing_messages_after">
If this value is greater than zero, the connection should stop
looking for new messages on a given endpoint after this many
are found.
</member>
        <member name="M:vrpn_Connection.Jane_stop_this_crazy_thing(System.UInt32)">
This function should be seldom used.  It is here for the case of
the vrpn_Imager, whose servers do not follow "The VRPN Way" because
they try to jam more data into the network than there is bandwidth
to support it.  As a result, a client may call mainloop() on the
connection and have it never return -- there is always more data
in the network to read, so we never hand control back to the main
program.  The reason for the name comes from an old U.S. cartoon
called "The Jetsons".  In it, George Jetson is running on a
treadmill when it goes out of control and starts spinning so fast
that he can't even run fast enough to reach the controls and turn
it off.  He cries out to his wife, "Jane!  Stop this crazy thing!"
The parameter specifies a trigger: if more than the specified number
of messages come in on a given input channel during one mainloop()
call, the connection should stop looking for more messages.  NOTE:
this does not guarantee that only this many messages will be received,
only that the connection will stop looking for new ones on a given
channel once that many have been received (for example, UDP channels
will parse all the rest of the messages in a packet before stopping).
A value of 0 turns off the limit, and will cause all incoming messages
to be handled before returning.
</member>
        <member name="M:vrpn_Connection.get_File_Connection">
vrpn_File_Connection implements this as "return this" so it
can be used to detect a File_Connection and get the pointer for it
</member>
        <member name="M:vrpn_Connection.save_log_so_far">
Save any messages on any endpoints which have been logged so far.
</member>
        <member name="M:vrpn_Connection.register_log_filter(=FUNC:System.Int32(System.Void*,vrpn_HANDLERPARAM),System.Void*)">
@brief Sets up a filter function for logging.
Any user message to be logged is first passed to this function,
and will only be logged if the function returns zero (XXX).
NOTE:  this only affects local logging - remote logging
is unfiltered!  Only user messages are filtered;  all system
messages are logged.
Returns nonzero on failure.
</member>
        <member name="M:vrpn_Connection.sender_name(System.Int32)">
Returns the name of the specified sender/type, or NULL
if the parameter is invalid.  Only works for user
messages (type &gt;= 0).
</member>
        <member name="M:vrpn_Connection.get_time">
returns the current time in the connection (since the epoch -- UTC
time).
</member>
        <member name="M:vrpn_Connection.send_pending_reports">
send pending report, clear the buffer.
This function was protected, now is public, so we can use it
to send out intermediate results without calling mainloop
</member>
        <member name="M:vrpn_Connection.register_handler(System.Int32,=FUNC:System.Int32(System.Void*,vrpn_HANDLERPARAM),System.Void*,System.Int32)">
Set up (or remove) a handler for a message of a given type.
Optionally, specify which sender to handle messages from.
Handlers will be called during mainloop().
Your handler should return 0 or a communication error is assumed
and the connection will be shut down.
</member>
        <member name="M:vrpn_Connection.register_sender(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Get a token to use for the string name of the sender or type.
Remember to check for -1 meaning failure.
</member>
        <member name="M:vrpn_Connection.get_log_names(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**)">
This function returns the logfile names of this connection in
the parameters.  It will allocate memory for the name of each
log file in use.  If no logging of a particular type is happening,
then *(X_Y_logname) will be set to NULL.
IMPORTANT:  code calling this function is responsible for freeing
the memory allocated for these strings.
</member>
        <member name="M:vrpn_Connection.connected">
Returns vrpn_true if the connection has been established, vrpn_false if not
(For a networkless connection, this is equivalent to doing_okay()).
</member>
        <member name="M:vrpn_Connection.doing_okay">
Returns vrpn_true if the connection is okay, vrpn_false if not
</member>
        <member name="M:vrpn_Connection.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,=FUNC:vrpn_Endpoint_IP*(vrpn_Connection*,System.Int32*))">
Constructor for client connection.  This cannot be called
directly because vrpn_Connection is an abstract base class.
Call vrpn_get_connection_by_name() to create a client connection.
</member>
        <member name="M:vrpn_Connection.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,=FUNC:vrpn_Endpoint_IP*(vrpn_Connection*,System.Int32*))">
Constructor for server connection.  This cannot be called
directly any more because vrpn_Connection is an abstract base
class.  Call vrpn_create_server_connection() to make a server
of arbitrary type based on a name.
</member>
        <member name="F:vrpn_Endpoint_IP.d_tcpListenSocket">
This section deals with when a client connection is trying to
establish (or re-establish) a connection with its server. It
keeps track of what we need to know to make this happen.
</member>
        <member name="F:vrpn_Endpoint_IP.d_tcpSocket">
@todo XXX These should be protected; making them so will lead to making
   the code split the functions between Endpoint and Connection
   protected:
</member>
        <member name="M:vrpn_Endpoint_IP.send_pending_reports">
@brief send pending report, clear the buffer.

This function was protected, now is public, so we can use it
to send out intermediate results without calling mainloop
</member>
        <member name="M:vrpn_Endpoint_IP.init">
@}
@name Manipulators
@{
</member>
        <member name="M:vrpn_Endpoint_IP.outbound_udp_open">
True if the UDP outbound is open, False if not.
</member>
        <member name="M:vrpn_Endpoint_IP.doing_okay">
@name Accessors
@{
</member>
        <member name="T:vrpn_Endpoint_IP">
@brief Encapsulation of the data and methods for a single IP-based
connection
to take care of one part of many clients talking to a single server.

This will only be used from within the vrpn_Connection_IP class;  it should
not be instantiated by users or devices.
Should not be visible!
</member>
        <member name="M:vrpn_Endpoint.dispatch(System.Int32,System.Int32,timeval,System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*)">
@}
</member>
        <member name="M:vrpn_Endpoint.setConnection(vrpn_Connection*)">
@}
@name Routines to inform the endpoint of the connection of
which it is a part.
@{
</member>
        <member name="M:vrpn_Endpoint.handle_sender_message(System.Void*,vrpn_HANDLERPARAM)">
@}
@name Routines that handle system messages

Visible so that vrpn_Connection can pass them to the Dispatcher
@{
</member>
        <member name="F:vrpn_Endpoint.d_inLog">
@name Logging

TCH 19 April 00;  changed into two logs 16 Feb 01
@{
</member>
        <member name="F:vrpn_Endpoint.d_remoteLogMode">
@todo XXX These should be protected; making them so will lead to making
   the code split the functions between Endpoint and Connection
   protected:
</member>
        <member name="M:vrpn_Endpoint.send_pending_reports">
send pending report, clear the buffer.
This function was protected, now is public, so we can use it
to send out intermediate results without calling mainloop
</member>
        <member name="M:vrpn_Endpoint.newRemoteType(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Int32,System.Int32)">
Adds a new remote type/sender and returns its index.
Returns -1 on error.
@{
</member>
        <member name="M:vrpn_Endpoint.newLocalSender(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
A new local sender or type has been established; set
the local type for it if the other side has declared it.
Return 1 if the other side has one, 0 if not.
</member>
        <member name="M:vrpn_Endpoint.clear_other_senders_and_types">
Clear out the remote mapping list. This is done when a
connection is dropped and we want to try and re-establish
it.
</member>
        <member name="M:vrpn_Endpoint.init">
@}
@name Manipulators
@{
</member>
        <member name="M:vrpn_Endpoint.local_sender_id(System.Int32)">
Returns the local mapping for the remote sender (-1 if none).
</member>
        <member name="M:vrpn_Endpoint.local_type_id(System.Int32)">
@name Accessors
@{
Returns the local mapping for the remote type (-1 if none).
</member>
        <member name="T:vrpn_Endpoint">
@brief Encapsulation of the data and methods for a single generic connection
to take care of one part of many clients talking to a single server.

This will only be used from within the vrpn_Connection class;  it should
not be instantiated by users or devices.
Should not be visible!
</member>
        <member name="T:vrpn_Connection">
@}

@brief Generic connection class not specific to the transport mechanism.

It abstracts all of the common functions.  Specific implementations
for IP, MPI, and other transport mechanisms follow.
</member>
        <member name="T:vrpnMsgCallbackEntry">
@todo HACK
These structs must be declared outside of vrpn_Connection
(although we'd like to make them protected/private members)
because aCC on PixelFlow doesn't handle nested classes correctly.
@{
@brief Description of a callback entry for a user type.
</member>
        <member name="T:vrpn_LOGLIST">
Placed here so vrpn_FileConnection can use it too.
</member>
        <member name="D:cName">
@brief Length of names within VRPN
</member>
        <member name="F:vrpn_CONTROL">
@}
@brief vrpn_CONTROL is the sender used for notification messages sent to the
user
from the local VRPN implementation (got_first_connection, etc.)
and for control messages sent by auxiliary services.  (Such as
class vrpn_Controller, which will be introduced in a future revision.)
</member>
        <member name="F:vrpn_got_first_connection">
@}
These are the strings that define the system-generated message
types that tell when connections are received and dropped.
@{
</member>
        <member name="D:vrpn_LOGFILTER">
@brief  Type of handler for filters on logfiles is the same as connection
handler
</member>
        <member name="D:vrpn_MESSAGEHANDLER">
@brief Type of a message handler for vrpn_Connection messages.
</member>
        <member name="T:vrpn_HANDLERPARAM">
@brief This structure is what is passed to a vrpn_Connection message
callback.

It is used by objects, but not normally by user code.
</member>
        <member name="T:vrpn_ConnectionStatus">
This is the list of states that a connection can be in
(possible values for status).  doing_okay() returns VRPN_TRUE
for connections &gt; BROKEN.
</member>
        <member name="M:_wassert(System.Char!System.Runtime.CompilerServices.IsConst*,System.Char!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
Fall back to normal asserts.
</member>
        <member name="M:vrpn_byte_order.ntoh(System.Double)">
network to host byte order for 64-bit floats, using vrpn_ntohd
</member>
        <member name="M:vrpn_byte_order.hton(System.Double)">
host to network byte order for 64-bit floats, using vrpn_htond
</member>
        <member name="M:vrpn_byte_order.ntoh(System.UInt32)">
network to host byte order for 32-bit uints
</member>
        <member name="M:vrpn_byte_order.hton(System.UInt32)">
host to network byte order for 32-bit uints
</member>
        <member name="M:vrpn_byte_order.ntoh(System.UInt16)">
network to host byte order for 16-bit uints
</member>
        <member name="M:vrpn_byte_order.hton(System.UInt16)">
host to network byte order for 16-bit uints
</member>
        <member name="M:vrpn_byte_order.ntoh(System.Byte)">
network to host byte order for 8-bit uints is a no-op
</member>
        <member name="M:vrpn_byte_order.hton(System.Byte)">
host to network byte order for 8-bit uints is a no-op
</member>
        <member name="T:timeval">
@brief Return number of microseconds between startT and endT.

@brief Return the number of seconds between startT and endT as a
floating-point value.

@}
Pack a message that will be sent the next time mainloop() is called.
Turn off the RELIABLE flag if you want low-latency (UDP) send.

@brief Pack a message that will be sent the next time mainloop() is
called.

Turn off the RELIABLE flag if you want low-latency (UDP) send.

Call each time through program main loop to handle receiving any
incoming messages and sending any packed messages.
Returns -1 when connection dropped due to error, 0 otherwise.
(only returns -1 once per connection drop).
Optional argument is TOTAL time to block on select() calls;
there may be multiple calls to select() per call to mainloop(),
and this timeout will be divided evenly between them.

Pack a message that will be sent the next time mainloop() is called.
Turn off the RELIABLE flag if you want low-latency (UDP) send.

Returns the time since the connection opened.
Some subclasses may redefine time.

Call each time through program main loop to handle receiving any
incoming messages and sending any packed messages.
Returns -1 when connection dropped due to error, 0 otherwise.
(only returns -1 once per connection drop).
Optional argument is TOTAL time to block on select() calls;
there may be multiple calls to select() per call to mainloop(),
and this timeout will be divided evenly between them.

Call each time through program main loop to handle receiving any
incoming messages and sending any packed messages.
Returns -1 on error, 0 otherwise.
Optional argument is TOTAL time to block on select() calls;
there may be multiple calls to select() per call to mainloop(),
and this timeout will be divided evenly between them.

Sends a NULL-terminated text message from the device d_sender_id

called?

unanswered group sent?

These functions should be called to report changes in state, once per
sensor.
</member>
        <member name="D:vrpn_int8">
@file vrpn_BaseClass.h

  All types of client/server/peer objects in VRPN should be derived from the
  vrpn_BaseClass type described here.  This includes Tracker, Button, Analog,
  Clock, Dial, ForceDevice, Sound, and Text; it should include any user-defined
  objects as well.

  This class both implements code that will be shared by most (if not all)
  objects in the system and forms a skeleton for the definition of new objects
  by requiring certain virtual member functions to be defined.

  See the VRPN web pages or another simple type (such as vrpn_Analog) for an
  example of how to create a new VRPN object type using this as a base class.

</member>
        <member name="M:RigidBodySolver.cRigidBody.SetSupplementaryInfo(RigidBodySolver.cRigidBodySolverSupplementaryInfo*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Optional additional system information to improve ray based solving
and determination of proper tracking algorithm based on system config and load.</summary>
        </member>
        <member name="M:RigidBodySolver.cRigidBody.ActiveTagRfChannel">
            <summary>Get the Active Tag RF channel for this rigid body.</summary>
        </member>
        <member name="M:RigidBodySolver.cRigidBody.SetActiveTagRfChannel(System.Int32)">
            <summary>Set the Active Tag RF channel for this rigid body.</summary>
        </member>
        <member name="M:RigidBodySolver.cRigidBody.ActiveTagID">
            <summary>Get the Active Tag ID for this rigid body.</summary>
        </member>
        <member name="M:RigidBodySolver.cRigidBody.SetActiveTagID(System.Int32)">
            <summary>Set the Active Tag ID for this rigid body.</summary>
        </member>
        <member name="M:RigidBodySolver.cRigidBody.SetMarkerActiveID(System.Int32,System.UInt32)">
            <summary>Set the active marker ID (which is part of the ID, not the label).</summary>
        </member>
        <member name="M:RigidBodySolver.cRigidBody.SetMarkerMemberID(System.Int32,System.UInt32)">
            <summary>Set the marker member ID, which must be unique among the member ID's assigned to markers
for this rigid body. The member ID is used in combination with the rigid body ID to construct the
label for each marker.</summary>
        </member>
        <member name="M:RigidBodySolver.cRigidBody.GetMarkerFullName(System.Int32,System.Char*,System.Int32)">
            <summary>Retrieve the fully qualified marker name, including the name of the rigid body that owns it.</summary>
        </member>
        <member name="M:RigidBodySolver.cRigidBodySolver.SetSupplementaryInfo(RigidBodySolver.cRigidBodySolverSupplementaryInfo*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Optional additional system information to improve ray based solving
and determination of proper tracking algorithm based on system config and load.</summary>
        </member>
        <member name="M:RigidBodySolver.cRigidBodySolver.FrameDiscontinuity">
            <summary>When pushing a frame that is not incrementally continuous with previous
frames, call FrameDiscontinuity to allow the solver to continue to solve even
if marker trajectories are broken.</summary>
        </member>
        <member name="M:RigidBodySolver.cRigidBodySolver.AssessRigidBodyConstellation(std.vector&lt;Core.cTMarker&lt;System.Single&gt;,std.allocator&lt;Core.cTMarker&lt;System.Single&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Assess a list of markers as a possible candidate for a rigid body.  This
will determine if it's a 'good' or 'bad' rigid body based on the marker arrangement</summary>
        </member>
        <member name="M:RigidBodySolver.cRigidBodySolver.FindRigidBodyIndex(RigidBodySolver.cRigidBody!System.Runtime.CompilerServices.IsConst*)">
            <summary>Find the index of the given rigid body in the rigid body list.</summary>
            <returns>The index if found, or -1 otherwise.</returns>
        </member>
        <member name="M:Core.cThreadedDispatch.ThreadProc(Core.cThreadHandle*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>ThreadProc method contains the default worker thread implementation for
   performing tasks in parallel.  Needs to be public for thread entry point to call in.</summary>
        </member>
        <member name="M:Core.cThreadedDispatch.IsAllThreadsIdle">
            <summary>Query IsAllThreadsIdle() to determine if all tasks are complete without blocking.</summary>
        </member>
        <member name="M:Core.cThreadedDispatch.WaitForThreadedCompletion">
            <summary>Call WaitForThreadedCompletion() to block until all dispatched tasks are complete.</summary>
        </member>
        <member name="M:Core.cThreadedDispatch.MaximumThreadCount">
            <summary>Parallelism defaults to the number of cores on the processor. Override
  this to limit the number of task running in parallel.</summary>
        </member>
        <member name="M:Core.cThreadedDispatch.PerformThreadedTask(Core.cIThreadingTask*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Override PerformThreadedTask to receive tasks to perform. This
   method will be called in parallel from a number of worker threads.</summary>
        </member>
        <member name="M:Core.cThreadedDispatch.DispatchNoThreading(Core.cIThreadingTask*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Dispatch a task without threading. This is typically to facilitate debugging of threaded algorithms.</summary>
        </member>
        <member name="M:Core.cThreadedDispatch.Dispatch(Core.cIThreadingTask*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Dispatch a task to be scheduled and performed by one of the worker threads.</summary>
        </member>
        <member name="T:Core.cThreadedDispatch">
            <summary>Inherit cThreadedDispatch to add threaded dispatching to your class.</summary>
        </member>
        <member name="T:Core.cIThreadingTask">
            <summary>Override cThreadedTask to store pertinent information regarding
   the threaded task to be performed.</summary>
        </member>
        <member name="M:Core.cThreadProc.ThreadProc(Core.cThreadHandle*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
  Inherit this class and override this function to provide a entry point for a new thread.
</summary>
        </member>
        <member name="M:Core.cThreadHandle.SetPriority(Core.cThreadHandle.eThreadPriority)">
            <summary>Set the thread priority. May be called at any time.</summary>
        </member>
        <member name="T:Core.cThreadHandle">
            <summary>
A platform-neutral thread handler.
</summary>
        </member>
        <member name="M:Core.cEvent.Wait(System.Int32)">
            <summary> Wait for an event to trigger. Specify timeout in milliseconds.  If zero is specified,
  a wait state will not be entered and will immediately return a boolean specifing if event has triggered. 
</summary>
        </member>
        <member name="M:Core.cEvent.Wait">
            <summary> Wait, potentially indefinitely, for an event to trigger. </summary>
        </member>
        <member name="M:Core.cEvent.Trigger">
            <summary> Trigger the event. </summary>
        </member>
        <member name="T:Core.cEvent">
            <summary>
  A cross-platform event object.  This can be used to signal one thread from another that an
  event has occurred.
</summary>
        </member>
        <member name="M:MoCapCore.cLabelGroup.GenerateNewID">
            <summary>Generates a new ID for this object. This should only be called by the framework, and is
typically used to resolve ID conflicts.</summary>
        </member>
        <member name="M:MoCapCore.cLabelGroup.MakeValidName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Find a unique label name based on the given name.</summary>
        </member>
        <member name="M:MoCapCore.cLabelGroup.RemoveLabel(System.UInt32)">
            <summary>Attempt to remove a label by ID/index.</summary>
        </member>
        <member name="M:MoCapCore.cLabelGroup.AddLabel(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32!System.Runtime.CompilerServices.IsConst)">
            <summary>Attempt to add a new label to the group. This method will alter the name to
make it unique. It will return the final name.</summary>
        </member>
        <member name="T:MoCapCore.cLabelGroup">
            <summary>A group of user-defined marker labels.</summary>
        </member>
        <member name="M:MotiveCore.cSkeletonNode.GenerateNewID">
            <summary>Generates a new ID for this object. This should only be called by the framework, and is
typically used to resolve ID conflicts.</summary>
        </member>
        <member name="M:MotiveCore.cSkeletonNode.AttachedJoints(std.vector&lt;MoCapCore.cJointNode**,std.allocator&lt;MoCapCore.cJointNode**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Gather the list of joints that are descendants of this skeleton. Joints are returned ordered
from the root outward in a depth-first traversal.</summary>
        </member>
        <member name="M:MotiveCore.cSkeletonNode.RemoveConstraint(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Removes the constraint with the given name. Returns false if name was not found.</summary>
        </member>
        <member name="M:MotiveCore.cSkeletonNode.AddConstraint(MoCapCore.cConstraint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Add a constraint.</summary>
        </member>
        <member name="M:MotiveCore.cSkeletonNode.AllConstraints(std.vector&lt;MoCapCore.cConstraint,std.allocator&lt;MoCapCore.cConstraint&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Retrieve all constraints currently associated with this skeleton.</summary>
        </member>
        <member name="M:MotiveCore.cSkeletonNode.GetConstraintPosition(System.UInt32)">
            <summary>Get the skeleton marker's current global position.</summary>
        </member>
        <member name="M:MotiveCore.cSkeletonNode.SelectedConstraintCount">
            <summary>Query for the number of selected constraints (markers).</summary>
        </member>
        <member name="M:MotiveCore.cSkeletonNode.IsConstraintSelected(System.UInt32)">
            <summary>Query for the selection state of a member marker.</summary>
        </member>
        <member name="M:MotiveCore.cSkeletonNode.SelectAllConstraints(System.Boolean)">
            <summary>Set the selection state of all member markers. Also sets the selection state of the skeleton itself.</summary>
        </member>
        <member name="M:MotiveCore.cSkeletonNode.SelectConstraint(System.UInt32,System.Boolean)">
            <summary>Set the selection state of a member marker. Also sets the selection state of the skeleton itself.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.LabelFromLabelName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Look up a label given a label name.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.ResetLabelOrder">
            <summary>Reset any custom label ordering back to default ordering. To be removed.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.SetLabelOrder(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Boolean)">
            <summary>Set the named label to be at the given index in label ordering.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.ResetLabelColors">
            <summary>Reset all label colors to the default color.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.LabelColor(System.UInt32)">
            <summary>Retrieve the color of a label given the member ID.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.LabelColors(std.vector&lt;Core.cVector3&lt;System.Single&gt;,std.allocator&lt;Core.cVector3&lt;System.Single&gt;&gt;&gt;*)">
            <summary>Retrieve the list of label colors associated with this source, by current label order.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.SetLabelColor(System.UInt32,Core.cVector3&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Override the default label color with the given one.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.ClearLabelSticks">
            <summary>Clear all label sticks.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.LabelSticks(std.vector&lt;Core.cMarkerStickT&lt;System.Single&gt;,std.allocator&lt;Core.cMarkerStickT&lt;System.Single&gt;&gt;&gt;*)">
            <summary>Retrieve the list of label sticks associated with this source.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.SetLabelStick(Core.cMarkerStickT&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Create or replace a label stick.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.IsLabelName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if the given name matches a name in the label list.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.OriginalLabelNames(std.vector&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;,std.allocator&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;&gt;&gt;*)">
            <returns>A vector of all original label names, by current label order. This method should be
removed at some point when label source templates are fully implemented.</returns>
        </member>
        <member name="M:MoCapCore.cILabelSource.LabelNames(std.vector&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;,std.allocator&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;&gt;&gt;*)">
            <returns>A vector of all label names, by current label order.</returns>
        </member>
        <member name="M:MoCapCore.cILabelSource.LabelName(System.UInt32)">
            <summary>Retrieve the label with the given member ID.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.SetLabelName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Assign a new name to replace the existing name of a label.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.LabelIDs(std.vector&lt;System.UInt32,std.allocator&lt;System.UInt32&gt;&gt;*,System.Boolean!System.Runtime.CompilerServices.IsConst)">
            <summary>Retrieve a vector of label member ID's, in current label order.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.LabelCount">
            <summary>Number of labels provided by this label source.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.EntityName">
            <summary>The unique name of this label source among any active label sources.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSource.EntityID">
            <summary>The unique ID of this label source.</summary>
        </member>
        <member name="T:MoCapCore.cILabelSource">
            <summary>Interface class for any element that provides marker labels.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSourceObserver.OnLabelColorChanged(MoCapCore.cILabelSource!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called whenever a label's color changes.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSourceObserver.OnLabelChanged(MoCapCore.cILabelSource!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called whenever the available labels list changes.</summary>
        </member>
        <member name="M:MoCapCore.cILabelSourceObserver.OnLabelListChanged(MoCapCore.cILabelSource!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called whenever the available labels list changes.</summary>
        </member>
        <member name="M:MoCapCore.cConstraint.DisplayColor">
            <summary>Display color for the constraint.</summary>
        </member>
        <member name="M:MoCapCore.cConstraint.SetDisplayColor(Core.cVector3&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the display color.</summary>
        </member>
        <member name="M:MoCapCore.cConstraint.PositionOffset">
            <summary>The target positional offset of the constraint from the constrained entity.</summary>
        </member>
        <member name="M:MoCapCore.cConstraint.SetPositionOffset(Core.cVector3&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the position offset.</summary>
        </member>
        <member name="M:MoCapCore.cConstraint.Weight">
            <summary>Relative weight of this constraint.</summary>
        </member>
        <member name="M:MoCapCore.cConstraint.SetWeight(System.Single)">
            <summary>Sets the constraint weight.</summary>
        </member>
        <member name="M:MoCapCore.cConstraint.Selected">
            <summary>Retrieve the selection state for this constraint.</summary>
        </member>
        <member name="M:MoCapCore.cConstraint.SetSelected(System.Boolean)">
            <summary>Set the selection state for this constraint.</summary>
        </member>
        <member name="M:MoCapCore.cConstraint.SetActiveMarkerID(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the active marker ID.</summary>
        </member>
        <member name="M:MoCapCore.cConstraint.ActiveMarkerID">
            <summary>The ID of the active marker.</summary>
        </member>
        <member name="M:MoCapCore.cConstraint.AttachmentID">
            <summary>The ID of the node this constraint is attached to.</summary>
        </member>
        <member name="M:MoCapCore.cConstraint.Name">
            <summary>Constraint name.</summary>
        </member>
        <member name="M:MoCapCore.cConstraint.SetName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Sets a new name for the constraint.</summary>
        </member>
        <member name="M:MoCapCore.cJointNode.SetChannel(std.unique_ptr&lt;MoCapCore.cIChannel,std.default_delete&lt;MoCapCore.cIChannel&gt;&gt;)">
cIChannelProvider
</member>
        <member name="M:MoCapCore.cJointNode.Label">
            <summary>Retrieve the label for this joint, if any.</summary>
        </member>
        <member name="M:MoCapCore.cJointNode.SetLabel(Core.cLabel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the label to use for this joint.</summary>
        </member>
        <member name="M:MoCapCore.cJointNode.JointType">
            <summary>Retrieve a type of joint.</summary>
        </member>
        <member name="M:MoCapCore.cJointNode.DegreesOfFreedom">
            <summary>Retrieve a bitfield of the current DOF's.</summary>
        </member>
        <member name="T:MoCapCore.cTransformNode">
            <summary>Concrete implementation of a class that supports translation/rotation transform hierarchies.</summary>
        </member>
        <member name="M:NMotive.MotiveProgressIndicator.Finish">
            <summary>Call this to finish a measured task.</summary>
        </member>
        <member name="M:NMotive.MotiveProgressIndicator.StackDepth">
            <summary>Retrieve the current progress stack depth.</summary>
        </member>
        <member name="M:NMotive.MotiveProgressIndicator.Message">
            <summary>Gets the current message.</summary>
        </member>
        <member name="M:NMotive.MotiveProgressIndicator.Progress">
            <summary>Gets the current progress value.</summary>
        </member>
        <member name="M:NMotive.MotiveProgressIndicator.IsCanceled">
            <summary>If the user or app has requested that an operation be canceled before completing, it
will set this property through the SetCanceled() method. Operations should regularly check this
state to see if the user has requested a cancel.</summary>
        </member>
        <member name="M:NMotive.MotiveProgressIndicator.SetCanceled">
            <summary>Set the canceled state. UI's use this method to allow the user or the app to cancel
a long-running operation. Operations should regularly check the IsCanceled() state to see if
the user has requested a cancel.</summary>
        </member>
        <member name="M:NMotive.MotiveProgressIndicator.SetMessage(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the message to display to the user.</summary>
        </member>
        <member name="M:NMotive.MotiveProgressIndicator.SetProgress(System.UInt32)">
            <summary>Called to update progress value directly. Progress is in the range [0,100].</summary>
        </member>
        <member name="M:NMotive.MotiveProgressIndicator.IncrementProgress">
            <summary>Called to increase the progress by one increment.</summary>
        </member>
        <member name="M:NMotive.MotiveProgressIndicator.Start(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>This is called to run the operation using the given progress indicator.</summary>
            <param name="message">A user-facing message to display during the task.</param>
            <param name="incrementCount">The number of progress increments that the task will take to complete.</param>
        </member>
        <member name="M:MoCapCore.cIProgressIndicator.Finish">
            <summary>Call this to finish a measured task.</summary>
        </member>
        <member name="M:MoCapCore.cIProgressIndicator.StackDepth">
            <summary>Retrieve the current progress stack depth.</summary>
        </member>
        <member name="M:MoCapCore.cIProgressIndicator.Message">
            <summary>Gets the current message.</summary>
        </member>
        <member name="M:MoCapCore.cIProgressIndicator.Progress">
            <summary>Gets the current progress value, in the range [0,100].</summary>
        </member>
        <member name="M:MoCapCore.cIProgressIndicator.IsCanceled">
            <summary>If the user or app has requested that an operation be canceled before completing, it
will set this property through the SetCanceled() method. Operations should regularly check this
state to see if the user has requested a cancel.</summary>
        </member>
        <member name="M:MoCapCore.cIProgressIndicator.SetCanceled">
            <summary>Set the canceled state. UI's use this method to allow the user or the app to cancel
a long-running operation. Operations should regularly check the IsCanceled() state to see if
the user has requested a cancel.</summary>
        </member>
        <member name="M:MoCapCore.cIProgressIndicator.SetMessage(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the message to display to the user.</summary>
        </member>
        <member name="M:MoCapCore.cIProgressIndicator.SetProgress(System.Single)">
            <summary>Called to update progress value directly. Progress is in the range [0,100].</summary>
        </member>
        <member name="M:MoCapCore.cIProgressIndicator.IncrementProgress">
            <summary>Called to increase the progress by one increment.</summary>
        </member>
        <member name="M:MoCapCore.cIProgressIndicator.Start(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>This is called to run the operation using the given progress indicator.</summary>
            <param name="message">A user-facing message to display during the task.</param>
            <param name="incrementCount">The number of progress increments that the task will take to complete.</param>
        </member>
        <member name="T:MoCapCore.cIProgressIndicator">
            <summary>
Used to report progress of long-running operations. This object can (and should) be used to
recurse into call trees of long-running operations where it makes sense to track progress of
portions of an operation. Start() may be called multiple times before calling Finish(), but
all calls to Start() must be matched with a call to Finish().
There are two ways to report progress. Either call Start() with a non-zero incrementCount to
set the number of times that IncrementProgress() will be called before the task is finished, or
just call SetProgress() to set the progress value directly during task execution. To help make
progress indication more predictable, it is recommended that you use an increment count
whenever possible.
</summary>
        </member>
        <member name="M:MoCapCore.IProgressIndicatorObserver.OnMessageChanged(MoCapCore.cIProgressIndicator!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Callback that gets called when the user-facing message changes.</summary>
        </member>
        <member name="M:MoCapCore.IProgressIndicatorObserver.OnProgressChanged(MoCapCore.cIProgressIndicator!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Callback that gets called when the progress value changes.</summary>
        </member>
        <member name="M:NMotive.Trajectorizer.Process(NMotive.Take,NMotive.FrameRangeSet)">
            <summary>
Trajectorizes a set of frame ranges in a take.
</summary>
            <param name="take">Take to trajectorize.</param>
            <param name="frameRanges">A set of frame ranges to trajectorize.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="M:NMotive.Trajectorizer.Process(NMotive.Take)">
            <summary>
Trajectorizes the given take.
</summary>
            <param name="take">Take to trajectorize.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="M:NMotive.Trajectorizer.Process(NMotive.Take,NMotive.FrameRangeSet,NMotive.TrajectorizerOption)">
            <summary>
Trajectorizes the given take according to the given processing option.
</summary>
            <param name="take">Take to trajectorize.</param>
            <param name="frameRanges">A set of frame ranges to trajectorize.</param>
            <param name="processingOption">Reconstruct, auto label, or both.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="M:NMotive.Trajectorizer.Process(NMotive.Take,NMotive.TrajectorizerOption)">
            <summary>
Trajectorizes the given take according to the given processing option.
</summary>
            <param name="take">Take to trajectorize.</param>
            <param name="processingOption">Reconstruct, auto label, or both.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="M:NMotive.Trajectorizer.#ctor(NMotive.ProgressIndicator)">
            <summary>
Constructs a <c>Trajectorizer</c> instance that uses the given 
progress indicator to report progress.
</summary>
            <param name="progress">This progress indicator will be used to report
trajectorization progress.</param>
        </member>
        <member name="M:NMotive.Trajectorizer.#ctor">
            <summary>
Constructs a <c>Trajectorizer</c> instance.
</summary>
        </member>
        <member name="M:NMotive.Trajectorizer.#cctor">
            <exclude />
        </member>
        <member name="T:NMotive.Trajectorizer">
            <summary>
Class for performing trajectorization of the 2D data in a take to
produce 3D data.
</summary>
        </member>
        <member name="T:NMotive.TrajectorizerOption">
            <summary>
Enumeration of trajectorizer take processing.
</summary>
        </member>
        <member name="F:NMotive.TrajectorizerOption.SolveAssets">
            <summary>Solves all active assets.</summary>
        </member>
        <member name="F:NMotive.TrajectorizerOption.ReconstructAndAutoLabel">
            <summary>Reconstruct and auto-label.</summary>
        </member>
        <member name="F:NMotive.TrajectorizerOption.AutoLabel">
            <summary>Auto-label only.</summary>
        </member>
        <member name="F:NMotive.TrajectorizerOption.Reconstruct">
            <summary>Reconstruct only. Do not label.</summary>
        </member>
        <member name="M:NMotive.TakeProcessor.DefaultFramesRangeSet(NMotive.Take)">
            <summary>
The default range set for a take if none is specified.
</summary>
            <param name="take">The take.</param>
            <returns>The default frame range set for the take.</returns>
        </member>
        <member name="M:NMotive.TakeProcessor.SelectMarkersToProcess(NMotive.Take,System.Collections.Generic.IList`1{NMotive.UID},System.Int32)">
            <summary>
Selects in the take the markers with the specified ID's.
</summary>
            <param name="take">Select the markers in this take.</param>
            <param name="markerIDs">ID's of the markers to select.</param>
            <param name="indexOfPrimarySelection">The index into the <code>markerIDs</code> list of
the primary selection.</param>
        </member>
        <member name="M:NMotive.TakeProcessor.Process(NMotive.Take)">
            <summary>
Processes the given take. 
</summary>
            <param name="take">The take to process.</param>
            <returns>A result object indicating success or failure.</returns>
        </member>
        <member name="P:NMotive.TakeProcessor.Progress">
            <summary>
Gets and sets the progress indicator for this processor.
</summary>
        </member>
        <member name="P:NMotive.TakeProcessor.Name">
            <summary>
Gets the name for this processor.
</summary>
        </member>
        <member name="M:NMotive.TakeProcessor.#ctor(NMotive.ProgressIndicator)">
            <summary>
Constructs a <c>TakeProcessor</c> object with the given progress
indicator.
</summary>
            <param name="progress">Progress indicator used by this processor.</param>
        </member>
        <member name="M:NMotive.TakeProcessor.#ctor">
            <summary>
Constructs a <c>TakeProcessor</c> object.
</summary>
        </member>
        <member name="T:NMotive.TakeProcessor">
            <summary>
Abstract base class for take processing classes.
</summary>
        </member>
        <member name="P:NMotive.Result.Message">
            <summary>
Gets the message.
</summary>
        </member>
        <member name="P:NMotive.Result.Success">
            <summary>
Gets the success state.
</summary>
        </member>
        <member name="M:NMotive.Result.#ctor(System.Boolean,System.String)">
            <summary>
Constructs a <c>Result</c> object with the given success state 
and message.
</summary>
            <param name="success">The success state.</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:NMotive.Result.#ctor">
            <summary>
Constructs a <c>Result</c> object with success set to <c>false</c>
empty message property.
</summary>
        </member>
        <member name="T:NMotive.Result">
            <summary>
Class representing the result of an operation. It indicates success or
failure and an information message (most useful when the result is
failure).
</summary>
        </member>
        <member name="P:NMotive.ProgressIndicator.IsCanceled">
            <summary>
Gets and sets the cancelled property. This property will be 
checked by the consumer code periodically to see if the operation
had been canceled.
</summary>
        </member>
        <member name="M:NMotive.ProgressIndicator.Finish">
            <summary>Call this to finish a measured task.</summary>
        </member>
        <member name="P:NMotive.ProgressIndicator.Message">
            <summary>Gets the current message.</summary>
        </member>
        <member name="P:NMotive.ProgressIndicator.Progress">
            <summary>Gets the current progress value.</summary>
        </member>
        <member name="M:NMotive.ProgressIndicator.SetMessage(System.String)">
            <summary>Set the message to display to the user.</summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:NMotive.ProgressIndicator.SetProgress(System.Single)">
            <summary>
Set the progress as a float value between 0 and 1.
</summary>
            <param name="progress">A float value in the range [0.0, 1.0] with 1.0 meaning
complete.</param>
        </member>
        <member name="M:NMotive.ProgressIndicator.SetProgress(System.UInt32)">
            <summary>
Called to update progress value directly. Progress is in the range [0,100].
</summary>
            <param name="percent">Progress as a percentage in the range [1,100]</param>
        </member>
        <member name="M:NMotive.ProgressIndicator.IncrementProgress">
            <summary>Called to increase the progress by one increment.</summary>
        </member>
        <member name="M:NMotive.ProgressIndicator.Start(System.String,System.UInt32)">
            <summary>This is called to run the operation using the given progress indicator.</summary>
            <param name="message">A user-facing message to display during the task.</param>
            <param name="incrementCount">The number of progress increments that the task will take to complete.</param>
        </member>
        <member name="F:NMotive.ProgressIndicator.mIsCancelled">
            <exclude />
        </member>
        <member name="F:NMotive.ProgressIndicator.mMessage">
            <exclude />
        </member>
        <member name="F:NMotive.ProgressIndicator.mProgressCount">
            <exclude />
        </member>
        <member name="F:NMotive.ProgressIndicator.mIncrementCount">
            <exclude />
        </member>
        <member name="F:NMotive.ProgressIndicator.mProgressPercent">
            <exclude />
        </member>
        <member name="T:NMotive.ProgressIndicator">
            <summary>
Class for indicating progress and messages pertaining to an operation.
</summary>
        </member>
        <member name="M:NMotive.Take.Finalize">
            <exclude />
        </member>
        <member name="M:NMotive.Take.Dispose">
            <exclude />
        </member>
        <member name="M:NMotive.Take.Save(System.String)">
            <summary>
Saves the take to the given file.
</summary>
            <param name="fileName">File to save to.</param>
            <returns>The result of the save attempt.</returns>
        </member>
        <member name="M:NMotive.Take.Save">
            <summary>
Saves any changes made to the take to its associated file.
</summary>
            <returns>The result of the save attempt.</returns>
        </member>
        <member name="M:NMotive.Take.UpdateDataTypes">
            <summary>
Update the data type meta-data on a take..
</summary>
        </member>
        <member name="M:NMotive.Take.HasData(NMotive.Take.DataType)">
            <summary>
Returns <c>true</c> if this take contains the given
data type.
</summary>
            <param name="dataType">The type of data.</param>
            <returns>
                <c>true</c> if this take contains the given data type.</returns>
        </member>
        <member name="M:NMotive.Take.HasGaps">
            <summary>
Checks if the take has gaps.
</summary>
            <returns>
                <c>true</c> if the take has gaps.</returns>
        </member>
        <member name="M:NMotive.Take.Solve">
            <summary>
Computes tracking data.
</summary>
            <returns>true if the operation is successful.</returns>
        </member>
        <member name="M:NMotive.Take.Solve(NMotive.FrameRangeSet)">
            <summary>
Computes tracking data from the specified frame ranges.
</summary>
            <param name="frameRanges">Solved data is computed for these frame
ranges.</param>
            <returns>true if the operation is successful.</returns>
        </member>
        <member name="M:NMotive.Take.RemoveSolve">
            <summary>
Removes all solved data from the take.
</summary>
        </member>
        <member name="M:NMotive.Take.RemoveSolve(NMotive.FrameRangeSet)">
            <summary>
Removes solved data in the specified frame ranges from the
take.
</summary>
            <param name="frameRanges">Solved data removed from these frame
ranges.</param>
        </member>
        <member name="P:NMotive.Take.EndTimecode">
            <summary>
Gets the ending timecode for this take.
</summary>
        </member>
        <member name="P:NMotive.Take.RecordingStartTime">
            <summary>
Gets the recording start time in Coordinated Universal Time (UTC).
</summary>
        </member>
        <member name="P:NMotive.Take.StartTimecode">
            <summary>
Gets the starting timecode for this take.
</summary>
        </member>
        <member name="P:NMotive.Take.Best">
            <summary>
Gets and sets the "Best" property for a take.
</summary>
        </member>
        <member name="P:NMotive.Take.Scene">
            <summary>
Access to the contained NodeWarehouse
</summary>
        </member>
        <member name="P:NMotive.Take.FileName">
            <summary>
Gets the name of the file associated with the take.
</summary>
        </member>
        <member name="P:NMotive.Take.FullFrameRange">
            <summary>
Gets the full frame range for the take as a frame range.
</summary>
        </member>
        <member name="P:NMotive.Take.FullTimeRange">
            <summary>
Gets the full time range for the take as a tuple where the first member 
is the start time and the second member is the end time.
</summary>
        </member>
        <member name="P:NMotive.Take.FrameTime">
            <summary>
Gets the master frame time (in seconds per frame).
</summary>
        </member>
        <member name="P:NMotive.Take.Notes">
            <summary>
Gets and sets the notes field for this take.
</summary>
        </member>
        <member name="P:NMotive.Take.Name">
            <summary>
Gets and sets the name for this take.
</summary>
        </member>
        <member name="P:NMotive.Take.FrameRate">
            <summary>
Gets the frame rate for this take.
</summary>
        </member>
        <member name="P:NMotive.Take.SessionID">
            <summary>
Gets the session ID for this take.
</summary>
        </member>
        <member name="P:NMotive.Take.ID">
            <summary>
Gets the unique ID for this take.
</summary>
        </member>
        <member name="P:NMotive.Take.BuildNumber">
            <summary>
Gets the Motive software build number which the take was recorded
with.
</summary>
        </member>
        <member name="P:NMotive.Take.SoftwareVersionString">
            <summary>
Gets a string representation Motive software version number which the take
 was recorded with.
</summary>
        </member>
        <member name="P:NMotive.Take.SoftwareVersion">
            <summary>
Gets the Motive software version number which the take was recorded
with. The value is hexadecimal that can be used for comparisons.
</summary>
        </member>
        <member name="M:NMotive.Take.#ctor(System.String)">
            <summary>
Constructs a take from the data in the given take file.
</summary>
            <param name="takeFilename">A take file.</param>
        </member>
        <member name="M:NMotive.Take.#ctor">
            <summary>
Constructs an empty take.
</summary>
        </member>
        <member name="F:NMotive.Take.DataType.AllTypes">
            <summary>Has all of the types of data.</summary>
        </member>
        <member name="F:NMotive.Take.DataType.Audio">
            <summary>Audio data.</summary>
        </member>
        <member name="F:NMotive.Take.DataType.Video">
            <summary>Video data.</summary>
        </member>
        <member name="F:NMotive.Take.DataType.Joints">
            <summary>Joint angle data.</summary>
        </member>
        <member name="F:NMotive.Take.DataType.e3D">
            <summary>3D data.</summary>
        </member>
        <member name="F:NMotive.Take.DataType.e2D">
            <summary>2D data.</summary>
        </member>
        <member name="F:NMotive.Take.DataType.None">
            <summary>No data.</summary>
        </member>
        <member name="T:NMotive.Take.DataType">
            <summary>
Types of data that a take may contain.
</summary>
        </member>
        <member name="T:NMotive.Take">
            <summary>
Owns all animation data for a take, as well as setup info for cameras (calibration, etc.).
</summary>
        </member>
        <member name="M:NMotive.Timecode.SetValue(System.UInt32,System.Int32)">
            <summary>
Set timecode values from the Motive integer format for timecode and 
subframe number.
</summary>
            <param name="timecode">Motive integer timecode format.</param>
            <param name="subframe">Subframe number.</param>
            <returns>
                <c>true</c> if the conversion was successful.</returns>
        </member>
        <member name="M:NMotive.Timecode.SetValue(System.UInt32)">
            <summary>
Set timecode values from the Motive integer format for timecode.
Subframe number is set to 0.
</summary>
            <param name="timecode">Motive integer timecode format.</param>
            <returns>
                <c>true</c> if the conversion was successful.</returns>
        </member>
        <member name="P:NMotive.Timecode.Subframe">
            <summary>
Gets and sets the subframe portion of the timecode.
</summary>
        </member>
        <member name="P:NMotive.Timecode.Frame">
            <summary>
Gets and sets the frame portion of the timecode.
</summary>
        </member>
        <member name="P:NMotive.Timecode.Seconds">
            <summary>
Gets and sets the seconds portion of the timecode.
</summary>
        </member>
        <member name="P:NMotive.Timecode.Minutes">
            <summary>
Gets and sets the minutes portion of the timecode.
</summary>
        </member>
        <member name="P:NMotive.Timecode.Hours">
            <summary>
Gets and sets the hours portion of the timecode.
</summary>
        </member>
        <member name="M:NMotive.Timecode.#ctor(System.UInt32,System.Int32)">
            <summary>
Constructs a <c>Timecode</c> object and intializes its values from
the Motive integer format for timecode.
</summary>
            <param name="timecode">Motive integer timecode format.</param>
            <param name="subframe">Subframe number.</param>
        </member>
        <member name="M:NMotive.Timecode.#ctor(System.UInt32)">
            <summary>
Constructs a <c>Timecode</c> object and intializes its values from
the Motive integer format for timecode.
</summary>
            <param name="timecode">Motive integer timecode format.</param>
        </member>
        <member name="M:NMotive.Timecode.#ctor">
            <summary>
Constructs a <c>Timecode</c> object with all values set to zero.
</summary>
        </member>
        <member name="T:NMotive.Timecode">
            <summary>
Class representing SMPTE timecode. 
</summary>
        </member>
        <member name="M:NMotive.FrameRangeSet.op_Inequality(NMotive.FrameRangeSet,NMotive.FrameRange)">
            <summary>
Non-equality operator for frame range sets and frame ranges.
</summary>
            <param name="lhs">A frame range set.</param>
            <param name="rhs">A frame range.</param>
            <returns>
                <c>true</c> if the set does not contain exactly one
range which is equal to the given range.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.op_Inequality(NMotive.FrameRangeSet,NMotive.FrameRangeSet)">
            <summary>
Non-equality operator for frame range sets.
</summary>
            <param name="lhs">A frame range set.</param>
            <param name="rhs">A frame range set.</param>
            <returns>
                <c>true</c> if the sets are not equal.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.op_Equality(NMotive.FrameRangeSet,NMotive.FrameRange)">
            <summary>
Equality operator for frame range sets and frame ranges.
</summary>
            <param name="lhs">A frame range set.</param>
            <param name="rhs">A frame range.</param>
            <returns>
                <c>true</c> if the set contains one range which is 
equal to the given range.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.op_Equality(NMotive.FrameRangeSet,NMotive.FrameRangeSet)">
            <summary>
Equality operator for frame range sets.
</summary>
            <param name="lhs">A frame range set.</param>
            <param name="rhs">A frame range set.</param>
            <returns>
                <c>true</c> if the sets are equal.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.op_Subtraction(NMotive.FrameRangeSet,System.Int32)">
            <summary>
Subtraction operator for frame range sets and frame indices.
</summary>
            <param name="lhs">A frame range set.</param>
            <param name="rhs">A frame index to remove from the set.</param>
            <returns>The frame range set with the given frame range whose start and 
endpoints are the given frame index removed.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.op_Subtraction(NMotive.FrameRangeSet,NMotive.FrameRange)">
            <summary>
Subtraction operator for frame range sets and frame ranges.
</summary>
            <param name="lhs">A frame range set.</param>
            <param name="rhs">A frame range to remove from the set.</param>
            <returns>The frame range set with the given frame range removed.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.op_Addition(NMotive.FrameRangeSet,System.Int32)">
            <summary>
Addition operator for frame range sets and frame indices.
</summary>
            <param name="lhs">A frame range set.</param>
            <param name="rhs">A frame index to add to the set.</param>
            <returns>The frame range set with the given frame range whose start and 
endpoints are the given frame index added.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.op_Addition(NMotive.FrameRangeSet,NMotive.FrameRange)">
            <summary>
Addition operator for frame range sets and frame ranges.
</summary>
            <param name="lhs">A frame range set.</param>
            <param name="rhs">A frame range to add to the set.</param>
            <returns>The frame range set with the given frame range added.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.UpdateExtents(System.Int32,NMotive.FrameRange)">
            <summary>Update the extents on the range with the given index in the array.</summary>
        </member>
        <member name="M:NMotive.FrameRangeSet.ConsolidateRanges">
            <summary>Consolidate overlapping ranges and sort them in ascending order.</summary>
        </member>
        <member name="M:NMotive.FrameRangeSet.Range(System.Int32)">
            <summary>
Gets the frame range with a given index.
</summary>
            <param name="n">Index of the frame to get.</param>
            <returns> the n'th disjoint range in the set.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.Contains(System.Int32)">
            <summary>
Tests if this frame range set contains a given frame index.
</summary>
            <param name="frameIndex">A frame index.</param>
            <returns>
                <c>true</c> if this set includes the given frame.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.Contains(NMotive.FrameRange)">
            <summary>
Tests if a given frame range is contained in this set.
</summary>
            <param name="range">The range to test.</param>
            <returns>
                <c>true</c> if this set completely contains the given range.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.Extents">
            <summary>
Calculates the extents of this frame range set.
</summary>
            <returns>A frame range with the lowest and highest frames contained 
in the set of ranges.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.Clear">
            <summary>Clears the list of ranges.</summary>
        </member>
        <member name="M:NMotive.FrameRangeSet.Invert">
            <summary>
Inverts the range set in place. If you invert a range that does not include positive and negative
infinity, the inverted set will extend to those limits.
</summary>
        </member>
        <member name="M:NMotive.FrameRangeSet.Intersection(NMotive.FrameRange)">
            <summary>
Returns the intersection of the given frame range with the this range set, or an empty frame range
if no intersection.
</summary>
            <param name="range">A frame range.</param>
            <returns>The frame range that is the intersection of this frame range set with the
given range.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.Intersects(NMotive.FrameRangeSet)">
            <summary>Returns true if the given range set intersects this set.</summary>
            <param name="set">A frame range set.</param>
            <returns>
                <c>true</c>if any frame range intersects any range in the given set.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.Intersects(NMotive.FrameRange)">
            <summary>Returns true if the given range intersects this set.</summary>
            <param name="range">Range to intersect.</param>
            <returns>
                <c>true</c>if any range in this set intercts the given range.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.Intersect(NMotive.FrameRange)">
            <summary>Sets this range set to the intersection with the given range set.</summary>
            <param name="range">The frame range to intersect.</param>
        </member>
        <member name="M:NMotive.FrameRangeSet.AddNoMerge(NMotive.FrameRange)">
            <summary>Add the given frame range into the set without merging overlapping ranges.</summary>
            <param name="range">A frame range to add.</param>
            <returns>
                <c>true</c> if the range was added. Note that the range will not be added if the
set is empty.</returns>
        </member>
        <member name="M:NMotive.FrameRangeSet.Add(NMotive.FrameRange)">
            <summary>Add (union) the given frame range into the set.</summary>
            <param name="range">A frame range to add.</param>
            <returns>True if the set was changed (the given range was not already included).</returns>
        </member>
        <member name="P:NMotive.FrameRangeSet.RangeCount">
            <summary>Returns the number of disjoint ranges contained in the set.</summary>
        </member>
        <member name="P:NMotive.FrameRangeSet.Empty">
            <summary>Returns true if there are no contained ranges.</summary>
        </member>
        <member name="P:NMotive.FrameRangeSet.TotalFrames">
            <summary>Calculates the total number of frames in the full set of ranges.</summary>
        </member>
        <member name="M:NMotive.FrameRangeSet.#ctor(NMotive.FrameRange)">
            <summary>
Constructs a frame range set containing the given range.
</summary>
            <param name="range">A frame range.</param>
        </member>
        <member name="M:NMotive.FrameRangeSet.#ctor(System.Int32)">
            <summary>
Constructs a frame range set with as single frame range whose
start and end points are the given frame index.
</summary>
            <param name="frameIndex">A frame index.</param>
        </member>
        <member name="M:NMotive.FrameRangeSet.#ctor">
            <summary>
Constructs an empty frame range set.
</summary>
        </member>
        <member name="T:NMotive.FrameRangeSet">
            <summary>
Represents a (non-overlapping) set of frame ranges. Ranges are stored in 
strictly increasing order of frame ranges for convenience when using the class.
</summary>
        </member>
        <member name="M:Motive.cProject.DefaultDataDirectory">
            <summary>Get the default data directory for the current user.</summary>
        </member>
        <member name="M:Motive.cProject.SaveTake(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;MoCapCore.cTakeManager&gt;,std.shared_ptr&lt;MoCapCore.cIStreamsManager&gt;)">
            <summary>Save a take to an arbitrary location on disk.</summary>
        </member>
        <member name="M:Motive.cProject.LoadTake(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;MoCapCore.cTakeManager&gt;,std.shared_ptr&lt;MoCapCore.cTimeManager&gt;,System.Boolean)">
            <summary>Load a take from an arbitrary location on disk.</summary>
        </member>
        <member name="T:Motive.cProject">
            <summary>A loader/saver application layer class for takes.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.DefaultProfileBackupFilename">
            <summary>Returns the full path to the backup file that will be written when the default profile
is updated.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.DefaultProfileName">
            <summary>Default user profile name, to use when starting up, and to save to when shutting down.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.ProfileFilename(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Composes the full path to the given profile name.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.ProfilePath">
            <summary>Full path to where all system user profiles are stored.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.ResetToDefault(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Reset the profile subscriber with the given name to default.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.ResetToDefault">
            <summary>Reset profile subscribers to default.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.LoadProfile(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;,std.allocator&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Load profile information for only the given subscriber type names from the given
profile file.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.LoadProfile(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Load profile information for only the given subscriber from the default profile file.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.LoadProfile(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Load profile information for only the given subscriber from the given profile file.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.LoadProfile(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Load a profile from the given filename.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.SaveProfile(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;,std.allocator&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Save information for only the given subscriber type names to the given profile filename.
Any existing contents in the file will be replaced.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.SaveProfile(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Save information for only the given subscriber type name to the given profile filename.
Any existing contents in the file will be replaced.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.SaveProfile(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Save a profile to the given filename. For the methods that take one or more subscriber names,
the saved profile will only contain elements from the named subscribers.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.AllSubscribers(std.vector&lt;std.shared_ptr&lt;MoCapCore.cIProfileSubscriber&gt;,std.allocator&lt;std.shared_ptr&lt;MoCapCore.cIProfileSubscriber&gt;&gt;&gt;*)">
            <summary>Retrieve a full list of subscribers.</summary>
        </member>
        <member name="M:MoCapCore.cProfileManager.FindSubscriber(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Locate a subscriber by type name.</summary>
            <returns>Valid object if found, null otherwise.</returns>
        </member>
        <member name="M:MoCapCore.cProfileManager.AddSubscriber(std.shared_ptr&lt;MoCapCore.cIProfileSubscriber&gt;)">
            <summary>Add a subscriber.</summary>
        </member>
        <member name="T:MoCapCore.cProfileManager">
            <summary>
Abstract base class for all nodes in a scene.
</summary>
        </member>
        <member name="M:MoCapCore.cIProfileManagerObserver.OnProfileLoaded(MoCapCore.cProfileManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called when the a profile is saved or loaded.
</member>
        <member name="T:MoCapCore.cIProfileManagerObserver">
            <summary>
Observer class for node object types. Derive from this type in order to be notified of changes
to any nodes that you attach to as an observer.
</summary>
        </member>
        <member name="M:MoCapCore.cILabelWarehouse.SelectedLabels(std.vector&lt;Core.cLabel,std.allocator&lt;Core.cLabel&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Retrieve a list of all selected labels.</summary>
            <returns>A list of selected Label objects.</returns>
        </member>
        <member name="M:MoCapCore.cILabelWarehouse.SelectLabel(Core.cLabel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Add Label to selected labels</summary>
        </member>
        <member name="M:MoCapCore.cILabelWarehouse.ClearSelectedLabels">
            <summary>Clear selected labels</summary>
        </member>
        <member name="M:MoCapCore.cILabelWarehouse.LabelName(Core.cLabel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Convenience function to retrieve the text name for a given label.</summary>
        </member>
        <member name="M:MoCapCore.cILabelWarehouse.IsLabel(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Determines if the given name matches is a match for a full label name. Full label names are denoted
by EntityName_LabelName.</summary>
        </member>
        <member name="M:MoCapCore.cILabelWarehouse.FindLabelSource(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Retrieve all labels for the label source with the given EntityID.</summary>
        </member>
        <member name="M:MoCapCore.cILabelWarehouse.AddLabelSource(std.shared_ptr&lt;MoCapCore.cILabelSource!System.Runtime.CompilerServices.IsConst&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Add a label source to our available list of sources.</summary>
        </member>
        <member name="M:MoCapCore.cILabelWarehouse.LabelDelimiter">
            <summary>Returns the character used to delimit entity names from member names. For example, if the delimiter
is '_', then labeled markers will follow the pattern EntityName_MarkerName.</summary>
        </member>
        <member name="M:MoCapCore.cILabelWarehouse.Clear">
            <summary>Remove all label sources.</summary>
        </member>
        <member name="T:MoCapCore.cILabelWarehouse">
            <summary>Warehouse class for label sources which provide available labels.</summary>
        </member>
        <member name="M:MoCapCore.cILabelWarehouseObserver.OnSelectedLabelListChanged(MoCapCore.cILabelWarehouse!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called whenever the selected label list changes.</summary>
        </member>
        <member name="M:MoCapCore.cILabelWarehouseObserver.OnLabelListChanged(MoCapCore.cILabelWarehouse!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called whenever the available labels list changes.</summary>
        </member>
        <member name="M:MotiveCore.cLiveDeviceManager.CameraByIndex(System.Int32)">
            <summary>Only for use in the Motive API. Retrieve a camera node by index.</summary>
        </member>
        <member name="M:MotiveCore.cLiveDeviceManager.SetPersistedSyncProperties(std.unique_ptr&lt;MoCapCore.cPropertyCollection,std.default_delete&lt;MoCapCore.cPropertyCollection&gt;&gt;)">
            <summary>Set the properties that were persisted from the last run. These are used when initializing a new
sync device when it becomes available.</summary>
        </member>
        <member name="M:MotiveCore.cLiveDeviceManager.ReplaceSuspendedCameras">
            <summary>Detect and replace any suspended cameras.</summary>
        </member>
        <member name="M:MotiveCore.cLiveDeviceManager.CameraButton(MoCapCore.cCameraNode*)">
            <summary>Handle a button press on a camera.</summary>
        </member>
        <member name="M:MotiveCore.cLiveDeviceManager.ActiveWandIsActive">
            <summary>True if an active wand is currently in use.</summary>
        </member>
        <member name="M:MotiveCore.cLiveDeviceManager.SetActiveWand(System.Boolean)">
            <summary>SetActiveWand when enabled will shift (or disable on USB) IR strobe for
 the utilization of active wands.</summary>
        </member>
        <member name="M:MotiveCore.cLiveDeviceManager.ApplyToAll(std.function&lt;(MoCapCore.cDeviceNode*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)(MoCapCore.cDeviceNode*!System.Runtime.CompilerServices.IsImplicitlyDereferenced&amp;)&gt;)">
            <summary>Apply the given lambda to all devices (this will include cameras and other device types).</summary>
        </member>
        <member name="M:MotiveCore.cLiveDeviceManager.Apply(std.function&lt;(MoCapCore.cCameraNode*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)(MoCapCore.cCameraNode*!System.Runtime.CompilerServices.IsImplicitlyDereferenced&amp;)&gt;)">
            <summary>Apply the given lambda to all cameras.</summary>
        </member>
        <member name="M:MotiveCore.cLiveDeviceManager.CameraCount">
            <summary>Current number of camera and device nodes.</summary>
        </member>
        <member name="M:MotiveCore.cLiveDeviceManager.AreCamerasInitialized">
            <summary>Senses whether live cameras have been given adequate time to be discovered and initialized.</summary>
        </member>
        <member name="M:MotiveCore.cLiveDeviceManager.IsInitialDeviceDiscoveryComplete">
            <summary>True if it is determined that initial camera discovery has been given adequate time and is complete.</summary>
        </member>
        <member name="M:MotiveCore.cILiveDeviceManagerObserver.CalibrationChanged(MotiveCore.cLiveDeviceManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when calibration info for the system has changed.</summary>
        </member>
        <member name="M:MotiveCore.cILiveDeviceManagerObserver.DevicesRemoved(MotiveCore.cLiveDeviceManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.set&lt;System.UInt32,std.less&lt;System.UInt32&gt;,std.allocator&lt;System.UInt32&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when a device is removed or unplugged. A list of the serial numbers of the devices that
were removed is also passed.</summary>
        </member>
        <member name="M:MotiveCore.cILiveDeviceManagerObserver.DevicesAdded(MotiveCore.cLiveDeviceManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.set&lt;System.UInt32,std.less&lt;System.UInt32&gt;,std.allocator&lt;System.UInt32&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when a device is added and initialized. A list of the serial numbers of the devices that
were added is also passed.</summary>
        </member>
        <member name="M:MoCapCore.cILiveDeviceManager.ActiveWandIsActive">
            <summary>True if an active wand is currently in use.</summary>
        </member>
        <member name="M:MoCapCore.cILiveDeviceManager.ApplyToAll(std.function&lt;(MoCapCore.cDeviceNode*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)(MoCapCore.cDeviceNode*!System.Runtime.CompilerServices.IsImplicitlyDereferenced&amp;)&gt;)">
            <summary>Apply the given lambda to all devices (this will include cameras and other device types).</summary>
        </member>
        <member name="M:MoCapCore.cILiveDeviceManager.Apply(std.function&lt;(MoCapCore.cCameraNode*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)(MoCapCore.cCameraNode*!System.Runtime.CompilerServices.IsImplicitlyDereferenced&amp;)&gt;)">
            <summary>Apply the given lambda to all cameras.</summary>
        </member>
        <member name="M:MoCapCore.cILiveDeviceManager.AreCamerasInitialized">
            <summary>Senses whether live cameras have been given adequate time to be discovered and initialized.</summary>
        </member>
        <member name="M:MoCapCore.cILiveDeviceManager.IsInitialDeviceDiscoveryComplete">
            <summary>True if it is determined that initial camera discovery has been given adequate time and is complete.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.SetPropertiesFromCalibration(MoCapCore.cCameraSettings!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set properties based on information in a calibration object.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.CameraGroup">
            <summary>Tracks whether this is an object or reference camera.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.SetStatusRingColor(System.Int32,System.Single*,System.Single*,System.Single*)">
            <summary>Set colors for all LEDs in the Status Ring individually</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.SetStatusRingColor(System.Single,System.Single,System.Single)">
            <summary>Set a single color for all LEDs in the Status Ring</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.UpdateMoodLight(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Updates the camera mood light based on current state.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.Orientation">
            <summary>Retrieve the 2D camera orientation, in radians.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.SetOrientation(System.Single)">
            <summary>Sets the 2D camera orientation.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.SetToActualOrientation">
            <summary>Sets the camera view orientation.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.TestObject(CameraLibrary.cObject!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Perform a 2D centroid filter test on a 2D object. Return value of true means it's passed the filter test
(and should be kept).
</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.CentroidFilter2DSettings">
            <summary>Fetch 2D centroid filter settings for this device.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.SetCentroidFilter2DSettings(MoCapCore.cCentroidFilter2DSettings!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Apply 2D centroid filter settings.  This will push updated settings to the hardware.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.SetCameraInMotion(System.Boolean)">
            <summary>Continuous calibration camera control.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.SetBlocking(System.Single,System.Single,System.Boolean,System.Int32)">
            <summary>Per-pixel blocking mask editing.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.StartBlockingVisibleMarkers(System.Int32,System.Int32)">
            <summary>
Begins to block visible markers over a sequence of several frames. The mask will not actually
be updated until some time later (after call to FinalizeBlockingUpdate), so the blocking mask
on the camera should not be queried until after it has been updated.
</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.BlockSurface">
            <summary>Blocking surface and bitmap.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.UpdateBitmapFromBlocking">
            <summary>Update the mask image on the camera with the current blocking mask.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.ClearBlocking">
            <summary>
Immediately clears the mask image on the camera. The mask image can be queried and will
return correct results after this method is called.
</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.EnableState">
            <summary>Convenience function that derives an enable state from the Enabled and ReconstructionEnabled
properties.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.IsEnabledForRecording">
            <summary>True if the camera is enabled and enabled for reconstruction.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.IsVisible3D">
            <summary>True if this camera should be drawn in a 3D viewport.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.PushFrame(std.shared_ptr&lt;CameraLibrary.Frame!System.Runtime.CompilerServices.IsConst&gt;,System.Boolean,System.Int32,System.Boolean)">
            <summary>Process a new incoming frame of data.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.Pose">
            <summary>Retrieve full pose information for the camera.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.SetPose(Core.cPose&lt;System.Single&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set pose information for the camera.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.Graphics">
            <summary>Access to the internal graphical representation of this camera. An interface class.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.CameraID">
            <summary>Retrieve the human-usable camera number for this device.</summary>
        </member>
        <member name="M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cILiveDeviceManager*,std.shared_ptr&lt;MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst&gt;)">
            <summary>Creates a blank camera node that can later be filled. Intended only for LIVE devices.</summary>
        </member>
        <member name="T:MoCapCore.cCameraNode">
            <summary>
cCameraNode is a Node that encapsulates access to a lower level Camera object,
which is associated by ID.  It also provides IPropertyProvider and IChannel support.

sub-class this node for specific camera model type to override property settings and other behavior
</summary>
        </member>
        <member name="M:MoCapCore.cICameraNodeFactory.SetDeviceOnNode(MoCapCore.cCameraSettings!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cINode*)">
            <summary>Set the internal device on a DeviceNode using calibration camera settings.</summary>
        </member>
        <member name="M:MoCapCore.cICameraNodeFactory.HasInternalDevice(MoCapCore.cINode!System.Runtime.CompilerServices.IsConst*)">
            <summary>Determines if the passed node is a device, and whether it has a valid CameraLibrary device attached.</summary>
        </member>
        <member name="M:MoCapCore.cICameraNodeFactory.CreateInstance(MoCapCore.cCameraSettings!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Construct a new node based on the info given in a cCameraSettings object.</summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.ApplyInternalSettingsToNode(System.Boolean)">
            <summary>Update node props from internal camera.</summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.InternalDevice">
            <summary>Access to the internal CameraLibrary device.</summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.SetDevice(CameraLibrary.Camera*)">
            <summary>Set associated internal device.</summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.MapDeviceRevisionToString(System.Int32)">
            <summary>Map an internal device revision number from the CameraLibrary into a human-readable string.</summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.IsUSB">
            <summary>True if this is a USB device.</summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.IsVirtual">
            <summary>True if this is virtual device.</summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.SerialNumber">
            <summary>Numeric (possibly encoded) serial number that is unique among all cameras.</summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.Serial">
            <summary>Convenience function to retrieve the serial number of the camera.</summary>
        </member>
        <member name="M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cILiveDeviceManager*,std.shared_ptr&lt;MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst&gt;)">
            <summary>Creates a blank device node that can later be filled. Intended only for LIVE devices.</summary>
        </member>
        <member name="T:MoCapCore.cDeviceNode">
            <summary>
cDeviceNode is a Node that encapsulates access to a lower level CameraLibrary device object,
which is associated by serial number.  It also provides IPropertyProvider and IChannel support.

sub-class this node for specific device model type to override property settings and other behavior
</summary>
        </member>
        <member name="F:MoCapCore.cSystemLatency.mValidTimer">
            <summary>Timer to determine if the most recent clock synchronization results are still relevant.</summary>
        </member>
        <member name="F:MoCapCore.cSystemLatency.mIntervalTimer">
            <summary>Timer utilized to determine if it's time to perform another clock synchronization.</summary>
        </member>
        <member name="F:MoCapCore.cSystemLatency.mUpdatePeriod">
            <summary>The period between clock synchronization queries.</summary>
        </member>
        <member name="M:MoCapCore.cSystemLatency.LocateVolunteerCameraFrame(std.shared_ptr&lt;CameraLibrary.FrameGroup!System.Runtime.CompilerServices.IsConst&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Locate a supported camera to utilize for the latency calculation and return its frame.</summary>
        </member>
        <member name="M:MoCapCore.cSystemLatency.IsSupportedSystem(CameraLibrary.FrameGroup!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Determine if it's possible to perform a real-time latency calculation.</summary>
        </member>
        <member name="M:MoCapCore.cSystemLatency.LatencyCallback(CameraLibrary.sHardwareTimeInfo!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Callback hook for reported system latency information from the camera callback.</summary>
        </member>
        <member name="M:MoCapCore.cSystemLatency.CheckUpdateSync(std.shared_ptr&lt;MoCapCore.cPipelineFrame!System.Runtime.CompilerServices.IsConst&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Checks to see if it's time to issue another hardware clock sync query.
Internally rate limited. Can be called every frame.</summary>
        </member>
        <member name="M:MoCapCore.cSystemLatency.FrameGroupReceived(std.shared_ptr&lt;CameraLibrary.FrameGroup!System.Runtime.CompilerServices.IsConst&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;MoCapCore.cPipelineFrame&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Populates pipeline frame telemetry related to system latency measurement. Call every frame.</summary>
        </member>
        <member name="M:MoCapCore.cSystemLatency.SecondsSinceExposure(std.shared_ptr&lt;MoCapCore.cPipelineFrame!System.Runtime.CompilerServices.IsConst&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns the clock synchronized estimated delta between now and a pipeline frame exposure.</summary>
        </member>
        <member name="M:MoCapCore.cSystemLatency.SecondsSinceTimestamp(System.UInt64)">
            <summary>Returns the clock synchronized estimated delta between now and a master timestamp.</summary>
        </member>
        <member name="M:MoCapCore.cSystemLatency.Valid">
            <summary>Checks whether latency clock synchronization is established and recent.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.Hash">
            <summary>Returns a unique value for the contents of this instance. Another instance may have the same
value if it has exactly the same contents.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.HasDataBundle(System.Int32)">
            <summary>Determine whether a data bundle for the given type exists.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.DataBundle(System.Int32)">
            <summary>Retrieve the data bundle for the given type. Returns an invalid shared pointer if a bundle of the requested
type has not been set.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.SetDataBundle(std.shared_ptr&lt;Core.cIDataTypeBundle&gt;)">
            <summary>Set the data bundle of the given type. Ownership is transferred here.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.FrameDeliveryRate">
            <summary>Frames per second.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.Recording">
            <summary>True if this frame is to be recorded.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.Timestamp">
            <summary>The frame timestamp, in seconds.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.TimeCode">
            <summary>The frame timestamp, in seconds.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.SystemFrame">
            <summary>The system frame number, without any offsets for recording.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.Frame">
            <summary>The frame number. This will be zero-based during a recording.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.SetFrame(System.Int32,System.Int32,Core.cTimeCode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Boolean,System.Single)">
            <summary>Set the frame number, time code, timestamp, and whether or not this frame is to be recorded,
along with other ancillary frame information.</summary>
        </member>
        <member name="M:MoCapCore.cPipelineFrame.Clear">
            <summary>Clears all data and prepares this instance to be reused. This is useful for reusing memory
that has been previously allocated </summary>
        </member>
        <member name="T:MoCapCore.cPipelineFrame">
            <summary>
A container class that holds all the accumulated data streams and telemetry information for a single frame of data.
Data objects in this container may be set once and only once until the entire container is cleared.
This is to help ensure write-once/read-many behavior.
</summary>
        </member>
        <member name="M:MoCapCore.cReconstructionPropertySet.ReconstructionBounds(MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Extract the reconstruction properties from the given provider and calculate the reconstruction
volume based on shape type, etc.</summary>
        </member>
        <member name="M:Core.Vector4.dotProduct(Core.Vector4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculates the dot (scalar) product of this vector with another.
    @param
    vec Vector with which to calculate the dot product (together
    with this one).
    @returns
    A float representing the dot product value.

</member>
        <member name="M:Core.Vector4.op_Assign(Core.Vector4!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assigns the value of the other vector.
    @param
    rkVector The other vector

</member>
        <member name="M:Core.Vector4.ptr">
Pointer accessor for direct copying

Pointer accessor for direct copying
</member>
        <member name="T:Core.Vector4">
4-dimensional homogeneous vector.

</member>
        <member name="M:Core.Vector3.angleBetween(Core.Vector3*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Generates a vector perpendicular to this vector (eg an 'up' vector).
    @remarks
    This method will return a vector which is perpendicular to this
    vector. There are an infinite number of possibilities but this
    method will guarantee to generate one of them. If you need more
    control you should use the Quaternion class.

Gets the angle between 2 vectors.
    @remarks
    Vectors do not have to be unit-length but must represent directions.

</member>
        <member name="M:Core.Vector3.makeCeil(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets this vector's components to the maximum of its own and the
    ones of the passed in vector.
    @remarks
    'Maximum' in this case means the combination of the highest
    value of x, y and z from both vectors. Highest is taken just
    numerically, not magnitude, so 1 &gt; -3.

</member>
        <member name="M:Core.Vector3.op_GreaterThan(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns true if the vector's scalar components are all smaller
    that the ones of the vector it is compared against.

</member>
        <member name="M:Core.Vector3.op_LessThan(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns true if the vector's scalar components are all greater
    that the ones of the vector it is compared against.

</member>
        <member name="M:Core.Vector3.midPoint(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns a vector at a point half way between this and the passed
    in vector.

</member>
        <member name="M:Core.Vector3.crossProduct(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculates the cross-product of 2 vectors, i.e. the vector that
    lies perpendicular to them both.

</member>
        <member name="M:Core.Vector3.absDotProduct(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculates the absolute dot (scalar) product of this vector with another.
    @remarks
    This function work similar dotProduct, except it use absolute value
    of each component of the vector to computing.
    @param
    vec Vector with which to calculate the absolute dot product (together
    with this one).
    @returns
    A Real representing the absolute dot product value.

</member>
        <member name="M:Core.Vector3.dotProduct(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculates the dot (scalar) product of this vector with another.
    @remarks
    The dot product can be used to calculate the angle between 2
    vectors. If both are unit vectors, the dot product is the
    cosine of the angle; otherwise the dot product must be
    divided by the product of the lengths of both vectors to get
    the cosine of the angle. This result can further be used to
    calculate the distance of a point from a plane.
    @param
    vec Vector with which to calculate the dot product (together
    with this one).
    @returns
    A float representing the dot product value.

</member>
        <member name="M:Core.Vector3.squaredDistance(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns the square of the distance to another vector.
    @remarks
    This method is for efficiency - calculating the actual
    distance to another vector requires a square root, which is
    expensive in terms of the operations required. This method
    returns the square of the distance to another vector, i.e.
    the same as the distance but before the square root is taken.
    Use this if you want to find the longest / shortest distance
    without incurring the square root.

</member>
        <member name="M:Core.Vector3.distance(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns the distance to another vector.
    @warning
    This operation requires a square root and is expensive in
    terms of CPU operations. If you don't need to know the exact
    distance (e.g. for just comparing distances) use squaredDistance()
    instead.

</member>
        <member name="M:Core.Vector3.squaredLength">
Returns the square of the length(magnitude) of the vector.
    @remarks
    This  method is for efficiency - calculating the actual
    length of a vector requires a square root, which is expensive
    in terms of the operations required. This method returns the
    square of the length of the vector, i.e. the same as the
    length but before the square root is taken. Use this if you
    want to find the longest / shortest vector without incurring
    the square root.

</member>
        <member name="M:Core.Vector3.op_Assign(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assigns the value of the other vector.
    @param
    rkVector The other vector

</member>
        <member name="M:Core.Vector3.ptr">
Pointer accessor for direct copying

Pointer accessor for direct copying
</member>
        <member name="M:Core.ComputeBlockHash(Core.cSerializer*,SHA1*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,HL_SHA1_CTX*)">
            <summary>Compute hash for a given individual data block of a serializer.</summary>
        </member>
        <member name="M:Core.ComputeHashTag(Core.cSerializer*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Compute a SHA1 hash for the given serializer's data.</summary>
        </member>
        <member name="M:SHA1.SHA1Result(HL_SHA1_CTX*,System.Byte*)">
  @brief 	This ends the sha operation, zeroizing the context
  		and returning the computed hash.

  @param	context The context to get the hash from
  @param	Message_Digest This is an OUT parameter which
  		contains the hash after the menberfunction returns
  @return	0 on succes, an error-code otherwise

</member>
        <member name="M:SHA1.SHA1Input(HL_SHA1_CTX*,System.Byte!System.Runtime.CompilerServices.IsConst*,System.UInt32)">
  @brief 	Data input.

  		This memberfunction add data to the specified
  		context.

  @param	context The context to add data to
  @param	message_array The data to add
  @param	length The length of the data to add

</member>
        <member name="M:SHA1.SHA1Reset(HL_SHA1_CTX*)">
@brief 	Resets the sha1 context and starts a new
		hashprocess
@param	context The context to reset
@return	0 on succes an error number otherwise

</member>
        <member name="M:SHA1.SHA1ProcessMessageBlock(HL_SHA1_CTX*)">
  @brief      This member-function will process the next 512 bits of the
  		message stored in the Message_Block array.

      	Many of the variable names in this code, especially the
      	single character names, were used because those were the
      	names used in the publication.

  @param	context The context to process

</member>
        <member name="M:SHA1.SHA1PadMessage(HL_SHA1_CTX*)">
  @brief 	Internal method to padd the message

      	According to the standard, the message must
      	be padded to an even 512 bits. The first 
      	padding bit must be a '1'.  The last 64	bits 
      	represent the length of the original message.
      	All bits in between should be 0.
      	This function will pad the message according 
      	to those rules by filling the Message_Block array
      	accordingly.  It will also call the 
      	ProcessMessageBlock function provided appropriately.
      	When it returns, it can be assumed that the message
      	digest has been computed.

  @param	context The context to padd


</member>
        <member name="T:SHA1">
  @brief 	This class represents the implementation of 
   		the sha1 algorithm.

   		Basically the class provides three public member-functions
   		to create a hash:  SHA1Reset(), SHA1Input() and SHA1Result().
   		If you want to create a hash based on a string or file quickly
   		you should use the sha1wrapper class instead of SHA1.

</member>
        <member name="F:HL_SHA1_CTX.Corrupted">
Is the message digest corrupted? 
</member>
        <member name="F:HL_SHA1_CTX.Computed">
Is the digest computed? 
</member>
        <member name="F:HL_SHA1_CTX.Message_Block">
512-bit message blocks 
</member>
        <member name="F:HL_SHA1_CTX.Message_Block_Index">
Index into message block array 
</member>
        <member name="F:HL_SHA1_CTX.Length_High">
Message length in bits 
</member>
        <member name="F:HL_SHA1_CTX.Length_Low">
Message length in bits 
</member>
        <member name="F:HL_SHA1_CTX.Intermediate_Hash">
Message Digest 
</member>
        <member name="T:HL_SHA1_CTX">
@brief this struct represents a SHA1-hash context.

</member>
        <member name="D:hl_uint64">
at least 8 Byte

</member>
        <member name="D:hl_uint32">
at least 4 Byte

</member>
        <member name="D:hl_uint16">
at least 2 Byte

</member>
        <member name="D:hl_uint8">
@file 	hl_sha1.h
@brief	This file contains the declaration of the SHA1 class
@date 	Mo 17 Sep 2007

exactly 1 Byte

</member>
        <member name="T:CameraLibrary.Frame">
            <summary>Data for a single camera on a single frame.</summary>
        </member>
        <member name="M:MotiveCore.cMotivePeripheralManager.ForcePlates">
Return all force plate nodes
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.AutoZero(AnalogSystem.cPluginDeviceBase*)">
Zero (tare) the device 
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.RemoveAllSelectedForcePlates">
Clear Selected ForcePlates
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.ClearSelectedForcePlateChannels">
Clear select force plate channels
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.SelectForcePlateChannel(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Boolean)">
Select ForcePlate Device *and* Node channel
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.SelectForcePlate(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Select force plate node
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.GetForcePlates(std.vector&lt;MoCapCore.cForcePlateNode**,std.allocator&lt;MoCapCore.cForcePlateNode**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get all force plate nodes
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.GetForcePlateByOrder(System.Int32)">
Get ForcePlate node by order
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.GetForcePlate(Core.cUID)">
Get ForcePlate node by ID
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.ValidatePlateOrdering">
Validate plate order is consistent and unique
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.CalculateForceVector(Core.cUID,Core.cVector3&lt;System.Single&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cVector3&lt;System.Single&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Calculate the most recent live frame's force vector (world coords, GRF)
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.CalculateForcePlateCornersFromCalSquare(CameraCalibration.cCalibrationSquare*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cForcePlateNode*)">
Calculate the specified force plate's corners (in world coords) given the cal squares coords
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.ClearSelectedDeviceNodeChannels(AnalogSystem.IDevice*)">
Clear DeviceNode channel selection
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.ClearSelectedDeviceNodeChannels">
Clear DeviceNode channel selection
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.SelectDeviceNodeChannel(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Boolean)">
Select DeviceNode channel
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.GeneralDevices">
Return General devices nodes
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.DataAcquisitions">
Return Data Acquisition nodes
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.UpdateSeedDeviceNodesFromDevices">
Sync DeviceNode property state with device state ( adding node if necessary)
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.SelectDeviceNode(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Select DeviceNode by ID
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.ClearSelectedDeviceNodes">
Clear selected devices nodes
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.GetActiveDeviceNodes(std.vector&lt;MoCapCore.cExternalDeviceNodeBase**,std.allocator&lt;MoCapCore.cExternalDeviceNodeBase**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get all Active (enabled) device nodes from the current TAK
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.GetAllDeviceNodes(std.vector&lt;MoCapCore.cExternalDeviceNodeBase**,std.allocator&lt;MoCapCore.cExternalDeviceNodeBase**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get all device nodes from the current TAK
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.GetDeviceNode(AnalogSystem.IDevice*)">
Get live DeviceNode by Device
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.GetDeviceNode(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;)">
Get live DeviceNode by Device Serial# (the device's unique ID)
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.GetDeviceNode(Core.cUID)">
Get live DeviceNode by UID
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.ClearSelectedDeviceChannels(AnalogSystem.IDevice*)">
Clear channel selection
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.ClearSelectedDeviceChannels">
Clear channel selection
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.GetSelectedDeviceChannels(std.vector&lt;MoCapCore.cIPropertyProvider**,std.allocator&lt;MoCapCore.cIPropertyProvider**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get selected channels
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.SelectDeviceChannel(AnalogSystem.IDevice*,System.Int32,System.Boolean)">
Select Device channel
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.EnableDeviceChannel(AnalogSystem.cPluginDeviceBase*,System.Int32,System.Boolean,System.Boolean)">
Toggle collecting from the specified channel (optionally invoking  device reconfiguration)
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.GetDevice(MoCapCore.cINode*)">
Get the PluginDevice associated with the specified DeviceNode (by device serial #) as cIPropertyProivider
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.GetDevice(MoCapCore.cExternalDeviceNodeBase*)">
Get the PluginDevice associated with the specified DeviceNode (by device serial #)
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.GetActiveDevices(std.list&lt;AnalogSystem.cPluginDeviceBase**,std.allocator&lt;AnalogSystem.cPluginDeviceBase**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get all Active (enabled) devices
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.EnableDevice(AnalogSystem.IDevice*,System.Boolean)">
Toggle device enabled / disabled
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.ValidateDeviceAcquisitionRate(System.Int32)">
Validate that the specified rate is actually supported by this device
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.UpdateDeviceRateFromExternal(AnalogSystem.cPluginDeviceBase*)">
Update device rate from current external (e.g. eSync) source
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.UpdateDeviceMocapRate(System.Double)">
Update the mocap rate for each device
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.PluginDeviceCount">
Returns the number of instantiated PluginDevices
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.PluginDevice(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;)">
Returns the PluginDevice with the specified serial (unique id)
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.PluginDevice(System.Int32)">
Returns the PluginDevice at the specified index
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.ProfileFilePath">
Path to file containing device configurations and settings (Profile)
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.LastError">
Get last reported error
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.GetNeedMocapSynchStartFrame">
Indicate if PeripheralManager is waiting for a mocap sync frame
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.SetNeedMocapSynchStartFrame(System.Boolean)">
Tell PeripheralManager *some* device(s) need a need mocap sync frame
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.SetNeedAnalogSync(System.Boolean,AnalogSystem.cPluginDeviceBase*)">
Tell *all* devices to reset their sync status and require mocap sync alignment
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.SetRunMode(System.Int32)">
Set host run mode (live, recording, playback), allowing devices to query host run state
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.IsAnalogCollecting">
Indicate if any devices are capturing
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.StopAnalogCollecting">
Notify each enabled device's to stop capture 
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.StartAnalogCollecting">
Notify each enabled device's to start capture 
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.AnalogDeviceDiscovery(System.Boolean)">
Detect and enumerate all supported peripheral (plugin) devices
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.RequestSearchForDevices">
Indicates whether peripheral manager needs to search for devices
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.SetRequestSearchForDevices(System.Boolean)">
Indicate peripheral manager needs to search for devices
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.UpdateDeviceConfigurations">
Update device configuration and channel allocations
</member>
        <member name="M:MotiveCore.cMotivePeripheralManager.LoadDeviceProfiles(std.shared_ptr&lt;MoCapCore.cProfileManager&gt;)">
Load saved device settings into devices
</member>
        <member name="M:MoCapCore.cCameraCalibration.SetCalibrationInfo(MoCapCore.cCameraCalibration!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Copy calibration info from another cCameraCalibration</summary>
        </member>
        <member name="M:MoCapCore.cCameraCalibration.ClearCalibrationInfo">
            <summary>Clear calibration info with this method.</summary>
        </member>
        <member name="M:MoCapCore.cCameraCalibration.InitializeCalibrationInfo(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Populate calibration info with this method.</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.Year">
            <summary>Date and time of calibration</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.WandActive">
            <summary>IsActiveWand reports if an active wand was used for calibration.</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.WandMicronSeries">
            <summary>IsMicronSeries reports if an OptiTrack Micron Series wand was used.</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.WandCenterOffset">
            <summary>This is the amount of offset in the wand's center marker in meters.</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.WandLength">
            <summary>This length of the wand used for calibration in meters.</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.WandMeanError99Percentile">
            <summary>99% of the Wand Mean Error values are less than this number.</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.WandMeanError95Percentile">
            <summary>95% of the Wand Mean Error values are less than this number.</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.WandMeanError50Percentile">
            <summary>50% of the Wand Mean Error values are less than this number.</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.WandMeanError">
            <summary>This is the global wand mean error for the system.</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.TriangulationMeanResidualError99Percentile">
            <summary>99% of the Triangulation Mean Residual values are less than this number.</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.TriangulationMeanResidualError95Percentile">
            <summary>95% of the Triangulation Mean Residual values are less than this number.</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.TriangulationMeanResidualError50Percentile">
            <summary>50% of the Triangulation Mean Residual values are less than this number.</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.TriangulationMeanResidualError">
            <summary>This is the global triangulation mean residual error for the camera system.</summary>
        </member>
        <member name="F:MoCapCore.cCameraCalibration.ReprojectionMeanPixelError">
            <summary>This is the global reprojection mean pixel error for the camera system.</summary>
        </member>
        <member name="M:Core.ConvertPose(Core.cPose&lt;System.Double&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Convert double pose to float pose.</summary>
        </member>
        <member name="M:Core.cISerializer.WriteData(Core.cISerializer!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>To Be Deprecated - Write the full contents of the given serializer into this one.</summary>
        </member>
        <member name="F:MoCapCore.cTimeManager.kDefaultFrameRate">
            <summary>The default time step applied at creation, and usable for resetting to default.</summary>
        </member>
        <member name="F:MoCapCore.cTimeManager.kDefaultAnimationRange">
            <summary>The default animation range applied at creation, and usable for resetting to default.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.VisibleRange">
            <summary>Get the current play range.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.SetVisibleRange(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the "visible" time range, which is always a subset of the full animation range.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.HasSelectedRanges">
            <summary>Returns true if there is a non-empty time selection.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.SelectedRanges">
            <summary>Returns the number of (disconnected) selected frame ranges.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.ClearSelectedRanges">
            <summary>Clears all frame selections.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.SelectRanges(Core.cFrameRangeSet!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Replace any current range selection with the given range set.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.SelectRange(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Add the given range to the currently selected frame range(s).</summary>
            <param name="exclusive">If true, any existing time selection will be replaced by the one given.</param>
        </member>
        <member name="M:MoCapCore.cTimeManager.PlaySpeed">
            <summary>Returns the time scaling in effect during playback.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.FrameRate">
            <summary>Get the master frame rate (in frames/sec), based on current time step.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.TimeStep">
            <summary>Returns the current frame time step (in secs) used during playback.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.Looping">
            <summary>Returns true if looping is active.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.IsPlaybackMode(MoCapCore.cTimeManager.eRunMode)">
            <summary>Returns true if the given mode is a "playback" mode.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.IsLiveMode(MoCapCore.cTimeManager.eRunMode)">
            <summary>Returns true if the given mode is a "live" mode.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.IsLive">
            <summary>Returns true if we are in a live mode.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.IsPaused">
            <summary>Returns true if playback is paused.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.IsPlaying">
            <summary>Returns true if playback is active (not real-time, paused, or recording).</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.IsRecording">
            <summary>Returns true if recording is active.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.CanGoLive">
            <summary>Returns true if the system can go live and/or record.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.PlayRange">
            <summary>Get the current play range.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.AnimationRange">
            <summary>Get the current valid animation range.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.DisplayFrame(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Applies logic to determine the values that should be displayed for frame time. If in Live mode,
this will return zero until recording starts. If in playback mode, it will return the current frame.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.CurrentFrame">
            <summary>Gets the current frame number.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.RunMode">
            <summary>Current run mode.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.SetPlaySpeed(System.Double)">
            <summary>Set the time scaling to use during playback, in the range [0.01, 100.0].</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.SetFrameRate(System.Double)">
            <summary>Set the master frame rate. This is the playback rate when playing back at 100% play speed.</summary>
            <returns>True if the given step size was valid and set.</returns>
        </member>
        <member name="M:MoCapCore.cTimeManager.SetPlaybackType(MoCapCore.cTimeManager.ePlaybackType,System.Boolean)">
            <summary>
Set playback type, choosing between looping / bounce and EndPoint.
</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.SetLooping(System.Boolean,System.Boolean)">
            <summary>
Set looping on or off. When looping is on, playback will reset to the other end of the
play range if playback is stepped beyond the end.
</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.SetPlayRange(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Set the valid playback range, which must be a subset of the animation range.</summary>
            <param name="keepTimeInRange">If true, current time will be changed as needed to lie within the new play range.</param>
            <returns>False if the range was already equal to the value passed.</returns>
        </member>
        <member name="M:MoCapCore.cTimeManager.SetAnimationRange(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Set the full valid range for any playback, time selection, etc.</summary>
            <param name="keepTimeInRange">If true, current time will be changed as needed to lie within the new range.</param>
            <returns>False if the range was already equal to the value passed.</returns>
        </member>
        <member name="M:MoCapCore.cTimeManager.SetCurrentFrame(System.Int32,System.Boolean,System.Boolean)">
            <summary>Set the current frame. Run mode status is unaffected.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.GoToEnd">
            <summary>Sets the current time to the end of the current play range.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.GoToStart">
            <summary>Sets the current time to the beginning of the play range.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.Reset(System.Double,Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Resets to initial state, with a given time step and animation range.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.Stop">
            <summary>Stop any playback and set run mode to real-time.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.StepBackward(System.UInt32)">
            <summary>Steps playback one frame backward. Stops recording or playback if either is active.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.StepForward(System.UInt32)">
            <summary>Steps playback forward the given number of frames. Stops recording or playback if either is active.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.Pause">
            <summary>Pause playback.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.PlayReverse">
            <summary>
Start playback in reverse. Stops recording if recording is active. During playback,
time gets updated on TimeManager's own thread, and update notifications that go out
do so on that thread.
</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.Play">
            <summary>
Start playback. Stops recording if recording is active. During playback, time gets
updated on TimeManager's own thread, and update notifications that go out do so on
that thread.
</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.ShutDown">
            <summary>Shut the thread down and prepare for tear-down.</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.StartUp">
            <summary>
Must be called after construction to initialize the frame counter. Should be done toward the 
end of application startup to minimize time change notifications during startup.
</summary>
        </member>
        <member name="M:MoCapCore.cTimeManager.#ctor(System.Boolean)">
            <summary>Create a new instance. There should typically only be one instance of TimeManager.</summary>
            <param name="canGoLive">Sets whether live/record modes are available or not.</param>
        </member>
        <member name="T:MoCapCore.cTimeManager">
            <summary>
A singleton class that manages the playback head, including current time and recording status.
Any objects that rely on knowledge of time, playback status, or recording status should acquire
it from this object.
</summary>
        </member>
        <member name="M:MoCapCore.cITimeManagerObserver.OnSelectedRangesChanged(MoCapCore.cTimeManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when selected frame ranges change.</summary>
        </member>
        <member name="M:MoCapCore.cITimeManagerObserver.OnRunModeChanged(MoCapCore.cTimeManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>Called when the run mode changes.</summary>
        </member>
        <member name="M:MoCapCore.cITimeManagerObserver.OnRunModeChanging(MoCapCore.cTimeManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>Called when the run mode changes.</summary>
        </member>
        <member name="M:MoCapCore.cITimeManagerObserver.OnVisibleRangeChanged(MoCapCore.cTimeManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the playback range changes.</summary>
        </member>
        <member name="M:MoCapCore.cITimeManagerObserver.OnPlayRangeChanged(MoCapCore.cTimeManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the playback range changes.</summary>
        </member>
        <member name="M:MoCapCore.cITimeManagerObserver.OnAnimationRangeChanged(MoCapCore.cTimeManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the valid animation range changes.</summary>
        </member>
        <member name="M:MoCapCore.cITimeManagerObserver.OnTimeStepChanged(MoCapCore.cTimeManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the playback frame rate changes.</summary>
        </member>
        <member name="M:MoCapCore.cITimeManagerObserver.OnTimeChanged(MoCapCore.cTimeManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
            <summary>
Called when the playback head time changes. Also passes what the time was before this
latest change.
</summary>
        </member>
        <member name="T:MoCapCore.cITimeManagerObserver">
            <summary>
Derive from this class and add yourself as an observer to TimeManager to be notified when changes
occur to TimeManager.
</summary>
        </member>
        <member name="M:Core.cThreadHelpers.ThreadID">
            <summary>Returns a unique ID for the calling thread.</summary>
        </member>
        <member name="M:Core.cThreadHelpers.Sleep(System.Int32)">
            <summary>Relinquish the CPU and wait for the given time on the caller's thread.</summary>
        </member>
        <member name="T:Core.cThreadHelpers">
            <summary>A collection of useful thread-related functions.</summary>
        </member>
        <member name="M:Core.cThread.Process">
            <summary>
Override this method to define the functionality that should run each time the thread wakes up and runs
either through continuous running, or via a call to RunOnce().
</summary>
        </member>
        <member name="M:Core.cThread.LoopWait">
            <summary>Get the current wait time between Process() calls when running.</summary>
        </member>
        <member name="M:Core.cThread.Priority">
            <summary>Get the current thread priority.</summary>
        </member>
        <member name="M:Core.cThread.IsRunning">
            <summary>Returns true if the thread is running continuously (i.e. not in RunOnce mode).</summary>
        </member>
        <member name="M:Core.cThread.Stop">
            <summary>Stop the thread (i.e. kill the thread). This effectively destroys the internal thread and calling
Run() or RunOnce() can be called after this to recreate and restart the thread.</summary>
        </member>
        <member name="M:Core.cThread.Pause">
            <summary>Pause continuous running of the thread, placing the thread in a suspended state. Run() or 
RunOnce() can be called after this.</summary>
        </member>
        <member name="M:Core.cThread.RunOnce">
            <summary>Run the processing method once (asynchronously) on this thread, then suspend the thread.
The thread will remain active in between calls to RunOnce(), but be in a suspended state. To terminate
the thread, call Stop().</summary>
        </member>
        <member name="M:Core.cThread.Run">
            <summary>Run the processing method continuously until Pause is called or the thread is
destroyed.</summary>
        </member>
        <member name="M:Core.cThread.SetLoopWait(System.Int32)">
            <summary>Set the amount of time to wait between calls to Process() when running continuously.</summary>
        </member>
        <member name="M:Core.cThread.SetPriority(Core.cThread.eThreadPriority)">
            <summary>Set the thread priority. May be called at any time.</summary>
        </member>
        <member name="T:Core.cThread">
            <summary>
A platform-neutral thread. Derive from this class and override the Process() method to define functionality
that should run each time the thread wakes up. This class manages a separate thread, but is not thread-safe
so methods on this class should be called from a single thread for each cThread instance.
</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.GetDefaultSessionDirectory">
            <summary>Get the default session directory.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.PrimarySelectedTake">
            <summary>Convenience method to retrieve the primary selected take in the current session.</summary>
            <returns>An invalid ID if no take is selected in the current session.</returns>
        </member>
        <member name="M:MoCapCore.cTakeManager.SelectedTakes(std.vector&lt;Core.cUID,std.allocator&lt;Core.cUID&gt;&gt;*)">
            <summary>Convenience method to retrieve the composite list of ID's of selected takes across all sessions.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.ClearSelectedTakes">
            <summary>De-selects all selected takes.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.SeedTake">
            <summary>
Access the "seed" take that is used as the master when populating a new take for recording.
</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.FindTake(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Search a take with the given file path.
</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.FindTake(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Search among all sessions, starting with the current session, to locate the take with the given
ID.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.FindTake(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Search to find a take with the given name that belongs to the session with the given ID.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.RewriteTake(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;Core.cICameraFrameFactory&gt;,Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Boolean)">
            <summary>Overwrites an existing take with a new take that has the given property adjustments.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.MoveCopySession(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Moves/Copies the Session with the given ID to another session.</summary>
            <returns>True if the session is moved/Copied.</returns>
        </member>
        <member name="M:MoCapCore.cTakeManager.CopyTake(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Copies the take with the given ID from one session to another.</summary>
            <returns>True if the take was found and copied.</returns>
        </member>
        <member name="M:MoCapCore.cTakeManager.MoveTake(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Moves the take with the given ID from one session to another.</summary>
            <returns>True if the take was found and moved.</returns>
        </member>
        <member name="M:MoCapCore.cTakeManager.RemoveTake(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
            <summary>
Search among all sessions, starting with the current session, and attempt to find and remove
the take with the given ID.
</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.SetEditableCurrentTake">
            <summary>
Attempts to set the current take to the non-seed take that was last current. If a valid
choice can't be found, the current take is set to the seed take and false is returned.
</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.SetCurrentTake(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Search among all sessions to locate the take with the given ID, setting it as the current take if found.
</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.CurrentTake">
            <summary>convenience method for retrieving the current take from the current session.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.PopulateEmptyTake">
            <summary>
Use the current suggested take name to either locate an existing (empty) take or create a new take.
</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.AddTake(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Convenience method for adding a new take to a given session. If the take doesn't already exist, the
given suggested take name is used as the seed for the name of the new take, but the caller should
query the Name property of the take that is returned to get the final name.
</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.AddTake(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Add a new or existing take, also adding any parent sessions that are needed. The passed
filename should be a full path and filename.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.SuggestedTakeName">
            <summary>Retrieve the current suggested take name.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.SetSuggestedTakeName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Set the suggested name to use for the next new take. The name may be augmented to make it
unique before actually creating a take.
</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.TopLevelSessions(std.vector&lt;MoCapCore.cSession**,std.allocator&lt;MoCapCore.cSession**&gt;&gt;*)">
            <summary>Retrieve a list of all top-level sessions (i.e. sessions with no parent).</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.AllSessions(std.vector&lt;MoCapCore.cSession**,std.allocator&lt;MoCapCore.cSession**&gt;&gt;*)">
            <summary>Retrieve a list of all existing sessions.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.SessionByIndex(System.UInt32)">
            <summary>Get a session by index. Returns the default session if index is out of range.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.SessionCount">
            <summary>Get the number of available sessions.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.ContainsCurrentSession(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if the given session is or contains the current recording session.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.CurrentSession">
            <summary>Get the current session.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.FindSession(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Find the session with the given path.</summary>
            <returns>The session, if found. NULL otherwise.</returns>
        </member>
        <member name="M:MoCapCore.cTakeManager.FindSession(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Find the session with the given name.</summary>
            <returns>The session, if found. NULL otherwise.</returns>
        </member>
        <member name="M:MoCapCore.cTakeManager.FindSession(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Find the session with the given ID.</summary>
            <returns>The session, if found. NULL otherwise.</returns>
        </member>
        <member name="M:MoCapCore.cTakeManager.SetCurrentSession(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Set the current session by session ID. The active take within the session will also be
set as the active take if the active session is changed through this call.
</summary>
            <returns>True if the session was found and set current.</returns>
        </member>
        <member name="M:MoCapCore.cTakeManager.RemoveSession(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>
Remove the session with the given ID. Sessions that still contain takes cannot be deleted
until all takes have either been moved to another session, or removed from the session. At
least one session must always exist, so the last session may not be deleted. Use Clear() to
remove all current sessions and reset to a fresh state.
</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.AddSession(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Add a new session with the given path. The session will be created if it does not
already exist, or just returned if it does.</summary>
            <param name="makeCurrent">If true, the named session will be set as the current session.</param>
            <param name="makeUnique">If true, the input session name may be adjusted in order to make
the session unique on the file system.</param>
        </member>
        <member name="M:MoCapCore.cTakeManager.PlaybackType">
            <summary>Retrieve the current playback type. If the current take is the seed take (i.e. we are
in Live mode, the playback type is always None.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.SetPlaybackType(MoCapCore.cTakeManager.ePlaybackType)">
            <summary>Sets the playback type. Using 2D playback mode is known as "debug" mode.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.IsDirty">
            <summary>Returns true if any session or takes have changed since last save/load.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.SaveDirtyTakes">
            <summary>Save any unsaved or changed (dirty) takes.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.ResumeNotifications">
            <summary>Resume notifications and emit any notifications that accrued since suspended.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.SuspendNotifications">
            <summary>Suspend all notifications and start keeping track of which ones need to fire.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.Empty">
            <summary>Returns true if there are no available takes in any sessions.</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.Clear(System.Boolean)">
            <summary>
Clears all sessions and takes. If createDefaultSession is true, a new default session will be
created during clearing, which is usually what you want. Only those that will be immediately adding
at least one session should consider calling this method with createDefaultSession set to false.
</summary>
        </member>
        <member name="M:MoCapCore.cTakeManager.#ctor(std.shared_ptr&lt;MoCapCore.cIStreamsManager&gt;,std.shared_ptr&lt;Core.cICameraFrameFactory&gt;,std.shared_ptr&lt;MoCapCore.cIChannelFactoryWarehouse&gt;,std.shared_ptr&lt;MoCapCore.cINodeFactoryWarehouse&gt;,std.shared_ptr&lt;MoCapCore.cIPropertyProvider&gt;,std.shared_ptr&lt;MoCapCore.cILegacyTakeLoader&gt;)">
            <summary>Create a new TakeManager. Ownership of the take factory is transfered to this object.</summary>
        </member>
        <member name="T:MoCapCore.cTakeManager">
            <summary>
A class for managing sessions, take loading, session and take creation, and take application.
</summary>
        </member>
        <member name="M:MoCapCore.cITakeManagerObserver.OnTakeListChanged(MoCapCore.cTakeManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cSession!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the take list for a specific session has changed.</summary>
        </member>
        <member name="M:MoCapCore.cITakeManagerObserver.OnSessionUpdated(MoCapCore.cTakeManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cSession!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when session is updated.</summary>
        </member>
        <member name="M:MoCapCore.cITakeManagerObserver.OnSelectedTakeListChanged(MoCapCore.cTakeManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the list of selected takes changed.</summary>
        </member>
        <member name="M:MoCapCore.cITakeManagerObserver.OnSuggestedTakeNameChanged(MoCapCore.cTakeManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called anytime the suggested take name is altered.</summary>
        </member>
        <member name="M:MoCapCore.cITakeManagerObserver.OnSessionListChanged(MoCapCore.cTakeManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called after sessions are added to or removed from the loaded sessions list.</summary>
        </member>
        <member name="M:MoCapCore.cITakeManagerObserver.OnPlaybackTypeChanged(MoCapCore.cTakeManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the run mode changes.</summary>
        </member>
        <member name="M:MoCapCore.cITakeManagerObserver.OnTakeListChanged(MoCapCore.cTakeManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called after takes are added to or removed from the loaded takes list.</summary>
        </member>
        <member name="M:MoCapCore.cITakeManagerObserver.OnCurrentSessionChanged(MoCapCore.cTakeManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the current session has been swapped out.</summary>
        </member>
        <member name="M:MoCapCore.cITakeManagerObserver.OnCurrentTakeChanged(MoCapCore.cTakeManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the current take has been swapped out.</summary>
        </member>
        <member name="M:MoCapCore.cITakeManagerObserver.OnCurrentTakeChanging(MoCapCore.cTakeManager!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the current take is about to change.</summary>
        </member>
        <member name="M:MoCapCore.cSession.AllChildSessions(std.vector&lt;MoCapCore.cSession**,std.allocator&lt;MoCapCore.cSession**&gt;&gt;*)">
            <summary>Retrieve the list of all child sessions.</summary>
        </member>
        <member name="M:MoCapCore.cSession.RemoveChild(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Attempt to remove the given child. Also sets its parent to null.</summary>
        </member>
        <member name="M:MoCapCore.cSession.AddChild(MoCapCore.cSession*)">
            <summary>Add a child session to this parent. Child must have no existing parent.</summary>
        </member>
        <member name="M:MoCapCore.cSession.ParentSession">
            <summary>
Returns parent session. All sessions displayed in tree have always parent. Top level session's parent
is tree root item (it is invisible in tree).
</summary>
        </member>
        <member name="M:MoCapCore.cSession.IsDescendentOf(MoCapCore.cSession!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if this session is descended from (or equal to) the given session.</summary>
        </member>
        <member name="M:MoCapCore.cSession.FindUniqueTakeName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Find a take name that is currently unique among takes in the session and on disk. The name will
use the given name as a seed starting point and append a suffix if needed to make it unique.
</summary>
        </member>
        <member name="M:MoCapCore.cSession.TopLevelParentID">
            <summary>Returns the ID of the top-most parent to this session, or its own ID if it has no parent.</summary>
        </member>
        <member name="M:MoCapCore.cSession.IsDirty">
            <summary>Returns true if any of the contained takes is dirty.</summary>
        </member>
        <member name="M:MoCapCore.cSession.Empty">
            <summary>Returns true if no data (takes) are present.</summary>
        </member>
        <member name="M:MoCapCore.cSession.UsingSeedTake">
            <summary>Returns true if the active take is the live (seed) take.</summary>
        </member>
        <member name="M:MoCapCore.cSession.PrimarySelectedTake">
            <summary>Retrieve the primary selected take, if any.</summary>
        </member>
        <member name="M:MoCapCore.cSession.SelectedTakes(std.vector&lt;Core.cUID,std.allocator&lt;Core.cUID&gt;&gt;*)">
            <summary>Retrieve any selected takes.</summary>
        </member>
        <member name="M:MoCapCore.cSession.AllTakes(std.vector&lt;MoCapCore.cTake**,std.allocator&lt;MoCapCore.cTake**&gt;&gt;*)">
            <summary>Retrieve a list of all takes currently contained in the session.</summary>
        </member>
        <member name="M:MoCapCore.cSession.TakeByIndex(System.UInt32)">
            <summary>Get a take by index, or the dummy take if index is out of range.</summary>
        </member>
        <member name="M:MoCapCore.cSession.TakeCount">
            <summary>Get the number of takes.</summary>
        </member>
        <member name="M:MoCapCore.cSession.FindEmptyTake(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Attempts to find an empty take in the session, starting at the take whose iD is given. Returns
NULL if none found.
</summary>
        </member>
        <member name="M:MoCapCore.cSession.FindEmptyTake(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;*)">
            <summary>
Finds an empty take with the proposed name, or applies the following criteria to find an existing take
with a modified name.
 * Currently active take is empty take, given name is same name - ok use it (do not create new take)
 * Currently active take is empty take, text box has different name - create new take with given name (autogen if empty)
 * Currently active take is non-empty take - name is same name - create new take with autogen name
 * Currently active take is non-empty take - name is different name - create new take with given name
</summary>
            <returns>The existing take, if an appropriate choice is found. If an existing take is not found, the ioProposedName
parameter is adjusted to an acceptable name for a new take if the caller chooses to create one.</returns>
        </member>
        <member name="M:MoCapCore.cSession.FindChildByFolderID(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Attempt to locate a child session in this session that has the given folder ID.</summary>
        </member>
        <member name="M:MoCapCore.cSession.FindTakeByFileID(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Attempt to locate a contained take by its file ID (the ID unique to the take's file on disk).</summary>
        </member>
        <member name="M:MoCapCore.cSession.FindTakeIndex(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*)">
            <summary>Finds the index within the take list of the given take. Returns false if not found.</summary>
        </member>
        <member name="M:MoCapCore.cSession.FindTake(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Attempt to find a take in this session with the given filename (including path).</summary>
            <returns>The take with the given label, or NULL if none found.</returns>
        </member>
        <member name="M:MoCapCore.cSession.FindTake(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Find the first take in the list with the given ID.</summary>
            <returns>The take with the given ID, or NULL if none found.</returns>
        </member>
        <member name="M:MoCapCore.cSession.FindTake(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Find the first take in the list with the given label. Labels are not required to be unique.</summary>
            <returns>The take with the given label, or NULL if none found.</returns>
        </member>
        <member name="M:MoCapCore.cSession.CurrentTake">
            <summary>Get the current take. This may be a dummy (but valid) take if no takes have been added.</summary>
        </member>
        <member name="M:MoCapCore.cSession.FolderID">
            <summary>Retrieve the unique identifier used to locate this session (folder) in the file system.</summary>
        </member>
        <member name="M:MoCapCore.cSession.ID">
            <summary>Get the unique ID for this session.</summary>
        </member>
        <member name="M:MoCapCore.cSession.Path">
            <summary>Get the full path to the session folder.</summary>
        </member>
        <member name="M:MoCapCore.cSession.Name">
            <summary>Get the name of this session (equivalent to the session folder name).</summary>
        </member>
        <member name="M:MoCapCore.cSession.ClearSelection">
            <summary>De-selects any selected takes.</summary>
        </member>
        <member name="M:MoCapCore.cSession.Clear">
            <summary>Removes all takes except the seed/dummy take.</summary>
        </member>
        <member name="M:MoCapCore.cSession.SetEditableCurrentTake">
            <summary>
Attempts to set the current take to the non-seed take that was last current. If a valid
choice can't be found, the current take is set to the seed take and false is returned.
</summary>
        </member>
        <member name="M:MoCapCore.cSession.SetCurrentTake(System.UInt32)">
            <summary>
Attempts to set the current take to the take at the given index in the current session.
</summary>
            <returns>True if the take was found and set current.</returns>
        </member>
        <member name="M:MoCapCore.cSession.SetCurrentTake(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the current take by take ID.</summary>
            <returns>True if the take was found and set current.</returns>
        </member>
        <member name="M:MoCapCore.cSession.SetCurrentTake(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Try to locate and set current the take with the given label. Labels are not required to be unique,
so this method sets current the first take found by this label.
</summary>
            <returns>True if the take was found and set current.</returns>
        </member>
        <member name="M:MoCapCore.cSession.IsTakeLabelDefault(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Whether the take label has been (most probably) generated here by GenerateTakeLabel().</summary>
        </member>
        <member name="M:MoCapCore.cSession.GenerateTakeLabel">
            <summary>Generate a unique take label within this session.</summary>
        </member>
        <member name="M:MoCapCore.cSession.MoveTake(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cSession*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Moves the take with the given index from the given session into this one.</summary>
            <returns>True if the take was found and moved.</returns>
        </member>
        <member name="M:MoCapCore.cSession.RemoveTake(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
            <summary>Remove the take with the given ID.</summary>
            <returns>True if the take was found and removed.</returns>
        </member>
        <member name="M:MoCapCore.cSession.AddTake(MoCapCore.cTake*,System.Boolean)">
            <summary>Add the given take.</summary>
        </member>
        <member name="M:MoCapCore.cSession.SetName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Set the name (which also sets the session folder name). Setting this value will cause
the session folder on disk to be renamed as well.
</summary>
        </member>
        <member name="M:MoCapCore.cSession.#ctor(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cTake*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Create a new session.</summary>
            <param name="requestedName">
Try to use this name for the new session. The system will attempt to use this name first,
then will hunt for a similar unique name if makeUnique is true. If no reasonable name can be
found then the name is set to blank.
</param>
        </member>
        <member name="T:MoCapCore.cSession">
            <summary>
Owns all takes within a session.
</summary>
        </member>
        <member name="M:MoCapCore.cISessionObserver.OnSelectedTakeListChanged(MoCapCore.cSession!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the list of selected takes in the session changes.</summary>
        </member>
        <member name="M:MoCapCore.cISessionObserver.OnTakeListChanged(MoCapCore.cSession!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when takes are added or removed from the takes list.</summary>
        </member>
        <member name="M:MoCapCore.cISessionObserver.OnCurrentTakeChanged(MoCapCore.cSession!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the current take is swapped out.</summary>
        </member>
        <member name="M:MoCapCore.cISessionObserver.OnCurrentTakeChanging(MoCapCore.cSession!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called just prior to swapping out the current take.</summary>
        </member>
        <member name="M:MoCapCore.cISessionObserver.OnNameChanged(MoCapCore.cSession!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the session name changes.</summary>
        </member>
        <member name="M:MoCapCore.cTake.LoadData(MoCapCore.cIDataStreamWarehouse*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Load take data from the given (already open) stream warehouse.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SaveData(MoCapCore.cIDataStreamWarehouse*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>
Save take data (nodes and calibration). Node animation data will only be available if the
take is open.
</summary>
        </member>
        <member name="M:MoCapCore.cTake.UpdateDataTypes">
            <summary>Forces an update of the internal data type meta-data based on data currently contained in the take.</summary>
        </member>
        <member name="M:MoCapCore.cTake.MarkClean">
            <summary>Mark the take as "clean" (i.e. not needing saving).</summary>
        </member>
        <member name="M:MoCapCore.cTake.MarkDirty">
            <summary>Mark the take as dirty and notify observers.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SetFrameRate(System.Double)">
            <summary>Set the master frame rate for this take.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SetSession(MoCapCore.cSession!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Sets the session this instance is attached to. Used to move takes between sessions.</summary>
        </member>
        <member name="M:MoCapCore.cTake.DefaultFileExtension">
            <summary>Returns the file extension to use when loading/saving (without the '.').</summary>
        </member>
        <member name="M:MoCapCore.cTake.FileID">
            <summary>Retrieve the unique file identifier that can be used to identify this take file
on the file system (file system dependent).</summary>
        </member>
        <member name="M:MoCapCore.cTake.IsOpen">
            <summary>Returns true if the take is fully loaded from disk. Will be false if only meta-data is loaded.</summary>
        </member>
        <member name="M:MoCapCore.cTake.IsDirty">
            <summary>Returns true if data has changed since last save, or the take has not been saved.</summary>
        </member>
        <member name="M:MoCapCore.cTake.FileExtension">
            <summary>Get the file extension used when loading/saving.</summary>
        </member>
        <member name="M:MoCapCore.cTake.FileName">
            <summary>Get the full filename (with path and extension) to use for this take.</summary>
        </member>
        <member name="M:MoCapCore.cTake.Close(System.Boolean,System.Boolean)">
            <summary>Close the take, but retain meta-data. Saves if saveIfNeeded is true and IsDirty is true.</summary>
        </member>
        <member name="M:MoCapCore.cTake.Open">
            <summary>Load from the filename given by FileName().</summary>
        </member>
        <member name="M:MoCapCore.cTake.SaveTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cIDataStreamWarehouse*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32)">
            <summary>
Save to an arbitrary filename. Does not change name or filename. The passed stream
warehouse must not be open and will only be used if the requested filename does not match
the current take filename.
</summary>
        </member>
        <member name="M:MoCapCore.cTake.Save(System.Boolean)">
            <summary>Save to our persistence stream if data has changed.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SetProgressIndicator(System.UInt32)">
            <summary>Progress indicator.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SetHealthIndicator(System.UInt32)">
            <summary>Health indicator</summary>
        </member>
        <member name="M:MoCapCore.cTake.ToTime(System.Int32)">
            <summary>Convert a frame to a time, using the current time and frame range.</summary>
        </member>
        <member name="M:MoCapCore.cTake.ToTimeCode(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Convert a frame number to timecode, if available. The returned timecode structure
will have its Invalid flag set if no timecode is available.
</summary>
        </member>
        <member name="M:MoCapCore.cTake.FractionalFrame(Core.cTime!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Convert a time to a fractional frame value based on the current take time range.</summary>
        </member>
        <member name="M:MoCapCore.cTake.AssetList">
            <summary>A string representing the names of the assets in the take.</summary>
        </member>
        <member name="M:MoCapCore.cTake.CaptureStartTime">
            <summary>Retrieve the time (date/time) when the take was captured.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SetCaptureStartTime(QDateTime!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set captured frame rate</summary>
        </member>
        <member name="M:MoCapCore.cTake.HasGaps">
            <summary>
Determines whether there are any gaps in reconstructed data. Will be false if data has not been
reconstructed yet.
</summary>
        </member>
        <member name="M:MoCapCore.cTake.IsBest">
            <summary>Get best.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SetBest(System.Boolean)">
            <summary>Set best.</summary>
        </member>
        <member name="M:MoCapCore.cTake.Notes">
            <summary>Get user notes.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SetNotes(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set user notes.</summary>
        </member>
        <member name="M:MoCapCore.cTake.HasData(System.Int32)">
            <summary>
Returns true if data of the requested type is present. If AllData is requested, true will
be returned if any data types are present.
</summary>
        </member>
        <member name="M:MoCapCore.cTake.DataTypes">
            <summary>Retrieve which types of data are present.</summary>
        </member>
        <member name="M:MoCapCore.cTake.FullTimeRange">
            <summary>Retrieves the full time range of all 2D/3D data.</summary>
        </member>
        <member name="M:MoCapCore.cTake.WorkingFrameRange">
            <summary>Retrieves the working frame range of all 2D/3D data.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SetWorkingFrameRange(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the working range to use for this take. Must be a strict sub-range of the full
animation range.</summary>
        </member>
        <member name="M:MoCapCore.cTake.FullFrameRange">
            <summary>Retrieves the full frame range of all 2D/3D data.</summary>
        </member>
        <member name="M:MoCapCore.cTake.FrameRate">
            <summary>Returns the master frame rate (in frames per second).</summary>
        </member>
        <member name="M:MoCapCore.cTake.FrameTime">
            <summary>Returns the master frame time (in seconds per frame).</summary>
        </member>
        <member name="M:MoCapCore.cTake.Track(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;)">
            <summary>Retrieve the track with the given name, or NULL if none.</summary>
        </member>
        <member name="M:MoCapCore.cTake.Track(System.UInt32)">
            <summary>Retrieve the track at the given index, or NULL if none.</summary>
        </member>
        <member name="M:MoCapCore.cTake.TrackCount">
            <summary>Returns the current track count.</summary>
        </member>
        <member name="M:MoCapCore.cTake.AddTrack(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;)">
            <summary>Allocates a new track and returns the new instance. Ownership remains with the take.</summary>
        </member>
        <member name="M:MoCapCore.cTake.Selected">
            <summary>Retrieve the selection state.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SetSelected(System.Boolean)">
            <summary>Set the selection state.</summary>
        </member>
        <member name="M:MoCapCore.cTake.ReconstructionBounds">
Calculate the current reconstruction bounds based on values of the reconstruction properties.
</member>
        <member name="M:MoCapCore.cTake.HasAnimation">
            <summary>Returns true if there is no time-series data present.</summary>
        </member>
        <member name="M:MoCapCore.cTake.Empty">
            <summary>Returns true if there is are no nodes, and no time-series data present.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SetCameraCalibration(MoCapCore.cCameraCalibration!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the calibration. Ownership of the passed pointer is transferred to this object.</summary>
        </member>
        <member name="M:MoCapCore.cTake.DataWarehouse">
            <summary>Access to the contained DataWarehouse.</summary>
        </member>
        <member name="M:MoCapCore.cTake.NodeWarehouse">
            <summary>Access to the contained NodeWarehouse.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SessionID">
            <summary>The session ID for the session that contains this take.</summary>
        </member>
        <member name="M:MoCapCore.cTake.ID">
            <summary>Unique ID.</summary>
        </member>
        <member name="M:MoCapCore.cTake.Name">
            <summary>Get the human-readable label to use for this take.</summary>
        </member>
        <member name="M:MoCapCore.cTake.ShiftAnimation(System.Int32!System.Runtime.CompilerServices.IsConst)">
            <summary>Shift all animation data by the given amount. A positive shift means resulting frame numbers will
have increased.</summary>
        </member>
        <member name="M:MoCapCore.cTake.ClearAnimation(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
            <summary>Clear all animation data over the given range.</summary>
        </member>
        <member name="M:MoCapCore.cTake.Clear">
            <summary>Clear all nodes, calibration info, etc. and reset to a default state.</summary>
        </member>
        <member name="M:MoCapCore.cTake.SetName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Set the name. Since names are the same as filenames and takes are stored in session folders,
cTake names must be unique within a session. Responsibility for this is delegated to the TakeManager.
</summary>
        </member>
        <member name="M:MoCapCore.cTake.FinishEdit">
            <summary>Finish an editing operation and send out any missed notifications.</summary>
        </member>
        <member name="M:MoCapCore.cTake.StartEdit">
            <summary>Suspend notifications so that a complex operation can be performed on the take.</summary>
        </member>
        <member name="M:MoCapCore.cTake.CopyFrom(MoCapCore.cTake!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Copies calibration and node warehouse from the given take and replaces them on this instance.
This method may only be used to populate an empty take.</summary>
            <param name="excludeInactiveNodes">If true, inactive nodes will not be cloned in the copy</param>
        </member>
        <member name="M:MoCapCore.cTake.Clone(MoCapCore.cSession!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cIDataStreamWarehouse*,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>
Creates a clone of this instance with a new unique ID. A new cIDataStreamWarehouse must also be passed
in since there is no sharing of those instances.
<param name="excludeInactiveNodes">If true, inactive nodes will not be cloned in the copy</param></summary>
        </member>
        <member name="M:MoCapCore.cTake.Initialize(MoCapCore.cSession!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cIDataStreamWarehouse*,std.shared_ptr&lt;Core.cICameraFrameFactory&gt;,std.shared_ptr&lt;MoCapCore.cIChannelFactoryWarehouse&gt;,std.shared_ptr&lt;MoCapCore.cINodeFactoryWarehouse&gt;,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Call to initialize and associate with an existing stream on disk. Ownership of the cIDataStreamWarehouse
instance is transferred here.
</summary>
        </member>
        <member name="M:MoCapCore.cTake.Initialize(std.shared_ptr&lt;Core.cICameraFrameFactory&gt;,std.shared_ptr&lt;MoCapCore.cIChannelFactoryWarehouse&gt;,std.shared_ptr&lt;MoCapCore.cINodeFactoryWarehouse&gt;)">
            <summary>Call to initialize a new instance.</summary>
        </member>
        <member name="T:MoCapCore.cTake">
            <summary>
Owns all animation data for a take, as well as setup info for cameras (calibration, etc.).
This class supports deferred loading and serialization of a take.
</summary>
        </member>
        <member name="M:MoCapCore.cITakeObserver.OnOpenedChanged(MoCapCore.cTake!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the open state has changed.</summary>
        </member>
        <member name="M:MoCapCore.cITakeObserver.OnDirtyChanged(MoCapCore.cTake!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the dirty (saved) state has changed.</summary>
        </member>
        <member name="M:MoCapCore.cITakeObserver.OnDataTypesChanged(MoCapCore.cTake!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the types of data available have changed.</summary>
        </member>
        <member name="M:MoCapCore.cITakeObserver.OnReconstructionSettingsChanged(MoCapCore.cTake!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the reconstruction settings change.</summary>
        </member>
        <member name="M:MoCapCore.cITakeObserver.OnCalibrationChanged(MoCapCore.cTake!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the camera calibration changes.</summary>
        </member>
        <member name="M:MoCapCore.cITakeObserver.OnTrackListChanged(MoCapCore.cTake!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the track list changes.</summary>
        </member>
        <member name="M:MoCapCore.cITakeObserver.OnFrameRangeChanged(MoCapCore.cTake!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the extents of the time range for this take change.</summary>
        </member>
        <member name="M:MoCapCore.cITakeObserver.OnSelectedChanged(MoCapCore.cTake!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the selection state has changed.</summary>
        </member>
        <member name="M:MoCapCore.cITakeObserver.OnNameChanged(MoCapCore.cTake!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the name (thus the filename) associated with the take is changed.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.HashCode">
            <summary>Returns a hash code that changes anytime data in the node warehouse changes.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.HashCodeOfType(System.Int32)">
            <summary>Returns a hash code that will remain the same until the list of the queried type changes.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.FindNodeByLabel(Core.cLabel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Find a node by label. Returns non-null only for nodes that have a valid label.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.FindNodeByName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Find a node by name.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.FindNodeByID(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Find a node by ID.</summary>
            <returns>The requested node, or NULL if not found.</returns>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.KeyedSelectedNodesOfType(System.Int32,Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;MoCapCore.cINode**,std.allocator&lt;MoCapCore.cINode**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Retrieve the list of all selected nodes of the requested type in the scene.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.KeyedSelectedNodesOfType(System.Int32,System.Int32,std.vector&lt;MoCapCore.cINode**,std.allocator&lt;MoCapCore.cINode**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Retrieve the list of all selected nodes of the requested type in the scene.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.HasKeyedNodesOfType(System.Int32,Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if nodes of the requested type exist.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.KeyedNodesOfType(System.Int32,Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;MoCapCore.cINode**,std.allocator&lt;MoCapCore.cINode**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Get a list of all nodes of a requested type that have keys within the given range.</summary>
            <param name="range">The time range within which to search for keyed nodes.</param>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.KeyedNodesOfType(System.Int32,System.Int32,std.vector&lt;MoCapCore.cINode**,std.allocator&lt;MoCapCore.cINode**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Get a list of all nodes of a requested type that have keys at the given frame. When querying 
for a single frame, this method is more efficient than the same-named method that takes a range.</summary>
            <param name="frame">The frame at which to search for keyed nodes.</param>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.HasNodesOfType(System.Int32)">
            <summary>Returns true if nodes of the requested type exist.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.NodeOfTypeByName(System.Int32,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns the (first) typed node with the requested name in the array of nodes of that type, or NULL if
the requested name is not found.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.NodeCountOfType(System.Int32)">
            <summary>Returns the number of nodes of the requested type that currently exist.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.HasSelectedNodesOfType(System.Int32)">
            <summary>Return true if any nodes in the typed node list are selected.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.PrimarySelectedNodeOfType(System.Int32)">
            <summary>Retrieve the primary selected node of a given type.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.SetPrimarySelectedNodeOfType(System.Int32,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Sets the given node as the primary selected node of the requested filter type. If the node is not already selected,
it is first selected.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.PrimarySelectedNode">
            <summary>Returns the primary selected node, if any.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.SelectedNodeCountOfType(System.Int32)">
            <summary>Retrieve the number of selected nodes of a requested type.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.SelectedNodesOfType(System.Int32,std.vector&lt;MoCapCore.cINode**,std.allocator&lt;MoCapCore.cINode**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Retrieve the list of all selected nodes of the requested type in the scene.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.HasSelectedNodes">
            <summary>Return true if any nodes are selected.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.AllSelectedNodes(std.vector&lt;MoCapCore.cINode**,std.allocator&lt;MoCapCore.cINode**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns the list of all selected nodes in the scene.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.AllNodesOfType(System.Int32,std.vector&lt;MoCapCore.cINode**,std.allocator&lt;MoCapCore.cINode**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Request the full list of objects of the requested type.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.AllNodes(std.vector&lt;MoCapCore.cINode**,std.allocator&lt;MoCapCore.cINode**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns the list of all nodes in the scene.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.Empty">
            <summary>Returns true if no nodes are present.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.FullFrameRange">
            <summary>Calculate the full frame range for all nodes in the scene.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.ClearSelectionOfType(System.Int32)">
            <summary>Deselect all items that are of the given type.</summary>
            <returns>True if any selection state was changed.</returns>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.ClearSelection">
            <summary>Deselect all items in the scene.</summary>
            <returns>True if any selection state was changed.</returns>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.HasAnimation">
            <summary>Returns true if animation exists on any nodes.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.ClearAnimationOfType(System.Int32,Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Removes all animation data for all nodes of requested type within the given time range.</summary>
            <param name="range">Range to operate over.</param>
            <param name="deleteEmptyNodes">If true, any nodes that do not have animation on them after clearing the requested
data range will be deleted.</param>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.ClearAnimation(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Removes all animation data for all nodes within the given time range.</summary>
            <param name="range">Range to operate over.</param>
            <param name="deleteEmptyNodes">If true, any nodes that do not have animation on them after clearing the requested
data range will be deleted.</param>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.ClearOfType(System.Int32)">
            <summary>Removes all nodes that pass the given filter.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.Clear(System.Boolean)">
            <summary>Removes all nodes.</summary>
            <returns>The number of nodes removed.</returns>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.Apply(System.Int32,std.function&lt;(MoCapCore.cINode*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)(MoCapCore.cINode*!System.Runtime.CompilerServices.IsImplicitlyDereferenced&amp;)&gt;)">
            <summary>Apply the given function to a filtered set of nodes.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.Apply(std.function&lt;(MoCapCore.cINode*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)(MoCapCore.cINode*!System.Runtime.CompilerServices.IsImplicitlyDereferenced&amp;)&gt;)">
            <summary>Apply the given function to all nodes in the warehouse.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.RemoveNodes(std.unordered_set&lt;Core.cUID,std.hash{Core.cUID},std.equal_to&lt;Core.cUID&gt;,std.allocator&lt;Core.cUID&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Efficiently remove a set of nodes from the warehouse.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.RemoveNode(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Removes the node with the given ID.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.NodePassesFilter(System.Int32,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Locates the requested filter and tests the given node against it to determine if it passes.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.ClearAllNodeFilters">
            <summary>Clears and deletes all node filters. Since this is a static, class-wide resource, instances
created after this call will have no filters available unless filters are re-added.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.FindFilterID(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Attempt to find the ID of a filter with the given name. Returns 0 if not found.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.AddNodeFilter(std.unique_ptr&lt;MoCapCore.cINodeFilter,std.default_delete&lt;MoCapCore.cINodeFilter&gt;&gt;)">
            <summary>Add a node filter. This will create a cached list of nodes that pass the filter, and will maintain it
as nodes are added to or removed from the warehouse.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.CreateAndAddNode(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Create and add a node of the requested type. This is a convenience wrapper around the
node factory warehouse. Returns the created node.</summary>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.AddNode(std.unique_ptr&lt;MoCapCore.cINode,std.default_delete&lt;MoCapCore.cINode&gt;&gt;)">
            <summary>Add a node to the scene.
The scene takes ownership of the node at this point. Node ID's must be unique within a scene,
so attempts to add multiple nodes with the same ID will fail.</summary>
            <returns>True if the node was added to the scene.</returns>
        </member>
        <member name="M:MoCapCore.cNodeWarehouse.Load(Core.cIReader*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
De-serialize this object from the given reader.
</member>
        <member name="M:MoCapCore.cNodeWarehouse.Save(Core.cIWriter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Serialize this object to the given writer.
</member>
        <member name="M:MoCapCore.cNodeWarehouse.IsEditing">
Check to see if the scene is being edited.
</member>
        <member name="M:MoCapCore.cNodeWarehouse.FinishEdit">
Finish an editing operation and send out any missed notifications.
</member>
        <member name="M:MoCapCore.cNodeWarehouse.StartEdit">
Suspend notifications so that a complex operation can be performed on the take.
</member>
        <member name="T:MoCapCore.cNodeWarehouse">
            <summary>Manages all 3D objects in the scene. It owns all items in the scene and is responsible for their deletion.</summary>
        </member>
        <member name="M:MoCapCore.cINodeWarehouseObserver.OnNodeChannelListChanged(MoCapCore.cNodeWarehouse!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;Core.cUID,std.allocator&lt;Core.cUID&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called when a node's channel List changes.
</member>
        <member name="M:MoCapCore.cINodeWarehouseObserver.OnVisibilityChanged(MoCapCore.cNodeWarehouse!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;Core.cUID,std.allocator&lt;Core.cUID&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called when node's visibility changes.
</member>
        <member name="M:MoCapCore.cINodeWarehouseObserver.OnNodeNameChanged(MoCapCore.cNodeWarehouse!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;Core.cUID,std.allocator&lt;Core.cUID&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called when a node's name changes.
</member>
        <member name="M:MoCapCore.cINodeWarehouseObserver.OnNodeDataChanged(MoCapCore.cNodeWarehouse!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;Core.cUID,std.allocator&lt;Core.cUID&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called when the channel data of any node change.
</member>
        <member name="M:MoCapCore.cINodeWarehouseObserver.OnFrameRangeChanged(MoCapCore.cNodeWarehouse!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called when the animation extents of any node change.
</member>
        <member name="M:MoCapCore.cINodeWarehouseObserver.OnNodeHierarchyChanged(MoCapCore.cNodeWarehouse!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;Core.cUID,std.allocator&lt;Core.cUID&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called when the scene hierarchy changes.
</member>
        <member name="M:MoCapCore.cINodeWarehouseObserver.OnSelectionChanged(MoCapCore.cNodeWarehouse!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;Core.cUID,std.allocator&lt;Core.cUID&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called when selection state for one or more items in the scene changes.
</member>
        <member name="M:MoCapCore.cINodeWarehouseObserver.OnNodeListChanged(MoCapCore.cNodeWarehouse!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;Core.cUID,std.allocator&lt;Core.cUID&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Called when one or more nodes is added or removed.
</member>
        <member name="T:MoCapCore.cINodeWarehouseObserver">
            <summary>Observer class for node object types. Derive from this type in order to be notified of changes
to any nodes that you attach to as an observer.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.GenerateNewID">
            <summary>Generates a new ID for this object. This should only be called by the framework, and is
typically used to resolve ID conflicts.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.CopyTo(Core.cTMarker&lt;System.Single&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
            <summary>Copy the marker definition and translation data at the given frame into the given marker.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.Residual">
            <summary>Retrieve the current marker residual.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.SetResidual(System.Single)">
            <summary>Set the current residual value for this marker. This is only really applicable to live
markers, and this value is not stored in a channel, so cannot be animated.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.Size">
            <summary>Get the physical size of the marker.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.AddSizeSample(System.Single)">
            <summary>Adds a size sample to the averaged size for this marker.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.SetSize(System.Single)">
            <summary>Set the absolute physical size of this marker, replacing any sampled average size.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.IsMeasurement">
            <summary>True if this is a measurement point.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.IsActiveMarker">
            <summary>Returns true if this was recorded from an active marker.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.IsLabeled">
            <summary>Returns true if this marker has a valid label.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.Label">
            <summary>Return the label currently in use by this marker, if any.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.RemoveLabel">
            <summary>Removes any existing label without resetting the label warehouse that may be in use.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.SetLabel(Core.cLabel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Labels this marker. Pass cLabel::Invalid to unlabel a marker.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.FullName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst)">
            <summary>Returns the "full" name of the marker, which is the EntityName_MarkerName for labeled markers,
and simply the name for unlabeled markers.</summary>
        </member>
        <member name="M:MoCapCore.cMarkerNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;MoCapCore.cILabelWarehouse!System.Runtime.CompilerServices.IsConst&gt;,System.Boolean)">
            <summary>Create a new instance with an assigned ID.</summary>
        </member>
        <member name="M:MoCapCore.cIMarkerNodeObserver.OnLabelChanged(MoCapCore.cMarkerNode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cLabel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the node's name has changed.</summary>
        </member>
        <member name="T:MoCapCore.cIMarkerNodeObserver">
            <summary>
Observer class for marker node object types. Derive from this type in order to be notified of changes
to any markers that you attach to as an observer.
</summary>
        </member>
        <member name="T:MoCapCore.cTranslationNodeFactory">
            <summary>Factory class for cNode</summary>
        </member>
        <member name="T:MoCapCore.cTranslationNode">
            <summary>
Concrete implementation of a class that supports translation/rotation transform hierarchies.
</summary>
        </member>
        <member name="M:MoCapCore.cITransformSource.WorldTransform(System.Int32)">
            <summary>Returns the world-space transform at the given frame.</summary>
        </member>
        <member name="M:MoCapCore.cITransformSource.Transform(System.Int32)">
            <summary>Get the full (local) transform at the given time.</summary>
        </member>
        <member name="M:MoCapCore.cITransformSource.Rotation(System.Int32)">
            <summary>Get the local position at the given time.</summary>
        </member>
        <member name="M:MoCapCore.cITransformSource.Translation(System.Int32)">
            <summary>Get the local position at the given time.</summary>
        </member>
        <member name="M:MoCapCore.cITransformSource.SetRotation(System.Int32,Core.cQuaternion&lt;System.Single,true&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>A convenience method for setting local rotation. The default rotation will be set if no animation
channel exists.</summary>
            <returns>True if the key was set. False if a key was not set, but the default value was.</returns>
        </member>
        <member name="M:MoCapCore.cITransformSource.SetTranslation(System.Int32,Core.cVector3&lt;System.Single&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>A convenience method for setting local translation. The default translation value will be set if no
animation channel exists.</summary>
            <returns>True if the key was set. False if a key was not set, but the default value was.</returns>
        </member>
        <member name="T:MoCapCore.cITransformSource">
            <summary>
Abstract base class for all nodes in a scene.
</summary>
        </member>
        <member name="T:MoCapCore.cNodeFactory">
            <summary>Factory class for cNode</summary>
        </member>
        <member name="T:MoCapCore.cNode">
            <summary>Concrete implementation of the INode interface class. Nodes own channel instances and are channel providers.
 They are also property providers through the cPropertyCollection class.</summary>
        </member>
        <member name="M:MoCapCore.cINodeFilter.TestNode(MoCapCore.cINode!System.Runtime.CompilerServices.IsConst*)">
            <summary>Returns true if the given node passes this filter.</summary>
        </member>
        <member name="M:MoCapCore.cINodeFilter.TypeID">
            <summary>Return the type ID for this filter. This is an arbitrary value, but needs to be unique among filter types.</summary>
        </member>
        <member name="M:MoCapCore.cINodeFilter.Name">
            <summary>Returns the name for this filter. It can be any arbitrary value, but should be unique among filter types.</summary>
        </member>
        <member name="M:MoCapCore.cINodeFactory.CreateInstance(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Creates a new instance of the type. Ownership is transferred to caller.</summary>
        </member>
        <member name="M:MoCapCore.cINodeFactory.TypeName">
            <summary>The type name of the class that will be created by this factory.</summary>
        </member>
        <member name="M:MoCapCore.cINode.Visible">
            <summary>Get the current selection state.</summary>
        </member>
        <member name="M:MoCapCore.cINode.SetVisible(System.Boolean)">
            <summary>Set the visibility state.</summary>
        </member>
        <member name="M:MoCapCore.cINode.Selected">
            <summary>Get the current selection state.</summary>
        </member>
        <member name="M:MoCapCore.cINode.SetSelected(System.Boolean)">
            <summary>Set the selection state.</summary>
        </member>
        <member name="M:MoCapCore.cINode.Name">
            <summary>Get the internal identifier string.</summary>
        </member>
        <member name="M:MoCapCore.cINode.SetName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the internal identifier string used for this node.</summary>
            <returns>False if the name cannot be set (e.g. is read-only).</returns>
        </member>
        <member name="M:MoCapCore.cINode.FindByID(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Attempts to find a node with the given ID in the hierarchy of this node, including
this node.</summary>
        </member>
        <member name="M:MoCapCore.cINode.FindByName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Attempts to find a node with the given name in the hierarchy of this node, including
this node.</summary>
        </member>
        <member name="M:MoCapCore.cINode.PreviousSibling">
            <summary>Get the previous sibling to this node, if any.</summary>
        </member>
        <member name="M:MoCapCore.cINode.NextSibling">
            <summary>Get the next sibling to this node, if any.</summary>
        </member>
        <member name="M:MoCapCore.cINode.Parent">
            <summary>Get the current parent of this node.</summary>
            <returns>Pointer to current parent, or NULL if none.</returns>
        </member>
        <member name="M:MoCapCore.cINode.FirstChild">
            <summary>Retrieve the child at the given index.</summary>
        </member>
        <member name="M:MoCapCore.cINode.ChildCount">
            <summary>Counts and returns our number of children.</summary>
        </member>
        <member name="M:MoCapCore.cINode.HasChildren">
            <summary>Returns true if this node has children.</summary>
        </member>
        <member name="M:MoCapCore.cINode.RemoveChild(MoCapCore.cINode*)">
            <summary>Removes the given child from the child list for this node.</summary>
            <returns>True if the child was removed. False if the child cannot be removed, or is not a child.</returns>
        </member>
        <member name="M:MoCapCore.cINode.AddChild(MoCapCore.cINode*)">
            <summary>Add the given node as a child to this one. The given node will be removed from
any node hierarchy that it is presently part of. Certain node types may only be
added as descendants or children of certain other node types.</summary>
            <returns>True if the child was added. False if the child was previously added or cannot be.</returns>
        </member>
        <member name="M:MoCapCore.cINode.Load(Core.cIReader*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
De-serialize this object from the given reader.
</member>
        <member name="M:MoCapCore.cINode.Save(Core.cIWriter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Serialize this object to the given writer.
</member>
        <member name="M:MoCapCore.cINode.ID">
            <summary>A unique ID among the universe.</summary>
        </member>
        <member name="M:MoCapCore.cINode.Clone">
            <summary>Make a deep copy. The new copy will have the same ID as the original. This is typically
used to make copies of things like skeletons or other asset types when creating new takes from
existing ones.</summary>
        </member>
        <member name="M:MoCapCore.cINode.TypeName">
            <summary>Returns a class-specific type name that does not change over time. This is an internal
identifying name, not for display.</summary>
        </member>
        <member name="T:MoCapCore.cINode">
            <summary>
Abstract base class for all nodes in a scene.
</summary>
        </member>
        <member name="M:MoCapCore.cINodeObserver.OnChannelListChanged(MoCapCore.cINode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called on channel list change.</summary>
        </member>
        <member name="M:MoCapCore.cINodeObserver.OnDelete(MoCapCore.cINode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called just prior to deleting the node.</summary>
        </member>
        <member name="M:MoCapCore.cINodeObserver.OnParentChanged(MoCapCore.cINode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when this node's parent is switched.</summary>
        </member>
        <member name="M:MoCapCore.cINodeObserver.OnChildListChanged(MoCapCore.cINode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when a new child is added. Yippee!</summary>
        </member>
        <member name="M:MoCapCore.cINodeObserver.OnVisibleChanged(MoCapCore.cINode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the node's selection state has changed.</summary>
        </member>
        <member name="M:MoCapCore.cINodeObserver.OnSelectedChanged(MoCapCore.cINode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the node's selection state has changed.</summary>
        </member>
        <member name="M:MoCapCore.cINodeObserver.OnNameChanged(MoCapCore.cINode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the node's name has changed.</summary>
        </member>
        <member name="T:MoCapCore.cINodeObserver">
            <summary>
Observer class for node object types. Derive from this type in order to be notified of changes
to any nodes that you attach to as an observer.
</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.KeyFrameRange">
            <summary>Returns the frame range extents of all keys on all channels.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.IsKeyed(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if any channel keys exist in the given range.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.IsKeyed(System.Int32)">
            <summary>Returns true if any channel key exists at the given frame.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.Channel(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns the channel with the given name, or a dummy channel if there is no match.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.Apply(std.function&lt;(MoCapCore.cIChannel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)(MoCapCore.cIChannel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced&amp;)&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Apply the given functional to each of the channels in this provider.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.LiveChannels(std.vector&lt;std.shared_ptr&lt;MoCapCore.cIChannel&gt;,std.allocator&lt;std.shared_ptr&lt;MoCapCore.cIChannel&gt;&gt;&gt;*)">
            <summary>Retrieve the full live channel list as a vector of shared pointers.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.Channels(std.vector&lt;std.shared_ptr&lt;MoCapCore.cIChannel&gt;,std.allocator&lt;std.shared_ptr&lt;MoCapCore.cIChannel&gt;&gt;&gt;*)">
            <summary>Retrieve the full channel list as a vector of shared pointers.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.ChannelCount">
            <summary>Returns the number of channels available. Depending on the container type used to store the
channel list, this method could result in an O(n) count, so be careful not to use it in tight loops.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.HasChannel(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if a channel of the given type exists on this node.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.SetChannel(std.unique_ptr&lt;MoCapCore.cIChannel,std.default_delete&lt;MoCapCore.cIChannel&gt;&gt;)">
            <summary>Set one of the animation channels. Which channel gets set is governed by the Name()
of the given channel. If the name is not recognized as a pre-defined channel slot, the channel is still added as
a channel for the node.</summary>
            <returns>True if the given channel was a match for this node and was set as a channel.</returns>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.Clear(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Clear all animation data over the given range if selectedKeysOnly is false. Otherwise, only clears
selected keys within the given range.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.FinishEdit">
            <summary>Finish a started undo-able edit operation.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProvider.StartEdit">
            <summary>Start an undo-able edit operation.</summary>
        </member>
        <member name="T:MoCapCore.cIChannelProvider">
            <summary>Abstract base class for all nodes in a scene.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProviderObserver.OnChannelDataChanged(MoCapCore.cIChannelProvider!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>The animation data of the channel changed.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelProviderObserver.OnFrameRangeChanged(MoCapCore.cIChannelProvider!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>The animation range of the channel changed.</summary>
        </member>
        <member name="T:MoCapCore.cIChannelProviderObserver">
            <summary>Observer class for node object types. Derive from this type in order to be notified of changes
to any nodes that you attach to as an observer.</summary>
        </member>
        <member name="M:Core.cTimer.Elapsed">
            <summary>Get the current value of the timer (in secs).</summary>
        </member>
        <member name="M:Core.cTimer.CatchUp">
            <summary>Restarts the timer and returns the time (in secs) it had before the restart.</summary>
        </member>
        <member name="T:Core.cTimer">
            <summary>
A high-precision timer class for calculating elapsed times
Usage :
  cTimer timer;
  ...
  timer.Start()
  ...
  double elapsed = timer.Value();
</summary>
        </member>
        <member name="M:Core.cTimeRange.Intersects(Core.cTimeRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Returns true if the given range intersects this one. Intersection will be true even if only the
edges coincide.
</summary>
        </member>
        <member name="M:Core.cTimeRange.Contains(Core.cTime!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary>Returns true if this range includes the given time.</summary>
        </member>
        <member name="M:Core.cTimeRange.Contains(Core.cTimeRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if this range completely contains the given range.</summary>
        </member>
        <member name="M:Core.cTimeRange.Length">
            <summary>Returns the length (end time minus start time) of the range.</summary>
        </member>
        <member name="M:Core.cTimeRange.Center">
            <summary>Get the center point of the range.</summary>
        </member>
        <member name="M:Core.cTimeRange.End">
            <summary>Get the range start time.</summary>
        </member>
        <member name="M:Core.cTimeRange.Start">
            <summary>Get the range start time.</summary>
        </member>
        <member name="M:Core.cTimeRange.Empty">
            <summary>Returns true if the time range is empty (i.e. start time &gt; end time).</summary>
        </member>
        <member name="M:Core.cTimeRange.Intersect(Core.cTimeRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Intersects this range with the one given.</summary>
        </member>
        <member name="M:Core.cTimeRange.Clear">
            <summary>Clears the range to an empty range.</summary>
        </member>
        <member name="M:Core.cTimeRange.SetEnd(Core.cTime!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Set the end time of the range. If the range was previously empty, both start and end times
will be set to the given time.
</summary>
        </member>
        <member name="M:Core.cTimeRange.SetStart(Core.cTime!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Set the start time of the range. If the range was previously empty, both start and end times
will be set to the given time.
</summary>
        </member>
        <member name="T:Core.cTimeRange">
            <summary>Represents a range of time.</summary>
        </member>
        <member name="F:MoCapCore.cIProfileSubscriber.kGroupLabelInternal">
            <summary>Profile categories to display in UI.</summary>
        </member>
        <member name="M:MoCapCore.cIProfileSubscriber.ResetToDefault">
            <summary>Reset options/settings to their default values.</summary>
        </member>
        <member name="M:MoCapCore.cIProfileSubscriber.LoadFromProfile(tinyxml2wc.XMLElement!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>De-serialize this object from the given XML element.</summary>
        </member>
        <member name="M:MoCapCore.cIProfileSubscriber.SaveToProfile(tinyxml2wc.XMLElement*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Serialize this object to an XML element.</summary>
        </member>
        <member name="M:MoCapCore.cIProfileSubscriber.ProfileGroupLabel">
            <summary>A human-readable category of the information that this subscriber provide to display in UI.
This category will not be persisted with the user profile, and may change over time.</summary>
        </member>
        <member name="M:MoCapCore.cIProfileSubscriber.ProfileDescription">
            <summary>A human-readable description of the information that this subscriber provides.</summary>
        </member>
        <member name="M:MoCapCore.cIProfileSubscriber.ProfileLabel">
            <summary>A human-readable label to use for display in UI and other places. This label will not be persisted
with the user profile, and may change over time.</summary>
        </member>
        <member name="M:MoCapCore.cIProfileSubscriber.ProfileTypeName">
            <summary>Returns a class-specific subscriber type name that does not change over time. This is also
the section name that will be used when writing the XML content for this subscriber. This
name must be unique among subscribers added to the ProfileManager.</summary>
        </member>
        <member name="T:MoCapCore.cIProfileSubscriber">
            <summary>
Interface for all classes that would like to participate in the User Profile system.
</summary>
        </member>
        <member name="M:Core.cFilename.SetSuffixFormat(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Suffix format specifier:
[suffix root (required)][suffix value format specifier][suffix suffix (optional)]
</summary>
        </member>
        <member name="M:Core.cFilename.ConvertSeparators(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Converts path separators from the standard '/' to whatever the platform separator is.</summary>
        </member>
        <member name="M:Core.cFilename.AppendPathPart(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Appends a single path part to whatever path currently exists, without changing other contents.</summary>
        </member>
        <member name="M:Core.cFilename.AppendPath(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Appends the given path to this one. Both this and the given item must be paths.</summary>
        </member>
        <member name="M:Core.cFilename.Append(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Appends the given filename to this path. Given filename must be relative, and any existing
filename and extension will be overwritten with the incoming filename if successful.
</summary>
        </member>
        <member name="M:Core.cFilename.IsPath">
            <summary>Returns true if the contained information is just a path, not a full filename.</summary>
        </member>
        <member name="M:Core.cFilename.MakeAbsolute(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Make this path absolute, if it is relative. Absolute path is assumed to be relative to the
given path.</summary>
        </member>
        <member name="M:Core.cFilename.IsRelative">
            <summary>Returns true if the contained filename/path is relative (i.e. not absolute)</summary>
        </member>
        <member name="M:Core.cFilename.IsFilename">
            <summary>Returns true if this is a filename (with extension).</summary>
        </member>
        <member name="M:Core.cFilename.Delete">
            <summary>Attempt to delete any associated real file/folder that exists on disk.</summary>
        </member>
        <member name="M:Core.cFilename.Exists(System.Boolean)">
            <summary>Returns true if the file or folder exists on disk.</summary>
        </member>
        <member name="M:Core.cFilename.FullFilename">
            <summary>Get the full filename, including volume, path, and extension, if any.</summary>
        </member>
        <member name="M:Core.cFilename.FullName">
            <summary>Get the filename with no path information, but do include the extension, if any.</summary>
        </member>
        <member name="M:Core.cFilename.ExtensionMatches(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Compares extension with the given string and returns true if there is a match.
The passed string should not contain the period used to designate it as a file extension
</summary>
        </member>
        <member name="M:Core.cFilename.Extension">
            <summary>Get the file extension, if any.</summary>
        </member>
        <member name="M:Core.cFilename.Name">
            <summary>Base name (without any path or extension information).</summary>
        </member>
        <member name="M:Core.cFilename.FullPath">
            <summary>Get the full path with drive/volume designation, including a trailing path delimiter.</summary>
        </member>
        <member name="M:Core.cFilename.PathParts">
            <summary>Get the parts of the path as a vector of strings.</summary>
        </member>
        <member name="M:Core.cFilename.IncrementName">
            <summary>
Increments the name portion of the filename to the next incremental value using the given format
statement.
Name format:
[name][suffix root (required)][suffix value][suffix suffix (optional)]
</summary>
        </member>
        <member name="M:Core.cFilename.StripExtension">
            <summary>Strip off any extension that is present.</summary>
        </member>
        <member name="M:Core.cFilename.StripName">
            <summary>Strip off any filename and extension that are present.</summary>
        </member>
        <member name="M:Core.cFilename.StripVolume">
            <summary>Strip off any volume designation that is present.</summary>
        </member>
        <member name="M:Core.cFilename.PopPathPart">
            <summary>Pop one directory off the end of the path.</summary>
        </member>
        <member name="M:Core.cFilename.Path">
            <summary>Get the file path, excluding drive/volume designation, but with a trailing delimiter.</summary>
        </member>
        <member name="M:Core.cFilename.Volume">
            <summary>Drive/volume/server designation, excluding trailing path delimiter (e.g. "C:", "//Data")</summary>
        </member>
        <member name="M:Core.cFilename.Empty">
            <summary>Returns true if all components of the filename are empty.</summary>
        </member>
        <member name="M:Core.cFilename.Clear">
            <summary>Clears all data and resets to default values.</summary>
        </member>
        <member name="M:Core.cFilename.SetExtension(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the extension portion of the filename. Fails if the contained path is not a filename.</summary>
        </member>
        <member name="M:Core.cFilename.SetName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
            <summary>
Set just the Name portion of the filename (without extension). Passed string should have no path
separators. If renameOnDisk is true and the filename exists on disk, the file will be renamed
to match the given name. Returns false if the file could not be found or renamed when a rename
was requested.
</summary>
        </member>
        <member name="M:Core.cFilename.SetValue(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Parse a new filename.</summary>
        </member>
        <member name="T:Core.cFilename">
            <summary>Manages convenient ways to interact with filenames.</summary>
        </member>
        <member name="M:SkeletonSolver.CSkeletonSolver.ProcessTrajectories(System.Int32,SkeletonSolver.CLocalizeLabelHelper*,System.Single,System.Int32,System.Single,System.Boolean,System.Boolean,System.Boolean)">
iMaxMissingFrameToConnect:  Labels a marker if there is a candidate within iMaxMissingFrameToConnect frames.
fMaxFrameToFrameDist:       Labels a marker if the distance from the previous frame is less than this value.
</member>
        <member name="M:SkeletonSolver.cISkeletonSolverObserver.OnSkeletonMarkerChange(SkeletonSolver.CSkeletonSolver!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SkeletonSolver.CSkeleton*)">
            <summary>Called when the list of markers attached to a skeleton changes.</summary>
        </member>
        <member name="M:SkeletonSolver.cISkeletonSolverObserver.OnSkeletonListChange(SkeletonSolver.CSkeletonSolver!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the skeleton list changes.</summary>
        </member>
        <member name="M:Core.cRayBundle.HasReconstructionRays(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if there are assigned rays present for the given reconstruction.</summary>
        </member>
        <member name="M:Core.cRayBundle.ReconstructionRays(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Return an iterator pair for the rays that contribute to the given reconstruction.
</summary>
        </member>
        <member name="M:Core.cRayBundle.HasUnassignedRays">
            <summary>Returns true if there are assigned rays present.</summary>
        </member>
        <member name="M:Core.cRayBundle.UnassignedRays">
            <summary>Retrieve begin/end iterators for the unassigned rays (rays that are NOT assigned to markers).</summary>
        </member>
        <member name="M:Core.cRayBundle.HasAssignedRays">
            <summary>Returns true if there are assigned rays present.</summary>
        </member>
        <member name="M:Core.cRayBundle.AssignedRays">
            <summary>Retrieve begin/end iterators for the assigned rays (rays that are assigned to markers).</summary>
        </member>
        <member name="M:Core.cRayBundle.HasRays">
            <summary>Returns true if there are rays present.</summary>
        </member>
        <member name="M:Core.cRayBundle.AllRays">
            <summary>Retrieve begin/end iterators for the full ray list.</summary>
        </member>
        <member name="M:Core.cRayBundle.SetRaysPresorted(std.vector&lt;Core.cCameraRay,std.allocator&lt;Core.cCameraRay&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Populate the rays for this frame instance. The passed array is a non-const reference
because it will be swapped with the internal array and cleared on return, without freeing memory.
That will allow memory to be reused when possible.

This array is presorted by cUID for tracked rays with untracked rays following.
</summary>
        </member>
        <member name="M:Core.cRayBundle.SetRays(std.vector&lt;Core.cCameraRay,std.allocator&lt;Core.cCameraRay&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Populate the rays for this frame instance. The passed array is a non-const reference
because it will be swapped with the internal array and cleared on return, without freeing memory.
That will allow memory to be reused when possible.
</summary>
        </member>
        <member name="M:Core.cRayBundle.op_Assign(Core.cRayBundle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Assignment operator.</summary>
        </member>
        <member name="T:Core.cRayBundle">
            <summary>
A container class that holds a collection of rays and caches some state information on them
for fast computational access to lists of markers that meet certain criteria.
</summary>
        </member>
        <member name="M:Core.cIDataTypeBundle.Hash">
            <summary>Returns a hash that is unique to this instance of this type of data bundle. Uniqueness is not
guaranteed between different types of bundles.</summary>
        </member>
        <member name="M:Core.cIDataTypeBundle.Empty">
            <summary>Returns true if there are no rays in the bundle.</summary>
        </member>
        <member name="M:Core.cIDataTypeBundle.Clear">
            <summary>Clears all data and prepares this instance to be reused. This is useful for reusing memory
that has been previously allocated </summary>
        </member>
        <member name="M:Core.cIDataTypeBundle.TypeID">
            <summary>Return the type ID of the type that is bundled. This should be unchanged over time, and is an
arbitrary value that just needs to be unique among bundle types. Used as an identifier when using multiple
generic bundle pointers to retrieve the desired bundle type.</summary>
        </member>
        <member name="M:Core.cCameraRay.op_LessThan(Core.cCameraRay!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Comparison operators. Used mostly for sorting.</summary>
        </member>
        <member name="M:Core.cCameraRay.Equals(Core.cCameraRay!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if this ray instance is identical to the given instance.</summary>
        </member>
        <member name="M:Core.cCameraRay.Length">
            <summary>Ray length.</summary>
        </member>
        <member name="M:Core.cCameraRay.SetLength(System.Single)">
            <summary>Set the ray length.</summary>
        </member>
        <member name="M:Core.cCameraRay.Direction">
            <summary>3D ray direction.</summary>
        </member>
        <member name="M:Core.cCameraRay.Origin">
            <summary>3D ray origin.</summary>
        </member>
        <member name="M:Core.cCameraRay.ImageArea">
            <summary>Retrieves the (pixel) base area in the camera image.</summary>
        </member>
        <member name="M:Core.cCameraRay.ImagePosition">
            <summary>Retrieve the 2D image position in the camera image.</summary>
        </member>
        <member name="M:Core.cCameraRay.MarkerID">
            <summary>The ID of the marker that this ray is assigned to, or cUID::kInvalid if none.</summary>
        </member>
        <member name="M:Core.cCameraRay.SetMarkerID(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the assigned marker ID.</summary>
        </member>
        <member name="M:Core.cCameraRay.CameraSerial">
            <summary>Retrieve the serial number of the camera from which this ray originated.</summary>
        </member>
        <member name="M:Core.cCameraRay.ID">
            <summary>The (unique among rays) ID for this ray.</summary>
        </member>
        <member name="T:Core.cCameraRay">
            <summary>
A class representing a ray that emanates from a camera, and may be assigned to a 3D marker reconstruction.
</summary>
        </member>
        <member name="M:Core.cLabel.op_Equality(Core.cLabel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Comparison operators.</summary>
        </member>
        <member name="T:Core.cLabel.eEntityType">
            <summary>Legacy method to help with encoding and decoding the previous definition of a label.</summary>
            <returns>True if the passed ID was a legacy label that could be decoded.</returns>
        </member>
        <member name="M:Core.cLabel.ParseName(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Parse fully qualified name into entity and member names.</summary>
        </member>
        <member name="M:Core.cLabel.Valid">
            <summary>True if the label has a non-null entity ID. Does not attempt to ensure that the entity ID
is valid or that it belongs to an asset that has associated markers for labeling.</summary>
        </member>
        <member name="M:Core.cLabel.MemberID">
            <summary>The label ID within the entity.</summary>
        </member>
        <member name="M:Core.cLabel.EntityID">
            <summary>The node ID for the entity that this label belongs to.</summary>
        </member>
        <member name="T:Core.cLabel">
            <summary>A class that represents a marker label. Marker labels consist of two parts: The entity that the marker
is associated with (e.g. skeleton, rigid body, etc.), and the (one-based) index into the label list for that entity.
</summary>
        </member>
        <member name="T:MoCapCore.cActionFactoryWarehouse">
            <summary>Concrete class that provides ability to create node instances of named class types.</summary>
        </member>
        <member name="M:MoCapCore.cActionFactory.CreateInstance(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Creates a new instance of the type. Ownership is transferred to caller.</summary>
        </member>
        <member name="M:MoCapCore.cActionFactory.TypeName">
            <summary>The type name of the class that will be created by this factory.</summary>
        </member>
        <member name="M:MoCapCore.cBasicAction.SlotActivate">
Internal slot being called on action triggered signal
</member>
        <member name="T:MoCapCore.cPropertyCollection">
            <summary>A list of Properties.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.SemanticType">
            <summary>Get the semantic type, if any of this definition.</summary>
            <returns>Reference to the semantic if any. If the definition has no
semantic type the returned ref will be null (!SemanticType() will evaluate to true).</returns>
        </member>
        <member name="M:MoCapCore.cProperty.SetToConstraintValue(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Set the property value to the value of the named constraint from the constraint list.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.SetToConstraintValue(System.UInt32,System.Boolean)">
            <summary>Set the property value to the value of the constraint at the given index in the constraint list.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.ConstraintsAreMandatory">
            <summary>
Returns true if the constraints are mandatory, false if it is possible
to set custom value as well.
</summary>
        </member>
        <member name="M:MoCapCore.cProperty.ConstraintsAreRange">
            <summary>
Returns true if the constraints should be considered a range. In this case,
exactly two constraints should exist, a max and a min.
</summary>
        </member>
        <member name="M:MoCapCore.cProperty.ConstraintName(System.UInt32)">
            <summary>Get the name of the constraint at the given index, if any.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.Constraint(System.UInt32)">
            <summary>Get the constraint at the given index.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.ConstraintCount(System.Boolean)">
            <summary>Find out how many value constraints are active.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.Advanced">
            <summary>Returns true if this property should be considered "advanced".</summary>
        </member>
        <member name="M:MoCapCore.cProperty.SetAdvanced(System.Boolean,System.Boolean)">
            <summary>Set the advanced flag. This sets the value on the underlying definition.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.Required">
            <summary>Returns true if this property requires a value.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.Hidden">
            <summary>True if this property is (or should be) hidden.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.SetHidden(System.Boolean,System.Boolean)">
            <summary>Set the hidden flag. This is an override.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.ReadOnly">
            <summary>Returns true if this property is read-only.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.SetReadOnly(System.Boolean,System.Boolean)">
            <summary>Set the read-only flag.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.EndEditAttributes">
            <summary>
Finish a grouped edit of attributes. Any callbacks associated with attribute editing that
were held by calling BeginEditAttributes will be called once this method is called.
</summary>
        </member>
        <member name="M:MoCapCore.cProperty.BeginEditAttributes">
            <summary>
Begin an edit operation on attributes. This must be matched with a call to
<code>EndEditAttributes()</code>. Calls to <code>BeginEditAttributes()</code> and
<code>EndEditAttributes()</code> should not be nested.
</summary>
        </member>
        <member name="M:MoCapCore.cProperty.ClearMacro(System.Boolean)">
            <summary>Clear any active macro.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.SetToMacro(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
            <summary>Activate the named macro.</summary>
            <returns>True if the macro was found and set as active.</returns>
        </member>
        <member name="M:MoCapCore.cProperty.ActiveMacro(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Get the name of the currently active macro, if any.</summary>
            <returns>True if a macro is currently active.</returns>
        </member>
        <member name="M:MoCapCore.cProperty.AvailableMacros(std.vector&lt;MoCapCore.cIMacro!System.Runtime.CompilerServices.IsConst**,std.allocator&lt;MoCapCore.cIMacro!System.Runtime.CompilerServices.IsConst**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Get the array of available macros for use with this property.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.HasMacros">
            <summary>Returns true if there are macros available for this property.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.SetValueFromString(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
            <summary>
Set the value of the property from a string, if possible. The string must be formatted
identically to the formatting used by ValueAsString().
</summary>
        </member>
        <member name="M:MoCapCore.cProperty.ValueAsString">
            <summary>
Retrieve the value of the property as a string. Each value type will have its own
representation of what the returned string should look like.
</summary>
        </member>
        <member name="M:MoCapCore.cProperty.op_Equality(MoCapCore.cProperty!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Equality comparison operator. Compares values.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.Copy(MoCapCore.cProperty!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Copy the value and attributes of the given property into our own, if possible.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.IsSame(MoCapCore.cProperty!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if the given property was created by the same ParameterDefinition as this one.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.IsDefaultAttributes">
            <summary>Returns true if property attributes agree with the corresponding ones from its definition.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.IsDefaultValue(System.Boolean)">
            <summary>Returns true if a default value exists for the property, and the current value is set to it. Property
default values are overrideable from the definition. 
If <c>checkAgainstDef</c> is true the property's
value will be checked against its default value from the definition. If false the property's value will
be checked it's local default value. If the property has not overridden it's default value this parameter
has no effect.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.SetToDefaultValue(System.Boolean,System.Boolean)">
            <summary>Sets the value of this property to its default value, if it has one.</summary>
            <param name="respectReadOnly">If true, the read-only status is respected.</param>
            <returns>True if a default value exists and the property value was set to it.</returns>
        </member>
        <member name="M:MoCapCore.cProperty.ValueIsValid(MoCapCore.cIPropertyValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if the given property has a value and it satisfies any current constraints
and custom validators.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.ValueIsValid">
            <summary>Returns true if the property has a value and it satisfies any current constraints.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.FindConstraint(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Find constraint. Will either be from definition or instance-specific (overridden).</summary>
        </member>
        <member name="M:MoCapCore.cProperty.ClearConstraintOverrides(System.Boolean)">
            <summary>Removes any existing constraint overrides. Non-templated function that can be called on any property.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.HasContraintOverrides">
            <summary> true if property has custom (overriden) set of constraints.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.SetConstraintOverrides(std.vector&lt;std.pair&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;,MoCapCore.cIPropertyValue**&gt;,std.allocator&lt;std.pair&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;,MoCapCore.cIPropertyValue**&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Set constraint overrides on this property instance. This will also do property value validation
and set the property value to the nearest constraint, by value. It replaces any existing constraint
overrides.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.GroupLabel">
            <summary>A user-facing group label that the UI may use to group parameters. Should be localized.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.Description">
            <summary>A brief description of this property. Should be localized.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.Label">
            <summary>The user-facing label to display for this property. Should be localized.</summary>
        </member>
        <member name="M:MoCapCore.cProperty.Name">
            <summary>The internal name of this property, used for lookups. Should not be changed with localization</summary>
        </member>
        <member name="T:MoCapCore.cProperty">
            <summary>
A generic property class that provides storage and management for a generic type of data, determined
by the derived type of cIPropertyValue stored. Properties should only be instantiated from a property
definition.
</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyObserver.OnPropertyAttributesChanged(MoCapCore.cProperty!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>Callback that gets called when any attributes on the property change.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyObserver.OnPropertyValueChanged(MoCapCore.cProperty!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Callback that gets called when the value of the property changes.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.ConstraintsAreMandatory">
            <summary>Returns true if the constraints are mandatory, false if it is possible to set custom value.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.SetConstraintsAreMandatory(System.Boolean)">
            <summary>If set, if constraints are mandatory or only predefined values with option to set own value.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.ConstraintsAreRange">
            <summary>Returns true if the constraints should be interpreted as a value range.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.SetConstraintsAreRange(System.Boolean)">
            <summary>If set, there should be exactly two constraints and they represent a value range (min, max).</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.ConstraintName(System.UInt32)">
            <summary>Get the name of the constraint at the given index, if any.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.FindConstraint(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Attempt to find the constraint value by name.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.Constraint(System.UInt32)">
            <summary>Get the constraint at the given index.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.RemoveAllConstraints">
            <summary>
Remove any constraints associated with this definition.
</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.AddConstraint(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cIPropertyValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Create and add a named constraint with a specified value. The name must be unique among all constraints
attached to this object. If the a constraint with name does not already exist for this object, it is
added along with the specified value.
</summary>
            <param name="name">Constraint name. Must be unique within this definition.</param>
            <param name="val">Constraint value.</param>
            <returns>false if there is already a constraint with this name and the constraint
was not added, true otherwise</returns>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.AddConstraint(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Create and add a named constraint. The name must be unique among all constraints attached to this
object. Ownership of the returned pointer remains with this object.
</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.FindMacro(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Finds and returns a named macro, or NULL if it was not found.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.DefaultMacro">
            <summary>Returns the default macro, or NULL if none.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.AvailableMacros(std.vector&lt;MoCapCore.cIMacro!System.Runtime.CompilerServices.IsConst**,std.allocator&lt;MoCapCore.cIMacro!System.Runtime.CompilerServices.IsConst**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Get the list of macros compatible with this parameter definition.</summary>
            <returns>True if some items were added to the results array.</returns>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.HasMacros">
            <summary>Returns true if there are available macros.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.Units">
            <summary>The internal units of the property value.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyDefinition.#ctor(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoC">
            <summary>Construct a new parameter definition.</summary>
        </member>
        <member name="M:MoCapCore.cISemanticType.Clone">
            <summary>Creates a new object that is a copy of this one.</summary>
        </member>
        <member name="T:MoCapCore.cISemanticType">
            <summary>
Base class for all semantic types. These are very simple class derivations that provide
a heuristic way to deal with parameters that may have the same data type, but may differ
substantially in their meaning. For example, you may have two parameters that are both
Vector3f's, but one may be an unbounded position while the other is an RGB color. UI's
can use semantic types to assign appropriate controls to a parameter.

Use dynamic_cast to determine whether a type is of a requested type
<code>
if( dynamic_cast&lt;ISemanticTypeColor*&gt;( semanticType ) != NULL )
{
    // This is the type wanted
}
</code>

Because they are class types, semantic types can be arranged in a hierarchy so that base types
can share UI implementations (if the UI chooses to do that).
</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyValue.IsIndeterminate">
            <summary>
Method for determining if a property's value is indeterminate.
</summary>
            <returns>true if indeterminate and false if well defined.</returns>
        </member>
        <member name="M:MoCapCore.cIPropertyValue.TypeInfoHashCode">
            <summary>Get the std::type_info.hash_code() value for the underlying type.</summary>
            <returns>Type info hash code.</returns>
        </member>
        <member name="M:MoCapCore.cIPropertyValue.SetValueFromString(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the value from a string.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyValue.ValueAsString">
            <summary>
Retrieve the value of the property as a string, useful for text serialization or presentation in a UI.
</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyValue.IsEqual(MoCapCore.cIPropertyValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Equality comparison function.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyValue.IsLessThan(MoCapCore.cIPropertyValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Less-than comparison function.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyValue.CopyFrom(MoCapCore.cIPropertyValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Copy the contents of the given object into this one. We use this instead of an assignment
operator to ensure that all derived classes define it.
</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyValue.Clone">
            <summary>
Create a new object that is a duplicate of this one. The caller assumes ownership of the
returned object.
</summary>
        </member>
        <member name="T:MoCapCore.cIPropertyValue">
            <summary>
Interface base class for parameter value storage. Parameters contain an instance of cIPropertyValue.
</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyProvider.SetPropertiesToDefaultValues(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Convenience method to set all properties to their default values.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyProvider.Property(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Access to properties by name.</summary>
            <returns>The property, if found. A null value otherwise.</returns>
        </member>
        <member name="M:MoCapCore.cIPropertyProvider.Apply(std.function&lt;(MoCapCore.cProperty!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)(MoCapCore.cProperty!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced&amp;)&gt;)">
            <summary>Apply the given functional to each of the properties in this provider.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyProvider.Apply(std.function&lt;(MoCapCore.cProperty*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)(MoCapCore.cProperty*!System.Runtime.CompilerServices.IsImplicitlyDereferenced&amp;)&gt;)">
            <summary>Apply the given functional to each of the properties in this provider.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyProvider.Properties(std.vector&lt;std.shared_ptr&lt;MoCapCore.cProperty!System.Runtime.CompilerServices.IsConst&gt;,std.allocator&lt;std.shared_ptr&lt;MoCapCore.cProperty!System.Runtime.CompilerServices.IsConst&gt;&gt;&gt;*)">
            <summary>Retrieve the full properties list as a vector of shared pointers.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyProvider.PropertyCount">
            <summary>Retrieve the number of properties in this collection. Depending on the storage method for the
contained properties, this method could result in an O(n) operation to enumerate the properties, so
take care not to call it within inside loops.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyProvider.RemoveProperty(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Remove a named property from the collection of properties owned by this object.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyProvider.AddProperties(std.vector&lt;std.unique_ptr&lt;MoCapCore.cProperty,std.default_delete&lt;MoCapCore.cProperty&gt;&gt;,std.allocator&lt;std.unique_ptr&lt;MoCapCore.cProperty,std.default_delete&lt;MoCapCore.cProperty&gt;&gt;&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Add an array of properties at once. This may allow for economizing on notifications, array sizing, etc.
The unique_ptr version has a concrete implementation to accommodate the script interfaces.
</member>
        <member name="M:MoCapCore.cIPropertyProvider.AddProperty(std.unique_ptr&lt;MoCapCore.cProperty,std.default_delete&lt;MoCapCore.cProperty&gt;&gt;)">
            <summary>Add a property instance to this collection. Ownership of the property instance transfers
to this object with this call. Added properties must have unique names.</summary>
            <returns>True if the property was successfully added to the collection.</returns>
        </member>
        <member name="T:MoCapCore.cIPropertyProvider">
            <summary>A list of Properties.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyProviderObserver.OnPropertyAttributesChanged(MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;MoCapCore.cProperty!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32)">
            <summary>Callback that gets called when any attributes on the property change.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyProviderObserver.OnPropertyValueChanged(MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;MoCapCore.cProperty!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Callback that gets called when the value of the property changes.</summary>
        </member>
        <member name="M:MoCapCore.cIPropertyProviderObserver.OnPropertyListChanged(MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Callback that gets called when properties are added or removed.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyCollectionDefinition.ClearLibrary">
            <summary>
Clear (and delete) the static library of stored collection definitions. This allows an application
to tear down any collection definitions that have been stored up during application execution.
</summary>
        </member>
        <member name="M:MoCapCore.cPropertyCollectionDefinition.FindInLibrary(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Find a definition in the collection library, if it exists. If it is not found (perhaps ClearLibrary()
has been called), an invalid shared pointer is returned.
</summary>
        </member>
        <member name="M:MoCapCore.cPropertyCollectionDefinition.FindInLibrary(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Find a definition in the collection library, if it exists. If it is not found (perhaps ClearLibrary()
has been called), an invalid shared pointer is returned.
</summary>
        </member>
        <member name="M:MoCapCore.cPropertyCollectionDefinition.AddToLibrary(std.shared_ptr&lt;MoCapCore.cPropertyCollectionDefinition&gt;)">
            <summary>
Add a definition collection to the static list of available collections. This is a convenient
way to keep a reference to the definition available for creation of instances. The library can
be cleared so that definitions can be torn down by calling ClearLibrary().
</summary>
        </member>
        <member name="M:MoCapCore.cPropertyCollectionDefinition.CreateProperties(std.vector&lt;std.unique_ptr&lt;MoCapCore.cProperty,std.default_delete&lt;MoCapCore.cProperty&gt;&gt;,std.allocator&lt;std.unique_ptr&lt;MoCapCore.cProperty,std.default_delete&lt;MoCapCore.cProperty&gt;&gt;&gt;&gt;*,System.Boolean)">
            <summary>Create an instance of each of the properties in the definition and add it to the passed array.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyCollectionDefinition.CreateInstance(System.Boolean)">
            <summary>Create a new cPropertyCollection instance from this definition.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyCollectionDefinition.AddDefinition(std.unique_ptr&lt;MoCapCore.cPropertyDefinition,std.default_delete&lt;MoCapCore.cPropertyDefinition&gt;&gt;,System.Boolean)">
            <summary>
Add a new property definition to this collection. The collection takes ownership of the PropertyDefinition
object at this point. Property definitions can only be added to a group once.
</summary>
            <param name="def">The new definition. Ownership of the pointer will be assumed by the collection.</param>
            <param name="replaceExisting">If true and there exists a definition with the same name, the old definition
will be removed and replaced with the new one. Otherwise the old one will not be removed and the new 
definition will not be added.</param>
            <returns>True if the property was unique within the group and added successfully.</returns>
        </member>
        <member name="M:MoCapCore.cPropertyCollectionDefinition.ID">
            <summary>A cUID used to uniquely identify this definition.</summary>
        </member>
        <member name="M:MoCapCore.cPropertyCollectionDefinition.Name">
            <summary>Retrieve the name of this definition collection.</summary>
        </member>
        <member name="T:MoCapCore.cPropertyCollectionDefinition">
            <summary>
A grouping of parameter definitions that simplifies the task of creating and maintaining parameter
blocks.
</summary>
        </member>
        <member name="T:__type_info_node">
Invert x axis to switch handedness
</member>
        <member name="M:NMotive.Vector3fChannel.SetOrAddKeyComponent(System.Single,System.Int32,System.Int32,NMotive.InterpolationType)">
            <summary>
Sets a single component of a key, or creates a new key if none exists. The other axes of the new key
will be filled in using the requested interpolation type.
</summary>
            <param name="val">The value.</param>
            <param name="whichAxis">0 = x, 1 = y, 2 = z.</param>
            <param name="frameIndex">The key frame index which contains the value
to be set.</param>
            <param name="interpType">This interpolation type to used to interpret the other two axis
values if the key needs to be added.</param>
        </member>
        <member name="M:NMotive.Vector3fChannel.SetKeyComponent(System.Single,System.Int32,System.Int32)">
            <summary>
Sets a single component of a key. If the key is not found no values will
be set.
</summary>
            <param name="val">The value.</param>
            <param name="whichAxis">0 = x, 1 = y, 2 = z.</param>
            <param name="frameIndex">The key frame index which contains the value
to be set.</param>
        </member>
        <member name="M:NMotive.Vector3fChannel.FindKeys(NMotive.FrameRange)">
            <summary>
Retrieve all the keys that fall within the given time range, including end points. The keys
in the returned array are guaranteed to be in order of increasing time.
</summary>
            <param name="range">Find all keys in this frame range.</param>
            <returns>List of keys, in order of increasing time, of all the keys in the 
specified range.</returns>
        </member>
        <member name="M:NMotive.Vector3fChannel.AllKeys">
            <summary>
Retrieve a copy of the entire key array.
</summary>
            <returns>A list of all keys.</returns>
        </member>
        <member name="M:NMotive.Vector3fChannel.KeyExtents(NMotive.FrameRange,System.Int32,NMotive.Vector3f@,NMotive.Vector3f@)">
            <summary>
Calculate the minimum and maximum values in the requested dimension for all keys 
within the given range.
</summary>
            <param name="range">The frame range over which to compute the mimimum and 
maximum values.</param>
            <param name="minVals">Minimum values if there are keys in the given range.</param>
            <param name="maxVals">Maximum values if there are keys in the given range.</param>
            <param name="axis">Axis to get extents for. 0 = x-axis, 1 = y-axis, 2 = z-axis.</param>
            <returns>
                <c>true</c> if there are keys in the given range and <c>minVals</c> and
<c>maxVals</c> contain valid values. <c>false</c> if there are no keys in the given range.</returns>
        </member>
        <member name="M:NMotive.Vector3fChannel.Value(System.TimeSpan)">
            <summary>
Evaluate the channel at the given time and return its value. Will interpolate 
keys where needed.
</summary>
            <param name="fractionalFrame">Fractional frame time of the value.</param>
            <returns>The value at the frame time.</returns>
        </member>
        <member name="M:NMotive.Vector3fChannel.Value(System.Int32!System.Runtime.CompilerServices.IsLong,System.Boolean@)">
            <summary>
Evaluate the channel at the given frame and return its value. No interpolation.
</summary>
            <param name="frameIndex">et value for this frame index.</param>
            <param name="isKey">Set to <c>true</c> if the frame index corresponds to a key frame.</param>
            <returns>Value at the frame index if it is a keyframe. If it is not
a keyframe it is the value of the nearest previous key.</returns>
        </member>
        <member name="M:NMotive.Vector3fChannel.InsertKeys(System.Collections.Generic.List`1{NMotive.Keyframe`1{NMotive.Vector3f}},System.Boolean)">
            <summary>
Inserts the given keys into this channel. The time range of the incoming keys is cleared before
setting new keys. The given keys must be in the array in order of increasing frame number.
</summary>
            <param name="sourceKeys">Keys to insert.</param>
            <param name="preserveOriginal">If true any existing keys will be inserted into the input
<c>sourceKeys</c> before the source keys are inserted.</param>
        </member>
        <member name="M:NMotive.Vector3fChannel.SetKeys(System.Collections.Generic.List`1{NMotive.Keyframe`1{NMotive.Vector3f}},System.Boolean)">
            <summary>
Convenience method for setting multiple keys at once.
</summary>
            <param name="keys">Key frames to set.</param>
            <param name="addIfNotFound">If true, a new key will be created if one 
does not exist for each key.</param>
        </member>
        <member name="M:NMotive.Vector3fChannel.SetKey(NMotive.Vector3f,System.Int32,System.Boolean)">
            <summary>
Set a key at a given frame.
</summary>
            <param name="val">Key value to assign.</param>
            <param name="frameIndex">Frame index at which to assign value.</param>
            <param name="addIfNotFound">If true, a new key will be created 
at the given time if one does not exist</param>
        </member>
        <member name="M:NMotive.Vector3fChannel.SetKey(NMotive.Keyframe`1{NMotive.Vector3f},System.Boolean)">
            <summary>
Set a keyframe value.
</summary>
            <param name="key">Keyframe to add</param>
            <param name="addIfNotFound">If true, a new key will be created at the
given time if one does not exist</param>
        </member>
        <member name="P:NMotive.Vector3fChannel.DefaultValue">
            <summary>
Gets and sets the default <c>Vector3fChannel</c> value.
</summary>
        </member>
        <member name="M:NMotive.Vector3fChannel.#ctor">
            <summary>
Constructs an empty <c>Vector3fChannel</c> object.
</summary>
        </member>
        <member name="T:NMotive.Vector3fChannel">
            <summary>
Channel class for postitional, or transalational, data.
</summary>
        </member>
        <member name="T:NMotive.NMotiveUtils">
            <exclude />
        </member>
        <member name="T:NMotive.NMotiveRunMode">
            <exclude />
        </member>
        <member name="T:NMotive.Axis">
            <summary>
Enumeration of Motive axis value options.
</summary>
        </member>
        <member name="F:NMotive.Axis.Axis_NegativeZ">
            <summary>The negative z-axis.</summary>
        </member>
        <member name="F:NMotive.Axis.Axis_PositiveZ">
            <summary>The positive z-axis.</summary>
        </member>
        <member name="F:NMotive.Axis.Axis_NegativeY">
            <summary>The negative y-axis.</summary>
        </member>
        <member name="F:NMotive.Axis.Axis_PositiveY">
            <summary>The positive y-axis.</summary>
        </member>
        <member name="F:NMotive.Axis.Axis_NegativeX">
            <summary>The negative x-axis.</summary>
        </member>
        <member name="F:NMotive.Axis.Axis_PositiveX">
            <summary>The positive x-axis.</summary>
        </member>
        <member name="T:NMotive.LengthUnits">
            <summary>
Enumeration of units of length.
</summary>
        </member>
        <member name="F:NMotive.LengthUnits.Units_Millimeters">
            <summary>Millimeters.</summary>
        </member>
        <member name="F:NMotive.LengthUnits.Units_Centimeters">
            <summary>Centimeters.</summary>
        </member>
        <member name="F:NMotive.LengthUnits.Units_Meters">
            <summary>Meters.</summary>
        </member>
        <member name="T:NMotive.FileResult">
            <summary>
Enumeration of file operation results.
</summary>
        </member>
        <member name="F:NMotive.FileResult.NotLicensed">
            <summary>
Attempted to load a file that contained elements that are not 
licensed for use in this instance.
</summary>
        </member>
        <member name="F:NMotive.FileResult.AlreadyLoaded">
            <summary>
File is already loaded into the project.
</summary>
        </member>
        <member name="F:NMotive.FileResult.OutOfMemory">
            <summary>
Insufficient memory for the operation.
</summary>
        </member>
        <member name="F:NMotive.FileResult.NoData">
            <summary>
There was no data to write.
</summary>
        </member>
        <member name="F:NMotive.FileResult.NotCompatible">
            <summary>
The file was written by a newer version of the application, or is not otherwise compatible.
</summary>
        </member>
        <member name="F:NMotive.FileResult.BadFormat">
            <summary>
File contained unexpected data fields.
</summary>
        </member>
        <member name="F:NMotive.FileResult.IncompleteFile">
            <summary>
File did not contain all expected data fields.
</summary>
        </member>
        <member name="F:NMotive.FileResult.CannotOpenFile">
            <summary>
File did not exist, could not be read, or could not be written to.
</summary>
        </member>
        <member name="F:NMotive.FileResult.ResultOK">
            <summary>
Operation successful
</summary>
        </member>
        <member name="M:MoCapCore.cFileHelpers.ComposeUniqueFilename(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>
Given a filename, compose a filename that will be unique at the location the filename specifies.
The returned filename will be unique without regard for the file extension specified (i.e. if a file on
disk shares the same base filename as the one given, a new unique filename will be generated).
</summary>
        </member>
        <member name="M:MoCapCore.cFileHelpers.EnumerateFilenames(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.list&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;,std.allocator&lt;std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;&gt;&gt;*)">
            <summary>Get all filenames in specified folder with specified extension. Path must include trailing slash.</summary>
        </member>
        <member name="M:MoCapCore.cFileHelpers.IsVolume(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Returns true if the given string is valid syntax for a volume on the host environment.
Does not test whether the volume exists.
</summary>
        </member>
        <member name="M:MoCapCore.cFileHelpers.PathSeparator">
            <summary>Get the path separator used on this platform.</summary>
        </member>
        <member name="M:MoCapCore.cFileHelpers.MakeDirectory(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Create a folder at the given path.</summary>
        </member>
        <member name="M:MoCapCore.cFileHelpers.DirectoryExists(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if the given folder exists on disk.</summary>
        </member>
        <member name="M:MoCapCore.cFileHelpers.FileExists(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if the given file exists on disk.</summary>
        </member>
        <member name="M:MoCapCore.cFileHelpers.IsValidFilename(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns false if the file name contains invalid characters.</summary>
        </member>
        <member name="M:MoCapCore.cFileHelpers.MakeValidFilename(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Scrubs the given string and replaces any invalid filename characters with an underscore.
The given string should not be a full path, but just the filename with or without a file
extension.
</summary>
        </member>
        <member name="M:MoCapCore.cFileHelpers.Delete(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Deletes a file on disk, if it exists and can be deleted.</summary>
        </member>
        <member name="M:MoCapCore.cFileHelpers.Copy(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Copy the file or folder at the given path to the given target path.</summary>
            <param name="overwrite">If true and a file of the same name exists at the target location, it will be overwritten.</param>
        </member>
        <member name="M:MoCapCore.cFileHelpers.Move(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Move the file or folder at the given path and name to the target path.</summary>
        </member>
        <member name="T:MoCapCore.cFileHelpers">
            <summary>A collection of platform-neutral file and folder management routines.</summary>
        </member>
        <member name="M:NMotive.Vector3f.NativeToManaged(Core.cVector3&lt;System.Single&gt;)">
            <summary>
Returns the managed version of a native vector.
</summary>
            <param name="nativeVector">A native vector.</param>
            <returns>A managed version of the native vector.</returns>
        </member>
        <member name="M:NMotive.Vector3f.Distance(NMotive.Vector3f,NMotive.Vector3f)">
            <summary>
Computes the Euclidean distance between two vectors.
</summary>
            <param name="v">A vector.</param>
            <param name="w">A vector.</param>
            <returns>The Euclidean distance between the two vectors.</returns>
        </member>
        <member name="M:NMotive.Vector3f.DistanceSquared(NMotive.Vector3f,NMotive.Vector3f)">
            <summary>
Computes the Euclidean distance squared between two vectors.
</summary>
            <param name="v">A vector.</param>
            <param name="w">A vector.</param>
            <returns>The Euclidean distance squared between the two vectors.</returns>
        </member>
        <member name="M:NMotive.Vector3f.Lerp(NMotive.Vector3f,NMotive.Vector3f,System.Single)">
            <summary>
Returns a linear interpolated vector some percentage 't' between two vectors.
The parameter t is usually in the range [0,1], but this method can also be used to extrapolate
vectors beyond that range.
</summary>
            <param name="v1">Vector one.</param>
            <param name="v2">Vector two.</param>
            <param name="t">Percentage as decimal between 0 and 1.</param>
            <returns>The interploted value.</returns>
        </member>
        <member name="M:NMotive.Vector3f.Normalize(NMotive.Vector3f)">
            <summary>
Normalizes a vector to have length one.
</summary>
            <param name="x">A vector.</param>
            <returns>A normalized version of the input vector.</returns>
        </member>
        <member name="M:NMotive.Vector3f.Angle(NMotive.Vector3f,NMotive.Vector3f)">
            <summary>
Computes the angle (in radians) between two vectors.
</summary>
            <param name="v">A vector.</param>
            <param name="w">A vector.</param>
            <returns>The angle between the two vectors in radians.</returns>
        </member>
        <member name="M:NMotive.Vector3f.Cross(NMotive.Vector3f,NMotive.Vector3f)">
            <summary>
Computes the cross or vector product of two vectors.
</summary>
            <param name="v">A vector.</param>
            <param name="w">A vector.</param>
            <returns>The cross product.</returns>
        </member>
        <member name="M:NMotive.Vector3f.Dot(NMotive.Vector3f,NMotive.Vector3f)">
            <summary>
Computes the dot or scalar product of two vectors.
</summary>
            <param name="x">A vector.</param>
            <param name="y">A vector.</param>
            <returns>The dot product.</returns>
        </member>
        <member name="M:NMotive.Vector3f.Normalize">
            <summary>
Normalizes this vector to have length one.
</summary>
        </member>
        <member name="M:NMotive.Vector3f.Norm">
            <summary>
Computes the Euclidean norm.
</summary>
            <returns>The Euclidean norm.</returns>
        </member>
        <member name="M:NMotive.Vector3f.NormSquared">
            <summary>
Computes the Euclidean norm squared.
</summary>
            <returns>The Euclidean norm squared.</returns>
        </member>
        <member name="M:NMotive.Vector3f.Decrement(NMotive.Vector3f)">
            <summary>
Decrements the components of self by the values of the corresponding
components of the given vector. Note that this is just subtracting
the give vector from this vector.
</summary>
            <param name="v">A vector to subtract from self.</param>
        </member>
        <member name="M:NMotive.Vector3f.Decrement(System.Single,System.Single,System.Single)">
            <summary>
Decrements the components of self by the given
amounts.
</summary>
            <param name="dx">Amount to Decrement the X component by.</param>
            <param name="dy">Amount to Decrement the Y component by.</param>
            <param name="dz">Amount to Decrement the Z component by.</param>
        </member>
        <member name="M:NMotive.Vector3f.Decrement">
            <summary>
Decrements the value of each component of self by one.
</summary>
        </member>
        <member name="M:NMotive.Vector3f.Decrement(System.Single)">
            <summary>
Decrements each component of self by the given value.
</summary>
            <param name="a">Amount to decrement by.</param>
        </member>
        <member name="M:NMotive.Vector3f.Increment(NMotive.Vector3f)">
            <summary>
Increments each component of this vector by the corresponding
component of the input vector.
</summary>
            <param name="v">Vector to increment this vector by.</param>
        </member>
        <member name="M:NMotive.Vector3f.Increment(System.Single,System.Single,System.Single)">
            <summary>
Increments the components of self by the given
amounts.
</summary>
            <param name="dx">Amount to increment the X component by.</param>
            <param name="dy">Amount to increment the Y component by.</param>
            <param name="dz">Amount to increment the Z component by.</param>
        </member>
        <member name="M:NMotive.Vector3f.Increment(System.Single)">
            <summary>
Increments each component of self by the given value.
</summary>
            <param name="a">Increment amount.</param>
        </member>
        <member name="M:NMotive.Vector3f.Increment">
            <summary>
Increments each component of self by one.
</summary>
        </member>
        <member name="M:NMotive.Vector3f.Scale(System.Single)">
            <summary>
Multiplies each component of self by the given scalar.
</summary>
            <param name="s">The scalar.</param>
        </member>
        <member name="M:NMotive.Vector3f.SetValues(System.Single,System.Single,System.Single)">
            <summary>
Sets the components of self to the given values.
</summary>
            <param name="x">Value to set the X or first component to.</param>
            <param name="y">Value to set the Y or second component to.</param>
            <param name="z">Value to set the Z or third component to.</param>
        </member>
        <member name="M:NMotive.Vector3f.ToString">
            <summary>
Constructs a string representation of self.
</summary>
            <returns>A string representation of this vector.</returns>
        </member>
        <member name="M:NMotive.Vector3f.Equals(NMotive.Vector3f)">
            <summary>
Compares this vector to another for component-wise equality.
</summary>
            <param name="v">Vector to compare self to.</param>
            <returns>
                <c>true</c>if the componnents of self are equal
to the input vector.</returns>
            <remarks>This function will return <c>true</c> only if the vector
components are all equal in a bit-wise sense.</remarks>
        </member>
        <member name="M:NMotive.Vector3f.Equals(NMotive.Vector3f,System.Single)">
            <summary>
Compares this vector with another vector for equality using a 
tolerance. This function will return <c>true</c> if the 
absolute value of the difference of each component is less than
the specified tolerance.
</summary>
            <param name="v">Vector to compare self to.</param>
            <param name="tolerance">The tolerance.</param>
            <returns>
                <c>true</c> if the vectors are equal within the 
specified tolerance. </returns>
        </member>
        <member name="M:NMotive.Vector3f.op_Inequality(NMotive.Vector3f,NMotive.Vector3f)">
            <summary>
Compares two vectors for component-wise non-equality.
</summary>
            <param name="v">A vector.</param>
            <param name="w">A vector.</param>
            <returns>
                <c>true</c>if the componnents of the two vectors are not equal.</returns>
        </member>
        <member name="M:NMotive.Vector3f.op_Equality(NMotive.Vector3f,NMotive.Vector3f)">
            <summary>
Compares two vectors for component-wise equality.
</summary>
            <param name="v">A vector.</param>
            <param name="w">A vector.</param>
            <returns>
                <c>true</c>if the componnents of the two vectors are equal.</returns>
            <remarks>This function will return <c>true</c> only if the vectors
components are all equal in a bit-wise sense.</remarks>
        </member>
        <member name="M:NMotive.Vector3f.op_Multiply(System.Single,NMotive.Vector3f)">
            <summary>
Computes a vector whose components are equal to the components of
the input vector multiplied by a give scalar value.
</summary>
            <param name="s">A scaler to scale by.</param>
            <param name="x">A vector to scale.</param>
            <returns>Scaled vector.</returns>
        </member>
        <member name="M:NMotive.Vector3f.op_Multiply(NMotive.Vector3f,System.Single)">
            <summary>
Computes a vector whose components are equal to the components of
the input vector multiplied by a give scalar value.
</summary>
            <param name="x">A vector to scale.</param>
            <param name="s">A scaler to scale by.</param>
            <returns>Scaled vector.</returns>
        </member>
        <member name="M:NMotive.Vector3f.op_Subtraction(System.Single,NMotive.Vector3f)">
            <summary>
Subtract vector and scalar. Computes a vector whose ith component value
is the scalar minus the ith component value.
</summary>
            <param name="s">A scalar.</param>
            <param name="x">A vector.</param>
            <returns>a vector whose ith component value
is the scalar minus the ith component value.</returns>
        </member>
        <member name="M:NMotive.Vector3f.op_Subtraction(NMotive.Vector3f,System.Single)">
            <summary>
Subtract a scalar from a vector. Decrements each component of the vector by
</summary>
            <param name="x">A vector.</param>
            <param name="s">A scalar.</param>
            <returns>A vector whose component values are equal to the input vectors
incremented by the scalar value.</returns>
        </member>
        <member name="M:NMotive.Vector3f.op_Addition(System.Single,NMotive.Vector3f)">
            <summary>
Add a vector and a scalar. Increments each component of the vector by
</summary>
            <param name="s">A scalar.</param>
            <param name="x">A vector.</param>
            <returns>A vector whose component values are equal to the input vectors
incremented by the scalar value.</returns>
        </member>
        <member name="M:NMotive.Vector3f.op_Addition(NMotive.Vector3f,System.Single)">
            <summary>
Add a vector and a scalar. Increments each component of the vector by
</summary>
            <param name="x">A vector.</param>
            <param name="s">A scalar.</param>
            <returns>A vector whose component values are equal to the input vectors
incremented by the scalar value.</returns>
        </member>
        <member name="M:NMotive.Vector3f.op_Subtraction(NMotive.Vector3f,NMotive.Vector3f)">
            <summary>
Vector subtraction operator. Returns the component-wise difference
of two vectors.
</summary>
            <param name="x">A vector.</param>
            <param name="y">A vector</param>
            <returns>The difference of the two vectors.</returns>
        </member>
        <member name="M:NMotive.Vector3f.op_Addition(NMotive.Vector3f,NMotive.Vector3f)">
            <summary>
Vector addition operator. Returns the component-wise sum of two vectors.
</summary>
            <param name="x">A vector.</param>
            <param name="y">A vector</param>
            <returns>The sum of the two vectors.</returns>
        </member>
        <member name="M:NMotive.Vector3f.op_UnaryNegation(NMotive.Vector3f)">
            <summary>
Vector negation. returns a new vector object with component values
equal to equal to the negated input vector component values.
</summary>
            <param name="x">A vector to negate.</param>
            <returns>The negated vector.</returns>
        </member>
        <member name="P:NMotive.Vector3f.default(System.Int32)">
            <summary>
Index operator. Return the vector component at the specified
zero based index. X = [0], Y = [1], Z = [2].
Any index value other than 0, 1, or 2 will raise an exception.
</summary>
            <returns>The component at the give index.</returns>
        </member>
        <member name="P:NMotive.Vector3f.Z">
            <summary>
Gets and sets the Z component value.
</summary>
        </member>
        <member name="P:NMotive.Vector3f.Y">
            <summary>
Gets and sets the Y component value.
</summary>
        </member>
        <member name="P:NMotive.Vector3f.X">
            <summary>
Gets and sets the X component value.
</summary>
        </member>
        <member name="M:NMotive.Vector3f.#ctor(System.Single[])">
            <summary>
Constructs a <c>Vector3f</c> object with the given component
values.
</summary>
            <param name="values"> values[0] is the X component value,
values[1] is the Y component value, values[2] is the Z 
component value.</param>
        </member>
        <member name="M:NMotive.Vector3f.#ctor(System.Single,System.Single,System.Single)">
            <summary>
Constructs a <c>Vector3f</c> object with the given component
values.
</summary>
            <param name="x"> X component value.</param>
            <param name="y"> Y component value.</param>
            <param name="z"> Z component value.</param>
        </member>
        <member name="T:NMotive.Vector3f">
            <summary>
A three dimensional vector.
</summary>
        </member>
        <member name="M:NMotive.Channel.CompareTo(NMotive.Channel)">
            <summary>
Comparison operator, used for instance sorting
</summary>
            <param name="other">A channel to compare self to.</param>
            <returns>
Less than zero if this ID is less than other,
zero if this ID is equal to other,
greater than zero if this ID is greater than other.
</returns>
        </member>
        <member name="M:NMotive.Channel.KeyIndexRange(NMotive.FrameRange,System.Tuple`2{System.UInt32,System.UInt32}@)">
            <summary>
Get the key index range that falls within or on the edges of the given frame range.
</summary>
            <param name="range">The frame range to search across.</param>
            <param name="indexRange">The start and end indices of the keys that fall within or on the
frame range boundaries. Only valid if <c>true</c> is returned from the method.</param>
            <returns>
                <c>true</c> if a valid key index range was found.</returns>
        </member>
        <member name="M:NMotive.Channel.FindKeyIndex(System.Int32!System.Runtime.CompilerServices.IsLong,System.Boolean)">
            <summary>
Finds the key index for the requested frame, searching forward or back to find it if the requested frame
does not lie at a key. 
</summary>
            <param name="frame">The requested frame.</param>
            <param name="searchForward">A value of <c>true</c> means to search forward.
A value of <c>false</c> means to search backward.</param>
            <returns>The key index or value less than zero if there are no keys or no keys exist at the requested time
or beyond when traveling in the search direction.</returns>
        </member>
        <member name="M:NMotive.Channel.KeyIndex(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Returns the key index at the given frame.
</summary>
            <param name="frame">A frame.</param>
            <returns>The key index at the given frame if it corresponds to a key. Frames that do not
correspond to a key will return a negative value. That value is the number of frames since the last
key, or <c>FrameConstants.NegativeInfinity</c> if there are no keys or the requested frame is before any keys.
For example, if the value returned for a given requested frame is -8, then the previous valid key in time
occurred 8 frames ago in time.</returns>
        </member>
        <member name="M:NMotive.Channel.KeyFrameDistance(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Calculate the distance, in frames, from the given frame index to the nearest key in the key array. Distance
will always be non-negative.
</summary>
            <param name="frame">A key frame.</param>
            <returns>The distance, in frames, from the given frame index to the nearest key in the key array.</returns>
        </member>
        <member name="M:NMotive.Channel.KeyFrame(System.Int32)">
            <summary>
Get the frame index for the key at the given index.
</summary>
            <param name="index">Key frame index.</param>
            <returns>Frame index for the given key frame index.</returns>
        </member>
        <member name="M:NMotive.Channel.IsKey(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Determine if a key is set at the given frame index
</summary>
            <param name="index">Frame index at which to search</param>
            <returns>True if key exists at the give frame index, false otherwise</returns>
        </member>
        <member name="M:NMotive.Channel.FindNextGap(System.Int32!System.Runtime.CompilerServices.IsLong,System.Boolean)">
            <summary>
Attempts to find the next gap, searching either forward or backward from the given frame.
</summary>
            <param name="startFrame">Starting frame for the search.</param>
            <param name="searchForward">A value of <c>true</c> means to search forward.
A value of <c>false</c> means to search backward.</param>
            <returns>The next gap is always returned, even if the given frame is already within a gap. An empty
range will be returned if the requested frame lies outside the key range. If there
are no keys, an infinite range will be returned.</returns>
        </member>
        <member name="M:NMotive.Channel.GapRange(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Returns the full gap range of the gap that the requested frame lies within, or an empty range if
the frame is not in a gap.
</summary>
            <param name="frame">A frame.</param>
            <returns>Full gap range of the gap in which the given frame lies, or an empty range if the
frame is not in a gap.</returns>
        </member>
        <member name="M:NMotive.Channel.FillGaps(NMotive.FrameRange,NMotive.InterpolationType,System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Fills any gaps that exist within the given frame range whose length is less than or equal to 
the given max gap width. The frame range must completely contain the gap(s) to be filled, except
in the case of filling gaps before the first key or after the last key. In that case, the gap
will be filled to the extents of the requested range as long as the range includes a key.
</summary>
            <param name="range">A frame range.</param>
            <param name="interpType">The type of interpolation used.</param>
            <param name="maxGapWidth">Do not fill gaps with widths greater than this value.</param>
            <returns>The number of gaps filled.</returns>
        </member>
        <member name="M:NMotive.Channel.FindNextGap(System.Int32!System.Runtime.CompilerServices.IsLong,NMotive.FrameRange,System.Int32!System.Runtime.CompilerServices.IsLong@,System.Boolean)">
            <summary>
Attempts to find the next gap, searching either forward or backward from the given frame.
The next gap is always returned, even if the given frame is already within a gap. An empty
range will be returned if the requested frame lies outside the key range or there are no gaps
less than or equal to the requested max gap size that lie within the given full range.
</summary>
            <param name="frame">Beginning search frame.</param>
            <param name="fullRange">A frame range.</param>
            <param name="maxGap">Find gaps less than or equal to this number of frames.</param>
            <param name="searchForward">A value of <c>true</c> means to search forward.
A value of <c>false</c> means to search backward.</param>
            <returns>The next gap as a frame range, or an empty frame range if no gaps are found.</returns>
        </member>
        <member name="M:NMotive.Channel.Segments(NMotive.FrameRange)">
            <summary>
Retrieve a list of ranges that have continuous data (i.e. no gaps) for the given range.
</summary>
            <param name="range">A frame range.</param>
            <returns>The list of frame ranges with the given ranges with no gaps.</returns>
        </member>
        <member name="M:NMotive.Channel.Gaps(NMotive.FrameRange)">
            <summary>
Retrieve a list of gaps that lie within a given range. The output array is not cleared
during this call, so values are simply added to the passed array. Any gaps that lie on the boundary
of the requested range will be clipped to lie within the requested range.
</summary>
            <param name="range">A frame range.</param>
            <returns>The list of frame ranges with the given ranges with gaps.</returns>
        </member>
        <member name="M:NMotive.Channel.Gaps">
            <summary>
Retrieve a list of all gaps that currently exist.
</summary>
            <returns>The list of frame ranges with gaps.</returns>
        </member>
        <member name="M:NMotive.Channel.HasGaps(NMotive.FrameRange)">
            <summary>
Returns true if there are any frame gaps between the first key and the last. To test for gaps beyond
the first and last keys, you should pass in the full take frame range that you want to test against.
</summary>
            <param name="range">Check for gaps in this range.</param>
            <returns>
                <c>true</c>if there are gaps in the range. Returns <c>false</c> otherwise.</returns>
        </member>
        <member name="M:NMotive.Channel.HasKeys(NMotive.FrameRange)">
            <summary>
Returns true if keys exist within the given the time range, including endpoints.
</summary>
            <param name="range">Check for keys in this range.</param>
            <returns>
                <c>true</c> if keys exist in the given range.</returns>
        </member>
        <member name="M:NMotive.Channel.HasKeys">
            <summary>
Returns true if keys exist.
</summary>
            <returns>
                <c>true</c> if keys exist.</returns>
        </member>
        <member name="M:NMotive.Channel.ScaleAndOffsetTime(System.Double,System.Double,System.Int32)">
            <summary>
Scale and offset the time component of all keys on the channels by the given amounts.
</summary>
            <param name="offset">Offset.</param>
            <param name="scale">Scale.</param>
            <param name="startFrame">Starting frame.</param>
        </member>
        <member name="M:NMotive.Channel.ClearSelected(NMotive.FrameRange)">
            <summary>
Deletes any selected keys in the given range.
</summary>
            <param name="range">Selected keys withing this range will be deleted.</param>
        </member>
        <member name="M:NMotive.Channel.Clear(NMotive.FrameRange)">
            <summary>
Deletes any keys within or on the edges of the given time range.
</summary>
            <param name="range">Keys withing this range will be deleted.</param>
        </member>
        <member name="M:NMotive.Channel.Clear">
            <summary>
Deletes all keys on this channel and sets it back to its default state.
</summary>
        </member>
        <member name="M:NMotive.Channel.SelectKeys(NMotive.FrameRange,System.Boolean)">
            <summary>
Set the selection state of the keys that fall within (or on the edges of) the given time range.
</summary>
            <param name="range">A frame range.</param>
            <param name="onOff">If <c>true</c> set key states in the range are "on". Otherwise
set key states "off".</param>
            <returns>The number of keys whose selection state was altered.</returns>
        </member>
        <member name="M:NMotive.Channel.SelectKey(System.UInt32!System.Runtime.CompilerServices.IsLong,System.Boolean)">
            <summary>
Set the selection state of the key at the given index.
</summary>
            <param name="index">Index of the key.</param>
            <param name="onOff">If <c>true</c> set key state "on". Otherwise
set key state "off".</param>
        </member>
        <member name="P:NMotive.Channel.Type">
            <summary>
Gets the channel type that this channel applies to within a node.
</summary>
        </member>
        <member name="P:NMotive.Channel.KeyFrameRange">
            <summary>
Gets the frame range covered by all keys.
</summary>
        </member>
        <member name="P:NMotive.Channel.KeyCount">
            <summary>
Gets the number of keys present.
</summary>
        </member>
        <member name="M:NMotive.Channel.#ctor(MoCapCore.cIChannel*,System.Boolean)">
            <summary>
Constructs a channel object with the given native implementation.
Constructed object may optionally take ownership of the native
reference.
</summary>
            <param name="nativeImpl">A pointer to the native implementation.</param>
            <param name="takeOwnershipOfImpl">If true this object will own the 
native implementation and free it upon destruction. If this parameter
value is true it is assumed the native object pointed to is on the heap!</param>
            <exclude />
        </member>
        <member name="F:NMotive.Channel.mOwnImpl">
            <summary>
If <c>true</c> this object owns the native implementation and is
responsible for freeing it.
</summary>
        </member>
        <member name="F:NMotive.Channel.mNativeImpl">
            <exclude />
            <summary>
The native implementation.
</summary>
        </member>
        <member name="F:NMotive.Channel.ChannelType.SizeChannel">
            <exclude />
        </member>
        <member name="F:NMotive.Channel.ChannelType.ScaleChannel">
            <exclude />
        </member>
        <member name="F:NMotive.Channel.ChannelType.RotationChannel">
            <summary>
Rotation channel for nodes.
</summary>
        </member>
        <member name="F:NMotive.Channel.ChannelType.TranslationChannel">
            <summary>
Translation channel for nodes.
</summary>
        </member>
        <member name="F:NMotive.Channel.ChannelType.UnknownChannel">
            <summary>
Reserved for indeterminate types.
</summary>
        </member>
        <member name="T:NMotive.Channel.ChannelType">
            <summary>
Enum for the different channel types.
</summary>
        </member>
        <member name="T:NMotive.Channel">
            <summary>
Channels are owned by Takes and always have an associated ChannelType.
</summary>
        </member>
        <member name="M:NMotive.NMotiveException.#ctor(System.String,System.Exception)">
            <summary>
Constructs an <c>NMotiveException</c> object with the given
message and inner exception.
</summary>
            <param name="message">Exception message.</param>
            <param name="innerException">Inner exception.</param>
        </member>
        <member name="M:NMotive.NMotiveException.#ctor(System.String)">
            <summary>
Constructs an <c>NMotiveException</c> object with the given
message.
</summary>
            <param name="message">Exception message.</param>
        </member>
        <member name="M:NMotive.NMotiveException.#ctor">
            <summary>
Constructs an empty <c>NMotiveException</c> object.
</summary>
        </member>
        <member name="T:NMotive.NMotiveException">
            <summary>
Class for a general exception thrown by NMotive code.
</summary>
        </member>
        <member name="F:NMotive.FrameConstants.Invalid">
            <summary>
Use for testing for a valid frame index.
</summary>
        </member>
        <member name="F:NMotive.FrameConstants.NegativeInfinity">
            <summary>
Use for testing frame index equal to negative infinity.
</summary>
        </member>
        <member name="F:NMotive.FrameConstants.PositiveInfinity">
            <summary>
Use for testing frame index equal to positive infinity.
</summary>
        </member>
        <member name="T:NMotive.FrameConstants">
            <summary>
Constants for frames.
</summary>
        </member>
        <member name="M:NMotive.UID.Generate">
            <summary>
Generates a new ID value.
</summary>
            <returns>A new ID.</returns>
        </member>
        <member name="M:NMotive.UID.GetHashCode">
            <summary>
Hash code for this ID.
</summary>
            <returns>Hash code.</returns>
        </member>
        <member name="M:NMotive.UID.ToString">
            <summary>
String representation.
</summary>
            <returns>String representation.</returns>
        </member>
        <member name="M:NMotive.UID.CompareTo(NMotive.UID)">
            <summary>
Compare to function for ID's.
</summary>
            <param name="rhs">ID to compare to.</param>
            <returns>0 if the ID's are equal, -1 if self is less than the given
ID, and 1 otherwise.</returns>
        </member>
        <member name="M:NMotive.UID.Equals(NMotive.UID)">
            <summary>
Tests for equality of this UID to another.
</summary>
            <param name="rhs">UID to compare self to.</param>
            <returns>true if the given UID is the same as this.</returns>
        </member>
        <member name="M:NMotive.UID.SetValue(System.Int64,System.Int64)">
            <summary>
Set the value for the high and low bits.
</summary>
            <param name="highBits">High bits value.</param>
            <param name="lowBits">Low bits value.</param>
        </member>
        <member name="M:NMotive.UID.op_GreaterThanOrEqual(NMotive.UID,NMotive.UID)">
            <summary>
Greater than or equal comparison operator for ID's.
</summary>
            <param name="lhs">An ID.</param>
            <param name="rhs">An ID.</param>
            <returns>
                <c>true</c> if <c>lhs</c> is greater than or equal to <c>rhs</c></returns>
        </member>
        <member name="M:NMotive.UID.op_GreaterThan(NMotive.UID,NMotive.UID)">
            <summary>
Greater than comparison operator for ID's.
</summary>
            <param name="lhs">An ID.</param>
            <param name="rhs">An ID.</param>
            <returns>
                <c>true</c> if <c>lhs</c> is greater than <c>rhs</c></returns>
        </member>
        <member name="M:NMotive.UID.op_LessThanOrEqual(NMotive.UID,NMotive.UID)">
            <summary>
Less than or equal comparison operator for ID's.
</summary>
            <param name="lhs">An ID.</param>
            <param name="rhs">An ID.</param>
            <returns>
                <c>true</c> if <c>lhs</c> is less than or equal to <c>rhs</c></returns>
        </member>
        <member name="M:NMotive.UID.op_LessThan(NMotive.UID,NMotive.UID)">
            <summary>
Less than comparison operator for ID's.
</summary>
            <param name="lhs">An ID.</param>
            <param name="rhs">An ID.</param>
            <returns>
                <c>true</c> if <c>lhs</c> is less than <c>rhs</c></returns>
        </member>
        <member name="M:NMotive.UID.op_Inequality(NMotive.UID,NMotive.UID)">
            <summary>
Non-equality operator.
</summary>
            <param name="lhs">An ID.</param>
            <param name="rhs">An ID.</param>
            <returns>
                <c>true</c> if the ID's are not equal.</returns>
        </member>
        <member name="M:NMotive.UID.op_Equality(NMotive.UID,NMotive.UID)">
            <summary>
Equality operator.
</summary>
            <param name="lhs">An ID.</param>
            <param name="rhs">An ID.</param>
            <returns>
                <c>true</c> if the ID's are equal.</returns>
        </member>
        <member name="P:NMotive.UID.Valid">
            <summary>
Is the ID valid.
</summary>
        </member>
        <member name="P:NMotive.UID.HighBits">
            <summary>
Gets the high bits.
</summary>
        </member>
        <member name="P:NMotive.UID.LowBits">
            <summary>
Gets the low bits.
</summary>
        </member>
        <member name="M:NMotive.UID.#ctor(NMotive.UID)">
            <summary>
Creates a copy of another <c>UID</c> object.
</summary>
            <param name="other">The ID to copy.</param>
        </member>
        <member name="M:NMotive.UID.#ctor(System.Int64,System.Int64)">
            <summary>
Creates a <c>UID</c> object with the given high bits and low bits.
</summary>
            <param name="highBits">The ID's high bits.</param>
            <param name="lowBits">The ID's low bits.</param>
        </member>
        <member name="M:NMotive.UID.#ctor">
            <summary>
Creates a <c>UID</c> object with value 0 for both high and low bits.
</summary>
        </member>
        <member name="T:NMotive.UID">
            <summary>
Class <c>UID</c> represents a unique ID.  The ID constists of 
two 64 bit integers - the "high" bits and the "low" bits.
</summary>
        </member>
        <member name="P:NMotive.Keyframe`1.Frame">
            <summary>
Gets and sets the frame number.
</summary>
        </member>
        <member name="P:NMotive.Keyframe`1.Value">
            <summary>
Gets and sets the key frame value.
</summary>
        </member>
        <member name="M:NMotive.Keyframe`1.op_Inequality(NMotive.Keyframe`1{`0},NMotive.Keyframe`1{`0})">
            <summary>
Non-equality operator for key frames.
</summary>
            <param name="lhs">Left hand side key frame.</param>
            <param name="rhs">Right hand side key frame.</param>
            <returns>
                <c>true</c> if lhs is not equal to right hand side.</returns>
        </member>
        <member name="M:NMotive.Keyframe`1.op_Equality(NMotive.Keyframe`1{`0},NMotive.Keyframe`1{`0})">
            <summary>
Equality operator for key frames.
</summary>
            <param name="lhs">Left hand side key frame.</param>
            <param name="rhs">Right hand side key frame.</param>
            <returns>
                <c>true</c> if lhs is equal to right hand side.</returns>
        </member>
        <member name="M:NMotive.Keyframe`1.op_GreaterThanOrEqual(NMotive.Keyframe`1{`0},NMotive.Keyframe`1{`0})">
            <summary>
Greater than or equal operator for key frames.
</summary>
            <param name="lhs">Left hand side key frame.</param>
            <param name="rhs">Right hand side key frame.</param>
            <returns>
                <c>true</c> if lhs is greater than or equal right hand side.</returns>
        </member>
        <member name="M:NMotive.Keyframe`1.op_LessThanOrEqual(NMotive.Keyframe`1{`0},NMotive.Keyframe`1{`0})">
            <summary>
Less than or equal operator for key frames.
</summary>
            <param name="lhs">Left hand side key frame.</param>
            <param name="rhs">Right hand side key frame.</param>
            <returns>
                <c>true</c> if lhs is less than or equal right hand side.</returns>
        </member>
        <member name="M:NMotive.Keyframe`1.op_GreaterThan(NMotive.Keyframe`1{`0},NMotive.Keyframe`1{`0})">
            <summary>
Greater than operator for key frames.
</summary>
            <param name="lhs">Left hand side key frame.</param>
            <param name="rhs">Right hand side key frame.</param>
            <returns>
                <c>true</c> if lhs is greater than right hand side.</returns>
        </member>
        <member name="M:NMotive.Keyframe`1.op_LessThan(NMotive.Keyframe`1{`0},NMotive.Keyframe`1{`0})">
            <summary>
Less than operator for key frames.
</summary>
            <param name="lhs">Left hand side key frame.</param>
            <param name="rhs">Right hand side key frame.</param>
            <returns>
                <c>true</c> if lhs is less than right hand side.</returns>
        </member>
        <member name="M:NMotive.Keyframe`1.CompareTo(NMotive.Keyframe`1{`0})">
            <summary>
Compares this key frame to another.
Comparison is made using the frame numbers.
</summary>
            <param name="other">A key frame.</param>
            <returns>
Less than zero if this frame is less than other,
zero if this frame is equal to other,
greater than zero if this frame is greater than other.
</returns>
        </member>
        <member name="M:NMotive.Keyframe`1.Equals(NMotive.Keyframe`1{`0})">
            <summary>
Tests equality of this key frame to another.
Key frames are equal if the have the same number and value.
</summary>
            <param name="other">A key frame.</param>
            <returns>
                <c>true</c> if this key frame is equal to other.</returns>
        </member>
        <member name="M:NMotive.Keyframe`1.#ctor(`0,System.Int32)">
            <summary>
Constructs a key frame with the given value.
</summary>
            <param name="val">Value for this key frame.</param>
            <param name="frame">Frame number for this key frame.</param>
        </member>
        <member name="T:NMotive.Keyframe`1">
            <summary>
Generic representation for key frames.
</summary>
            <typeparam name="T">frame data type.</typeparam>
        </member>
        <member name="M:NMotive.FrameRange.Decrement">
            <summary>
Shift the range down by one frame.
</summary>
            <returns>This frame range decremented.</returns>
        </member>
        <member name="M:NMotive.FrameRange.Increment">
            <summary>
Shift the range up by one frame.
</summary>
            <returns>This frame range incremented.</returns>
        </member>
        <member name="M:NMotive.FrameRange.op_Decrement">
            <summary>
Shift the range down by one frame.
</summary>
            <returns>A reference to self.</returns>
        </member>
        <member name="M:NMotive.FrameRange.op_Increment">
            <summary>
Shift the range up by one frame.
</summary>
            <returns>A reference to self.</returns>
        </member>
        <member name="M:NMotive.FrameRange.op_GreaterThan(NMotive.FrameRange,System.Int32)">
            <summary>
Greater than comparison operator for a frame range and a frame index.
</summary>
            <param name="lhs">A frame range.</param>
            <param name="frameIndex">A frame index.</param>
            <returns>
                <c>true</c>if the start of the frame range is greater than the 
frame index.</returns>
        </member>
        <member name="M:NMotive.FrameRange.op_GreaterThan(NMotive.FrameRange,NMotive.FrameRange)">
            <summary>
Greater than comparison operator for frame ranges.
</summary>
            <param name="lhs">A frame range.</param>
            <param name="rhs">A frame range.</param>
            <returns>
                <c>true</c> if start of <c>lhs</c> is greater than end of <c>rhs</c> (no range overlap).</returns>
        </member>
        <member name="M:NMotive.FrameRange.op_LessThan(NMotive.FrameRange,System.Int32)">
            <summary>
Less than comparison operator for a frame range and a frame index.
</summary>
            <param name="lhs">A frame range.</param>
            <param name="frameIndex">A frame index.</param>
            <returns>
                <c>true</c>if the endpoint of the frame range is less than the 
frame index.</returns>
        </member>
        <member name="M:NMotive.FrameRange.op_LessThan(NMotive.FrameRange,NMotive.FrameRange)">
            <summary>
Less than comparison operator for frame ranges.
</summary>
            <param name="lhs">A frame range.</param>
            <param name="rhs">A frame range.</param>
            <returns>
                <c>true</c> if end of <c>lhs</c> is less than start time of <c>rhs</c> (no range overlap).</returns>
        </member>
        <member name="M:NMotive.FrameRange.op_Inequality(NMotive.FrameRange,NMotive.FrameRange)">
            <summary>
Non-equality operator for frame ranges.
</summary>
            <param name="lhs">A frame range.</param>
            <param name="rhs">A frame range.</param>
            <returns>Two frame ranges are equal if their endpoints coincide.</returns>
        </member>
        <member name="M:NMotive.FrameRange.op_Equality(NMotive.FrameRange,NMotive.FrameRange)">
            <summary>
Equality operator for frame ranges.
</summary>
            <param name="lhs">A frame range.</param>
            <param name="rhs">A frame range.</param>
            <returns>Two frame ranges are equal if their endpoints coincide.</returns>
        </member>
        <member name="M:NMotive.FrameRange.ToString">
            <summary>
Creates a string representation of the range.
</summary>
            <returns>A string representation of the range.</returns>
        </member>
        <member name="M:NMotive.FrameRange.GetHashCode">
            <summary>Hash code for frame range objects.</summary>
            <returns>A has code for this object.</returns>
        </member>
        <member name="M:NMotive.FrameRange.CompareTo(NMotive.FrameRange)">
            <summary>
Comparison method for ordering.
</summary>
            <param name="rhs">Object to compare self to.</param>
            <returns>
Less than zero if self is less than <c>rhs</c>,
Zero if self is equal to <c>rhs</c>,
Greater than zero if self is greater than <c>rhs</c></returns>
        </member>
        <member name="M:NMotive.FrameRange.Equals(NMotive.FrameRange)">
            <summary>
Checks equality of ranges. Ranges are equal if their endpoints
coincide.
</summary>
            <param name="rhs">The range to compare this range to.</param>
            <returns>
                <c>true</c> if the ranges are equal.</returns>
        </member>
        <member name="M:NMotive.FrameRange.Intersection(NMotive.FrameRange)">
            <summary>
Returns the intersection of this range with the one given.
</summary>
            <param name="range">Range to intersect with.</param>
            <returns>The intersection of the given range with this range.</returns>
        </member>
        <member name="M:NMotive.FrameRange.Intersects(NMotive.FrameRange)">
            <summary>
Returns true if the given range intersects this one. Intersection will be true even if only the
edges coincide.
</summary>
            <param name="range">Range to check for intersection.</param>
            <returns>
                <c>true</c> if the given range intersects this range.</returns>
        </member>
        <member name="M:NMotive.FrameRange.Contains(System.Int32)">
            <summary>
Checks if this range contains the given frame index.
</summary>
            <param name="frameIndex">Frame index to check.</param>
            <returns>
                <c>true</c> if this range contains the index.</returns>
        </member>
        <member name="M:NMotive.FrameRange.Contains(NMotive.FrameRange)">
            <summary>
Returns true if this range includes the given time.
</summary>
            <param name="range">Range to check.</param>
            <returns>
                <c>true</c> if this range contains the given range completely.</returns>
        </member>
        <member name="M:NMotive.FrameRange.Clear">
            <summary>
Clears the range to an empty range.
</summary>
        </member>
        <member name="M:NMotive.FrameRange.Offset(System.Int32)">
            <summary>
Offsets the range by the given amount, if the range is not empty.
</summary>
            <param name="amount">Number of frames to offset by.</param>
        </member>
        <member name="M:NMotive.FrameRange.Expand(System.Int32)">
            <summary>
Expand the range by the given number of frames at each end. Has no effect if the
range was empty to begin with, or if the given increment is negative.
</summary>
            <param name="increment">Number of frames to expand the range by.</param>
        </member>
        <member name="M:NMotive.FrameRange.Intersect(NMotive.FrameRange)">
            <summary>
Intersects self with another range.
<param name="range">Frame range to intersect.</param></summary>
        </member>
        <member name="M:NMotive.FrameRange.SetExtents(System.Int32,System.Int32)">
            <summary>
Sets both the starting and ending frame indices for the range.
</summary>
            <param name="startIndex">The starting index for the range.</param>
            <param name="endIndex">The ending index for the range.</param>
        </member>
        <member name="P:NMotive.FrameRange.Center">
            <summary>
Gets the center of the range.
</summary>
        </member>
        <member name="P:NMotive.FrameRange.IsEmpty">
            <summary>
returns <c>true</c> if the range is empty.
</summary>
        </member>
        <member name="P:NMotive.FrameRange.Length">
            <summary>
Gets the length of the range in frames.
</summary>
        </member>
        <member name="P:NMotive.FrameRange.End">
            <summary>
Gets and sets the end frame of the range. If the range was previously
 empty, both start and end frames will be set to the given frame.
</summary>
        </member>
        <member name="P:NMotive.FrameRange.Start">
            <summary>
Gets and set the start frame of the range. If the range was
previously empty, both start and end frames will be set to the given frame.
</summary>
        </member>
        <member name="M:NMotive.FrameRange.#ctor(Core.cFrameRange*)">
            <exclude />
        </member>
        <member name="M:NMotive.FrameRange.#ctor(System.Int32,System.Int32)">
            <summary>
Constructs a <c>FrameRange</c> instance with the given
start and end indices.
</summary>
            <param name="startIndex"> The ranges starting index.</param>
            <param name="endIndex">The ranges ending index.</param>
        </member>
        <member name="M:NMotive.FrameRange.#ctor">
            <summary>
Default constructor. Behavior is undefined.
</summary>
        </member>
        <member name="F:NMotive.FrameRange.Forever">
            <summary>
Constant range object representing an infinitely long range.
</summary>
        </member>
        <member name="F:NMotive.FrameRange.Empty">
            <summary>
Constant range object representing an empty range.
</summary>
        </member>
        <member name="T:NMotive.FrameRange">
            <summary>
Class representing a range of contiguous frames.
</summary>
        </member>
        <member name="T:NMotive.InterpolationType">
            <summary>
Enumeration type of interpolation options.
</summary>
        </member>
        <member name="F:NMotive.InterpolationType.ModelBased">
            <summary>
Key value created from model based expected position.
</summary>
        </member>
        <member name="F:NMotive.InterpolationType.PatternBased">
            <summary>
Key value created from pattern based expected position.
</summary>
        </member>
        <member name="F:NMotive.InterpolationType.Hermite">
            <summary>
Hermite interpolation. Key value follows a cubic Hermite spline 
between key n and key n+1.
</summary>
        </member>
        <member name="F:NMotive.InterpolationType.Linear">
            <summary>
Linear interpolation. Key value proceeds in straight line from key n 
to key n+1
</summary>
        </member>
        <member name="F:NMotive.InterpolationType.Constant">
            <summary>
Constant interpolation. Key value is fixed until next key is encountered.
</summary>
        </member>
        <member name="M:MoCapCore.cIChannelFactory.CreateInstance(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Creates a new channel of the type specified by this factory.</summary>
            <param name="channelName">A name for the channel, such as Rotation or Translation. This name designates a role
that the channel fills when attached to a node.</param>
        </member>
        <member name="M:MoCapCore.cIChannelFactory.TypeName">
            <summary>Human-readable type name for the object type that this factory creates.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.Load(Core.cIReader*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID*)">
            <summary>Load the object from the given serialization source.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.Save(Core.cIWriter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Serialize to the given writer.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.SetSamplesPerFrame(System.Int32)">
            <summary>Set the number of value samples stored per frame.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.SamplesPerFrame">
            <summary>Retrieve the number of value samples stored per frame.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.KeyIndexRange(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.pair&lt;System.UInt32,System.UInt32&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Get the key index range that falls within or on the edges of the given frame range.</summary>
            <param name="timeRange">The frame range to search across.</param>
            <param name="idxRange">The start and end indices of the keys that fall within or on the
frame range boundaries. Only valid if true is returned from the method.</param>
            <returns>True if a valid key index range was found.</returns>
        </member>
        <member name="M:MoCapCore.cIChannel.FindKeyIndex(System.Int32,System.Boolean)">
            <summary>
Finds the key index for the requested frame, searching forward or back to find it if the requested frame
does not lie at a key. Returns a value less than 0 if there are no keys or no keys exist at the requested time
or beyond when traveling in the search direction.
</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.KeyIndex(System.Int32)">
            <summary>
Returns the key index at the given frame, if it corresponds to a key. Frames that do not
correspond to a key will return a negative value. That value is the number of frames since the last
key, or FrameConstants::NegativeInfinity if there are no keys or the requested frame is before any keys.
For example, if the value returned for a given requested frame is -8, then the previous valid key in time
occurred 8 frames ago in time.
</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.KeyFrameRange">
            <summary>Get the frame range covered by all keys.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.KeyFrameDistance(System.Int32)">
            <summary>
Calculate the distance, in frames, from the given frame to the nearest key in the key array. Distance
will always be non-negative.
</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.IsKey(System.Int32)">
            <summary>Determine if a key is set at the given time</summary>
            <param name="tm">FrameIndex at which to search</param>
            <returns>True if a key exists, false otherwise</returns>
        </member>
        <member name="M:MoCapCore.cIChannel.KeyCount">
            <summary>Returns the number of keys present.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.FillGaps(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MoCapCore.cIChannel.eInterpolationType,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Fills any gaps that exist within the given frame range whose length is less than or equal to 
the given max gap width. The frame range must completely contain the gap(s) to be filled, except
in the case of filling gaps before the first key or after the last key. In that case, the gap
will be filled to the extents of the requested range as int as the range includes a key.
</summary>
            <returns>The number of gaps filled.</returns>
        </member>
        <member name="M:MoCapCore.cIChannel.FindNextGap(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>
Attempts to find the next gap, searching either forward or backward from the given frame.
The next gap is always returned, even if the given frame is already within a gap. An empty
range will be returned if the requested frame lies outside the key range. If there
are no keys, an infinite range will be returned.
</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.FindNextGap(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>
Attempts to find the next gap, searching either forward or backward from the given frame.
The next gap is always returned, even if the given frame is already within a gap. An empty
range will be returned if the requested frame lies outside the key range or there are no gaps
less than or equal to the requested max gap size that lie within the given full range.
</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.Segments(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Core.cFrameRangeSet*)">
            <summary>Retrieve a list of ranges that have continuous data (i.e. no gaps) for the given range.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.GapRange(System.Int32)">
            <summary>
Returns the full gap range of the gap that the requested frame lies within, or an empty range if
the frame is not in a gap.
</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.Gaps(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Retrieve a frame range set of gaps that lie within a given range. Any gaps that lie on the boundary
of the requested range will be clipped to lie within the requested range.
</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.HasGaps(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Returns true if there are any frame gaps between the first key and the last. To test for gaps beyond
the first and last keys, you should pass in the full take frame range that you want to test against.
</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.HasKeys(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if keys exist within the given the time range, including endpoints.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.HasKeys">
            <summary>Returns true if keys exist.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.ScaleAndOffsetTime(System.Double,System.Double,System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Scale and offset the time component of all keys on the channels by the given amounts.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.ShiftKeys(System.Int32!System.Runtime.CompilerServices.IsConst)">
            <summary>Shift any existing keys by the number of frames indicated. Positive frame shift will result in
higher frame numbers.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.ClearSelected(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Deletes any selected keys in the given range.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.Clear">
            <summary>Clear all keys.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.Clear(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Deletes any keys within or on the edges of the given time range. To clear all, just pass cFrameRange::Forever</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.SelectAllKeys(System.Boolean)">
            <summary>Set the selection state of all keys.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.SelectKeys(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Set the selection state of the keys that fall within (or on the edges of) the given time range.</summary>
            <returns>The number of keys whose selection state was altered.</returns>
        </member>
        <member name="M:MoCapCore.cIChannel.SelectKey(System.UInt32,System.Boolean)">
            <summary>Set the selection state of the key at the given key index.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.FinishEdit">
            <summary>Finishes an edit operation and issues any needed change notifications.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.StartEdit">
            <summary>
Begins an edit operation on this channel. All notifications are delayed until the edit
operation is completed with a matching call to FinishEdit().
</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.CopyFrom(MoCapCore.cIChannel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Copy the contents from the given channel into this one. This is a replacement for attempting
to override the assignment operator, which is messy to virtualize.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.Name">
            <summary>A name used to identify what role this channel plays, usually in a node.</summary>
        </member>
        <member name="M:MoCapCore.cIChannel.TypeName">
            <summary>The channel type that this channel applies to within a node.</summary>
        </member>
        <member name="T:MoCapCore.cIChannel.eInterpolationType">
            <summary>Key interpolation types.</summary>
        </member>
        <member name="T:MoCapCore.cIChannel">
            <summary>Pure virtual base class for animation track types</summary>
        </member>
        <member name="M:MoCapCore.cIChannelObserver.OnKeySelectionChanged(MoCapCore.cIChannel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the selection state of any keys change.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelObserver.OnKeyRangeChanged(MoCapCore.cIChannel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called when the overall frame range for the key array changes.</summary>
        </member>
        <member name="M:MoCapCore.cIChannelObserver.OnSetKeys(MoCapCore.cIChannel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Called whenever new keys have been created, or existing keys have been edited or deleted.</summary>
        </member>
        <member name="F:MoCapCore.cUndoStack.kDefaultMaxMemSize">
            <summary>The default maximum memory size for the undo buffer before serialization starts to engage.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.Enabled">
            <summary>True if the undo stack is enabled (i.e. will accept new undo items).</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.SetEnabled(System.Boolean)">
            <summary>Enable or disable acceptance of new undo items.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.Editing">
            <summary>True if an edit operation is active.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.FinishEdit(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Finishes and commits the changes to a usable undo list.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.CancelEdit">
            <summary>Cancels any current edit operation and undoes any items on the current edit stack.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.AddItem(MoCapCore.cIUndoItem*)">
            <summary>Add an item to the currently active edit list. Takes ownership of the item.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.StartEdit">
            <summary>Start a new edit operation if one is not already active.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.RedoCaption">
            <summary>Returns the current redo caption, or empty string if none.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.UndoCaption">
            <summary>Returns the current undo caption, or empty string if none.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.InUndoRedo">
            <summary>Returns true if an undo or redo is currently being executed.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.CanRedo">
            <summary>Returns true if there is an available redo.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.CanUndo">
            <summary>Returns true if there is an available undo.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.Clear">
            <summary>Clears the undo/redo stack completely and with extreme prejudice.</summary>
        </member>
        <member name="M:MoCapCore.cUndoStack.Redo">
            <summary>Redo the top group of items in the list that was previously undone.</summary>
            <returns>True if there was a list to redo and redo was successful.</returns>
        </member>
        <member name="M:MoCapCore.cUndoStack.Undo">
            <summary>Undo the top group of items in the list.</summary>
            <returns>True if there was a list to undo and undo was successful.</returns>
        </member>
        <member name="M:MoCapCore.cUndoStack.SetMaxMemSize(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Set a hint for how much memory usage is acceptable before serialization of items in the list
should start to occur.
</summary>
        </member>
        <member name="T:MoCapCore.cUndoStack">
            <summary>
Manages an undo stack composed of grouped undo items. Each undo/redo may affect a long list of edits
that occurred, so individual undo items are grouped into lists that can be undone/redone as a unit.
If a disk cache file is set, undo items will be cached to disk when the max mem size for the undo
stack is exceeded.
</summary>
        </member>
        <member name="M:MoCapCore.cUndoList.MemorySize">
            <summary>
Cumulative size (in memory) of all items in the list. Will be a small number if the list items
have been serialized to disk.
</summary>
        </member>
        <member name="M:MoCapCore.cUndoList.SetCaption(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Set the caption to use for this set of operations.</summary>
        </member>
        <member name="M:MoCapCore.cUndoList.AddItem(MoCapCore.cIUndoItem*)">
            <summary>Add an item to the list. Takes ownership of the item.</summary>
        </member>
        <member name="M:MoCapCore.cIUndoItem.MemorySize">
            <summary>The (approximate) size of this item in memory when not serialized.</summary>
        </member>
        <member name="M:MoCapCore.cIUndoItem.Redo">
            <summary>Redo any previously undone data edits that are part of this item.</summary>
        </member>
        <member name="M:MoCapCore.cIUndoItem.Undo">
            <summary>Undo any data edits that are part of this item.</summary>
        </member>
        <member name="T:MoCapCore.cIUndoItem">
            <summary>
Derive from this interface to create units of undo-able data edits. Multiple undo items can be pushed
onto the stack between UndoStack::StartEdit()/UndoStack::FinishEdit() calls and they will be collected
into a single undoable operation.
When implementing Redo(), remember that Undo() will have been called first on your undo item, so any
state information in the UndoItem should represent what the original state was, and how to Redo the
edit.
</summary>
        </member>
        <member name="M:Core.cThreadLock.Unlock">
            <summary>
Release the lock. The lock must have been previously acquired with a call to Lock() or a
successful call to TryLock(). Declared const so it can be used in const methods.
</summary>
        </member>
        <member name="M:Core.cThreadLock.Lock">
            <summary>Acquire a lock. Declared const so it can be used in const methods.</summary>
        </member>
        <member name="M:Core.cThreadLock.TryLock">
            <summary>Try to acquire a lock. Declared const so it can be used in const methods.</summary>
            <returns>True if the lock was engaged.</returns>
        </member>
        <member name="T:Core.cThreadLock">
            <summary>
A platform-neutral thread lock that can be used to ensure single-thread entry into blocks of code
surrounded by Lock()/TryLock() and Unlock() pairs. Every call to Lock()/TryLock() must be matched
with a call to Unlock()
</summary>
        </member>
        <member name="M:Core.cIBasicStream.Size">
            <summary>Reports the total current size of the stream.</summary>
        </member>
        <member name="M:Core.cIBasicStream.Seek(System.UInt64)">
            <summary>Seek to the requested (absolute) position in the stream.</summary>
        </member>
        <member name="M:Core.cIBasicStream.Tell">
            <summary>Returns the current position in the file stream.</summary>
        </member>
        <member name="M:Core.cTime.CurrentDateTimeString(System.Boolean)">
            <summary>Generate a string that contains the current local date and time in human-readable format.</summary>
        </member>
        <member name="M:Core.cTime.CurrentDateString">
            <summary>Generate a string that contains the current local date in human-readable format.</summary>
        </member>
        <member name="M:Core.cTime.CurrentDateTime(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Current local time.</summary>
        </member>
        <member name="M:Core.cTime.CurrentDateTime">
            <summary>Current local time.</summary>
        </member>
        <member name="M:Core.cTime.Valid">
            <summary>Returns true if the contained time is valid (not invalid).</summary>
        </member>
        <member name="M:Core.cTime.InFrames(Core.cTime!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Calculate the time in frames given a frame time interval.</summary>
        </member>
        <member name="M:Core.cTime.Average(Core.cTime!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Calculate the average time between this and the given time.</summary>
        </member>
        <member name="M:Core.cTime.InSeconds">
            <summary>Time in seconds only (i.e. hours, minutes, etc. all converted into seconds)</summary>
        </member>
        <member name="M:Core.cTime.SetHoursMinutesSeconds(System.Double,System.Double,System.Double)">
            <summary>Set the time based on real time measures.</summary>
        </member>
        <member name="M:Core.cTime.SetInSeconds(System.Double)">
            <summary>Set the full time based on a number of seconds.</summary>
        </member>
        <member name="T:Core.cTime">
            <summary>Represents a relative time.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.UpdateExtents(System.Int32,Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Update the extents on the range with the given index in the array.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.SortRanges">
            <summary>Sort ranges in ascending order.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.ConsolidateRanges">
            <summary>Consolidate overlapping ranges and sort them in ascending order.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.TotalFrames">
            <summary>Calculates the total number of frames in the full set of ranges.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.Range(System.Int32)">
            <summary>Returns the n'th disjoint range in the set.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.RangeCount">
            <summary>Returns the number of disjoint ranges contained in the set.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.Contains(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if this set includes the given frame.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.Contains(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if one of the ranges in the set completely contains the given range.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.Extents">
            <summary>Returns a frame range with the lowest and highest frames contained in the set of ranges.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.Empty">
            <summary>Returns true if there are no contained ranges.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.Clear">
            <summary>Clears the list of ranges.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.Invert">
            <summary>
Inverts the range set in place. If you invert a range that does not include positive and negative
infinity, the inverted set will extend to those limits.
</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.Intersection(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Returns the intersection of the given frame range with the this range set, or an empty frame range
if no intersection.
</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.Intersects(Core.cFrameRangeSet!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if the given range set intersects this set.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.Intersects(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if the given range intersects this set.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.Intersect(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Sets this range set to the intersection with the given frame range.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.Subtract(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Subtract the given range from the set, if it is included.</summary>
            <returns>True if the set was changed as a result (i.e. the set did include all or part of the given range.</returns>
        </member>
        <member name="M:Core.cFrameRangeSet.AddNoMerge(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Add the given frame range into the set without merging overlapping ranges.</summary>
        </member>
        <member name="M:Core.cFrameRangeSet.Add(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Add (union) the given frame range into the set.</summary>
            <returns>True if the set was changed (the given range was not already included).</returns>
        </member>
        <member name="M:Core.cFrameRangeSet.op_Assign(std.vector&lt;Core.cFrameRange,std.allocator&lt;Core.cFrameRange&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>The passed set of frame ranges is assumed to be in non-overlapping, always-increasing order.</summary>
        </member>
        <member name="T:Core.cFrameRangeSet">
            <summary>
Represents a (non-overlapping) set of frame ranges. Ranges are stored in strictly increasing order of
frame ranges for convenience when using the class.
</summary>
        </member>
        <member name="M:Core.cFrameRange.op_Decrement">
            <summary>Shift the range down by one frame.</summary>
        </member>
        <member name="M:Core.cFrameRange.op_Increment">
            <summary>Shift the range up by one frame.</summary>
        </member>
        <member name="M:Core.cFrameRange.Intersects(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Returns true if the given range intersects this one. Intersection will be true even if only the
edges coincide.
</summary>
        </member>
        <member name="M:Core.cFrameRange.Contains(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if this range includes the given time.</summary>
        </member>
        <member name="M:Core.cFrameRange.Contains(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns true if this range completely contains the given range.</summary>
        </member>
        <member name="M:Core.cFrameRange.Length">
            <summary>Returns the length (end time minus start time) of the range.</summary>
        </member>
        <member name="M:Core.cFrameRange.Center">
            <summary>Get the center point of the range.</summary>
        </member>
        <member name="M:Core.cFrameRange.End">
            <summary>Get the range end frame.</summary>
        </member>
        <member name="M:Core.cFrameRange.Start">
            <summary>Get the range start frame.</summary>
        </member>
        <member name="M:Core.cFrameRange.Empty">
            <summary>Returns true if the frame range is empty (i.e. start frame &gt; end frame).</summary>
        </member>
        <member name="M:Core.cFrameRange.Clear">
            <summary>Clears the range to an empty range.</summary>
        </member>
        <member name="M:Core.cFrameRange.Offset(System.Int32!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Offsets the range by the given amount, if the range is not empty.</summary>
        </member>
        <member name="M:Core.cFrameRange.Intersection(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Returns the intersection of this range with the one given.</summary>
        </member>
        <member name="M:Core.cFrameRange.Expand(System.Int32)">
            <summary>
Expand the range by the given number of frames at each end. Has no effect if the
range was empty to begin with, or if the given increment is negative.
</summary>
        </member>
        <member name="M:Core.cFrameRange.Intersect(Core.cFrameRange!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Intersects this range with the one given.</summary>
        </member>
        <member name="M:Core.cFrameRange.SetExtents(System.Int32,System.Int32)">
            <summary>Set both start and end of the range.</summary>
        </member>
        <member name="M:Core.cFrameRange.SetEnd(System.Int32)">
            <summary>
Set the end frame of the range. If the range was previously empty, both start and end frames
will be set to the given frame.
</summary>
        </member>
        <member name="M:Core.cFrameRange.SetStart(System.Int32)">
            <summary>
Set the start frame of the range. If the range was previously empty, both start and end frames
will be set to the given frame.
</summary>
        </member>
        <member name="T:Core.cFrameRange">
            <summary>Represents a range of time.</summary>
        </member>
        <member name="M:Core.cICameraFrameFactory.CreateInstance">
            <summary>Create a new instance of a camera frame.</summary>
        </member>
        <member name="M:Core.cTimeCode.TimeCode">
            <summary>Composite, compact timecode value (hours/mins/secs/frames).</summary>
        </member>
        <member name="M:Core.cAtomicLong.SetValue(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>Performs an atomic set value.</summary>
        </member>
        <member name="M:Core.cAtomicLong.SetIfEqual(System.Int32!System.Runtime.CompilerServices.IsLong,System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>Sets the variable to the given value if its current value matches compareVal.</summary>
        </member>
        <member name="M:Core.cAtomicLong.Decrement">
            <summary>Performs an atomic decrement.</summary>
        </member>
        <member name="M:Core.cAtomicLong.Increment">
            <summary>Performs an atomic increment.</summary>
        </member>
        <member name="M:Core.cAtomicLong.op_Assign(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>Performs an atomic assignment.</summary>
        </member>
        <member name="T:Core.cAtomicLong">
            <summary>
A class that is thread-safe and lock-free by using atomic operations for manipulating a single
long integer value.
</summary>
        </member>
        <member name="M:Core.cUID.Generate">
            <summary>Generate a new UID value.</summary>
        </member>
        <member name="M:Core.cUID.Valid">
            <summary>Returns true if the ID is valid (i.e. not equal to kInvalid).</summary>
        </member>
        <member name="M:Core.cUID.HighBits">
            <summary>Get the high 64 bits of the UID.</summary>
        </member>
        <member name="M:Core.cUID.LowBits">
            <summary>Get the low 64 bits of the UID.</summary>
        </member>
        <member name="M:Core.cUID.SetValue(System.UInt64,System.UInt64)">
            <summary>
Set the value of the UID from two long integer values. It is up to the caller to ensure that
the resulting UID is unique.
</summary>
        </member>
        <member name="M:Core.cUID.#ctor">
            <summary>
Create a default UID. In order to create a UID that has a valid unique identifier you
must call Generate().
</summary>
        </member>
        <member name="T:Core.cUID">
            <summary>
A platform-neutral 128-bit universal identifier. It is essentially guaranteed to never
generate the same ID twice.
</summary>
        </member>
        <member name="M:Core.CoreCount">
            <summary>Query the number of cores available on this machine.</summary>
        </member>
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cTimeManager.Record(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cProfileManager.ResetToDefault(std.vector<std.basic_string<System.Char,std.char_traits{System.Char},std.allocator<System.Char>>,std.allocator<std.basic_string<System.Char,std.char_traits{System.Char},std.allocator<System.Char>>>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cProfileManager.AvailableProfiles(std.vector<std.basic_string<System.Char,std.char_traits{System.Char},std.allocator<System.Char>>,std.allocator<std.basic_string<System.Char,std.char_traits{System.Char},std.allocator<System.Char>>>>*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cConstraint.ID'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.setup_new_connection'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.poll_for_cookie(timeval!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.clearBuffers'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.pack_sender_description(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.pack_type_description(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Endpoint.status'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Endpoint.rhostname'. -->
        <!-- Discarding badly formed XML document comment for member 'T:timeval'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.connect_udp_to(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.set_tcp_outbuf_size(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.poll_for_cookie(timeval!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.clearBuffers'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.setNICaddress(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Endpoint_IP.d_udpLobSocket'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.getOneTCPMessage(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt64)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Endpoint_IP.d_tcpOutbuf'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Connection.d_endpoints'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Connection.handle_log_message(System.Void*,vrpn_HANDLERPARAM)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Connection.pack_type_description(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:timeval'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_copy_service_name(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_copy_file_name(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_copy_machine_name(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_TextPrinter.vrpn_TextPrinter_Watch_Entry.next'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_TextPrinter.d_ostream'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_BaseClassUnique.send_text_message(vrpn_TEXT_SEVERITY)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cTimeManager.Record(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cMultiDeviceTrack.DataTypes'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cMultiDeviceFrame.DataTypes'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cTimeManager.Record(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.setup_new_connection'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.poll_for_cookie(timeval!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.clearBuffers'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.pack_sender_description(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.pack_type_description(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Endpoint.status'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Endpoint.rhostname'. -->
        <!-- Discarding badly formed XML document comment for member 'T:timeval'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.connect_udp_to(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.set_tcp_outbuf_size(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.poll_for_cookie(timeval!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.clearBuffers'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.setNICaddress(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Endpoint_IP.d_udpLobSocket'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.getOneTCPMessage(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt64)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Endpoint_IP.d_tcpOutbuf'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Connection.d_endpoints'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Connection.handle_log_message(System.Void*,vrpn_HANDLERPARAM)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Connection.pack_type_description(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:timeval'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_copy_service_name(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_copy_file_name(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_copy_machine_name(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_TextPrinter.vrpn_TextPrinter_Watch_Entry.next'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_TextPrinter.d_ostream'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_BaseClassUnique.send_text_message(vrpn_TEXT_SEVERITY)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cConstraint.ID'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cTimeManager.Record(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cTimeManager.Record(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cTimeManager.Record(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cTimeManager.Record(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cTimeManager.Record(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cConstraint.ID'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.setup_new_connection'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.poll_for_cookie(timeval!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.clearBuffers'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.pack_sender_description(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.pack_type_description(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Endpoint.status'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Endpoint.rhostname'. -->
        <!-- Discarding badly formed XML document comment for member 'T:timeval'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.connect_udp_to(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.set_tcp_outbuf_size(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.poll_for_cookie(timeval!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.clearBuffers'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.setNICaddress(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Endpoint_IP.d_udpLobSocket'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.getOneTCPMessage(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt64)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Endpoint_IP.d_tcpOutbuf'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Connection.d_endpoints'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Connection.handle_log_message(System.Void*,vrpn_HANDLERPARAM)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Connection.pack_type_description(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:timeval'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_copy_service_name(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_copy_file_name(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_copy_machine_name(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_TextPrinter.vrpn_TextPrinter_Watch_Entry.next'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_TextPrinter.d_ostream'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_BaseClassUnique.send_text_message(vrpn_TEXT_SEVERITY)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cTimeManager.Record(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MotiveCore.cTRCExporter.Scale'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cTimeManager.Record(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cTimeManager.Record(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cConstraint.ID'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cTimeManager.Record(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cTimeManager.Record(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cTimeManager.Record(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cProfileManager.ResetToDefault(std.vector<std.basic_string<System.Char,std.char_traits{System.Char},std.allocator<System.Char>>,std.allocator<std.basic_string<System.Char,std.char_traits{System.Char},std.allocator<System.Char>>>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cProfileManager.AvailableProfiles(std.vector<std.basic_string<System.Char,std.char_traits{System.Char},std.allocator<System.Char>>,std.allocator<std.basic_string<System.Char,std.char_traits{System.Char},std.allocator<System.Char>>>>*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cTimeManager.Record(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cTimeManager.Record(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cTimeManager.Record(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cTimeManager.Record(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cTimeManager.Record(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cTimeManager.Record(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cTimeManager.Record(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cTimeManager.Record(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.XMLNode.Accept(tinyxml2wc.XMLVisitor*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:tinyxml2wc.XMLDeclaration'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.XMLElement.QueryIntAttribute(System.Char!System.Runtime.CompilerServices.IsConst*,System.Int32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.XMLElement.QueryIntText(System.Int32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.TiXMLDocument.Print(tinyxml2wc.XMLPrinter*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:tinyxml2wc.TiXMLDocument.NewDeclaration(System.Char!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:tinyxml2wc.XMLHandle'. -->
        <!-- Discarding badly formed XML document comment for member 'T:tinyxml2wc.XMLPrinter'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cConstraint.ID'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.setup_new_connection'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.poll_for_cookie(timeval!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.clearBuffers'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.pack_sender_description(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.pack_type_description(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Endpoint.status'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Endpoint.rhostname'. -->
        <!-- Discarding badly formed XML document comment for member 'T:timeval'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.connect_udp_to(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.set_tcp_outbuf_size(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.poll_for_cookie(timeval!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.clearBuffers'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.setNICaddress(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Endpoint_IP.d_udpLobSocket'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.getOneTCPMessage(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt64)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Endpoint_IP.d_tcpOutbuf'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Connection.d_endpoints'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Connection.handle_log_message(System.Void*,vrpn_HANDLERPARAM)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Connection.pack_type_description(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:timeval'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_copy_service_name(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_copy_file_name(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_copy_machine_name(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_TextPrinter.vrpn_TextPrinter_Watch_Entry.next'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_TextPrinter.d_ostream'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_BaseClassUnique.send_text_message(vrpn_TEXT_SEVERITY)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cTimeManager.Record(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cTimeManager.Record(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cTimeManager.Record(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.setup_new_connection'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.poll_for_cookie(timeval!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.clearBuffers'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.pack_sender_description(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.pack_type_description(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Endpoint.status'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Endpoint.rhostname'. -->
        <!-- Discarding badly formed XML document comment for member 'T:timeval'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.connect_udp_to(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.set_tcp_outbuf_size(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.poll_for_cookie(timeval!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.clearBuffers'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.setNICaddress(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Endpoint_IP.d_udpLobSocket'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.getOneTCPMessage(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt64)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Endpoint_IP.d_tcpOutbuf'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Connection.d_endpoints'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Connection.handle_log_message(System.Void*,vrpn_HANDLERPARAM)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Connection.pack_type_description(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:timeval'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_copy_service_name(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_copy_file_name(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_copy_machine_name(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_TextPrinter.vrpn_TextPrinter_Watch_Entry.next'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_TextPrinter.d_ostream'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_BaseClassUnique.send_text_message(vrpn_TEXT_SEVERITY)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cConstraint.ID'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cTimeManager.Record(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsObserved'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cCameraRay.IsTracked'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFilename.MakeRelativeTo(Core.cFilename!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cIChannel.KeyFrame(System.UInt32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.cFrameRangeSet.#ctor(std.vector<Core.cFrameRange,std.allocator<Core.cFrameRange>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cTimeManager.Record(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Core.Vector3.makeFloor(Core.Vector3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cDeviceNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.#ctor(Core.cUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<MoCapCore.cIPropertyProvider!System.Runtime.CompilerServices.IsConst>,System.UInt32,System.UInt32,System.UInt32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cCameraNode.SetActivePatternDepth(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:MoCapCore.cConstraint.ID'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.setup_new_connection'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.poll_for_cookie(timeval!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.clearBuffers'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.pack_sender_description(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint.pack_type_description(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Endpoint.status'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Endpoint.rhostname'. -->
        <!-- Discarding badly formed XML document comment for member 'T:timeval'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.connect_udp_to(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.set_tcp_outbuf_size(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.poll_for_cookie(timeval!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.clearBuffers'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.setNICaddress(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Endpoint_IP.d_udpLobSocket'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Endpoint_IP.getOneTCPMessage(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt64)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Endpoint_IP.d_tcpOutbuf'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_Connection.d_endpoints'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Connection.handle_log_message(System.Void*,vrpn_HANDLERPARAM)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_Connection.pack_type_description(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:timeval'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_copy_service_name(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_copy_file_name(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_copy_machine_name(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_TextPrinter.vrpn_TextPrinter_Watch_Entry.next'. -->
        <!-- Discarding badly formed XML document comment for member 'F:vrpn_TextPrinter.d_ostream'. -->
        <!-- Discarding badly formed XML document comment for member 'M:vrpn_BaseClassUnique.send_text_message(vrpn_TEXT_SEVERITY)'. -->
    </members>
</doc>